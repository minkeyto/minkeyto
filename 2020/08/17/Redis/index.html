<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis 教程 | 灵熙云工作室</title><meta name="robots" content="noindex"><meta name="description" content="概述什么是Redis　　Redis是用C语言开发的一个开源的高性能键值对（key-value）非关系性数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：   字符串类型 string 散列类型 hash 列"><meta name="keywords" content="SpringBoot,Redis,缓存,NoSQL,高可用,主从复制,哨兵机制,集群,RDB、AOF持久化,淘汰策略,LRU、LFU算法,穿透、击穿、雪崩,预热、降级,指标监控,Jedis,Servelet,RedisTemplate"><meta name="author" content="灵熙云,minkeyto@qq.com"><meta name="copyright" content="灵熙云"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/file/favicon.png"><link rel="canonical" href="http://www.goitman.cn/2020/08/17/Redis/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta name="msvalidate.01" content="8izvf3GqbX"/><meta property="og:type" content="article"><meta property="og:title" content="Redis 教程"><meta property="og:url" content="http://www.goitman.cn/2020/08/17/Redis/"><meta property="og:site_name" content="灵熙云工作室"><meta property="og:description" content="概述什么是Redis　　Redis是用C语言开发的一个开源的高性能键值对（key-value）非关系性数据库，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：   字符串类型 string 散列类型 hash 列"><meta property="og:image" content="https://s2.loli.net/2021/12/08/Xx7Fw6ApNDICcsz.jpg"><meta property="article:published_time" content="2020-08-17T03:17:39.048Z"><meta property="article:modified_time" content="2022-06-02T03:16:25.468Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5c009f46ba6df7bc385f101477536214";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-06-02 11:16:25'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/effect.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/file/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">38</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">139</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFRedis"><span class="toc-number">1.1.</span> <span class="toc-text">什么是Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.</span> <span class="toc-text">应用场景</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA"><span class="toc-number">2.</span> <span class="toc-text">环境搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Window"><span class="toc-number">2.1.</span> <span class="toc-text">Window</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%8D%95%E6%9C%BA"><span class="toc-number">2.1.1.</span> <span class="toc-text">Redis 单机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">目录结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E4%B8%8E%E5%85%B3%E9%97%AD"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">启动与关闭</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">redis客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4"><span class="toc-number">2.1.2.</span> <span class="toc-text">Redis 集群</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%876%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">准备6个实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.2.2.1.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E8%A3%85redis%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.2.2.2.</span> <span class="toc-text">安装redis服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDredis%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.2.2.3.</span> <span class="toc-text">卸载redis服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8redis%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.2.2.4.</span> <span class="toc-text">启动redis服务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2redis%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.2.2.5.</span> <span class="toc-text">停止redis服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redis-trib-rb%E5%88%9B%E5%BB%BA%E9%9B%86%E7%BE%A4"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">redis-trib.rb创建集群</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinel%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">sentinel哨兵配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAsentinel-conf"><span class="toc-number">2.1.2.4.1.</span> <span class="toc-text">创建sentinel.conf</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E5%93%A8%E5%85%B5%E6%9C%8D%E5%8A%A1"><span class="toc-number">2.1.2.4.2.</span> <span class="toc-text">启动哨兵服务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E4%B8%BB%E4%BB%8E%E5%8F%98%E5%8C%96"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">查看主从变化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux"><span class="toc-number">2.2.</span> <span class="toc-text">Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E5%8D%95%E6%9C%BA-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Redis 单机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87-1"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">环境准备</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85-1"><span class="toc-number">2.2.1.2.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.1.3.</span> <span class="toc-text">启动</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E5%90%AF%E5%8A%A8%EF%BC%88%E4%B8%8D%E6%8E%A8%E8%8D%90%EF%BC%89"><span class="toc-number">2.2.1.3.1.</span> <span class="toc-text">前端启动（不推荐）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.1.3.2.</span> <span class="toc-text">后台启动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.1.4.</span> <span class="toc-text">连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8redis-cli%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.1.4.1.</span> <span class="toc-text">使用redis-cli客户端连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%95%8C%E9%9D%A2%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.1.4.2.</span> <span class="toc-text">图形化界面连接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redis-%E9%9B%86%E7%BE%A4%EF%BC%88%E9%87%8D%E7%82%B9%EF%BC%89"><span class="toc-number">2.2.2.</span> <span class="toc-text">Redis 集群（重点）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%86%E5%A4%876%E4%B8%AA%E5%AE%9E%E4%BE%8B-1"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">准备6个实例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.2.1.1.</span> <span class="toc-text">复制实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">2.2.2.1.2.</span> <span class="toc-text">修改端口号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%8C%E6%97%B6%E5%90%AF%E5%8A%A86%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.2.2.1.3.</span> <span class="toc-text">同时启动6个实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">安装环境</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BAredis%E9%9B%86%E7%BE%A4"><span class="toc-number">2.2.2.3.</span> <span class="toc-text">创建redis集群</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%9B%86%E7%BE%A4%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.2.3.1.</span> <span class="toc-text">配置集群节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%90%AF%E5%8A%A8"><span class="toc-number">2.2.2.3.2.</span> <span class="toc-text">集群启动</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E7%9A%84%E5%A2%9E%E5%88%A0%E6%9F%A5%E6%94%B9"><span class="toc-number">2.2.2.4.</span> <span class="toc-text">节点的增删查改</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.2.4.1.</span> <span class="toc-text">增加主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A2%9E%E5%8A%A0%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.2.4.2.</span> <span class="toc-text">增加从节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%B8%BB%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.2.4.3.</span> <span class="toc-text">删除主节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E4%BB%8E%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.2.4.4.</span> <span class="toc-text">删除从节点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sentinel%E5%93%A8%E5%85%B5%E9%85%8D%E7%BD%AE-1"><span class="toc-number">2.2.2.5.</span> <span class="toc-text">sentinel哨兵配置</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">2.2.2.5.1.</span> <span class="toc-text">修改文件配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8sentinel"><span class="toc-number">2.2.2.5.2.</span> <span class="toc-text">启动sentinel</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Redis%E9%9B%86%E7%BE%A4%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.6.</span> <span class="toc-text">Redis集群连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.6.1.</span> <span class="toc-text">工具连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.2.2.6.2.</span> <span class="toc-text">代码连接</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E8%AF%A6%E6%83%85"><span class="toc-number">2.3.</span> <span class="toc-text">配置详情</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-conf"><span class="toc-number">2.3.1.</span> <span class="toc-text">redis.conf</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-sentinel-conf"><span class="toc-number">2.3.2.</span> <span class="toc-text">redis-sentinel.conf</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E5%8F%AF%E7%94%A8"><span class="toc-number">3.</span> <span class="toc-text">高可用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.</span> <span class="toc-text">主从复制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-1"><span class="toc-number">3.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%90%AD%E5%BB%BA"><span class="toc-number">3.1.2.</span> <span class="toc-text">搭建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.3.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%BA%93%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">主从库第一次全量复制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">3.1.3.1.1.</span> <span class="toc-text">建立连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%BA%93%E5%90%8C%E6%AD%A5%E6%95%B0%E6%8D%AE%E7%BB%99%E4%BB%8E%E5%BA%93"><span class="toc-number">3.1.3.1.2.</span> <span class="toc-text">主库同步数据给从库</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E6%96%B0%E5%86%99%E5%91%BD%E4%BB%A4%E5%88%B0%E4%BB%8E%E5%BA%93"><span class="toc-number">3.1.3.1.3.</span> <span class="toc-text">发送新写命令到从库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%87%8F%E5%A4%8D%E5%88%B6"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">增量复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%95%BF%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%91%BD%E4%BB%A4%E4%BC%A0%E6%92%AD"><span class="toc-number">3.1.3.3.</span> <span class="toc-text">基于长连接的命令传播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.4.</span> <span class="toc-text">相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">3.1.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">3.2.</span> <span class="toc-text">哨兵机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%A8%E5%85%B5%EF%BC%88Sentinel%EF%BC%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是哨兵（Sentinel）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.2.</span> <span class="toc-text">主要任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7"><span class="toc-number">3.2.2.1.</span> <span class="toc-text">监控</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF"><span class="toc-number">3.2.2.1.1.</span> <span class="toc-text">主观下线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF"><span class="toc-number">3.2.2.1.2.</span> <span class="toc-text">客观下线</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E8%A7%82%E4%B8%8B%E7%BA%BF%E4%B8%8E%E5%AE%A2%E8%A7%82%E4%B8%8B%E7%BA%BF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.2.1.3.</span> <span class="toc-text">主观下线与客观下线的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%88%87%E6%8D%A2%E4%B8%BB%E5%BA%93"><span class="toc-number">3.2.2.2.</span> <span class="toc-text">自动切换主库</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AD%9B%E9%80%89%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.2.2.1.</span> <span class="toc-text">筛选条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%89%93%E5%88%86"><span class="toc-number">3.2.2.2.2.</span> <span class="toc-text">打分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E7%9F%A5"><span class="toc-number">3.2.2.3.</span> <span class="toc-text">通知</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%A8%E5%85%B5%E7%9A%84%E4%B8%BB%E8%A6%81%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0%E7%9B%AE%E6%A0%87"><span class="toc-number">3.2.2.4.</span> <span class="toc-text">哨兵的主要任务与实现目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.3.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pub-x2F-sub-%E5%AE%9E%E7%8E%B0%E5%93%A8%E5%85%B5%E9%97%B4%E9%80%9A%E4%BF%A1%E5%92%8C%E5%8F%91%E7%8E%B0-slave"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">pub&#x2F;sub 实现哨兵间通信和发现 slave</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%93%A8%E5%85%B5%E6%89%A7%E8%A1%8C%E4%B8%BB%E4%BB%8E%E5%88%87%E6%8D%A2"><span class="toc-number">3.2.3.2.</span> <span class="toc-text">选择哨兵执行主从切换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87-pub-x2F-sub-%E5%AE%9E%E7%8E%B0%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BA%8B%E4%BB%B6%E9%80%9A%E7%9F%A5"><span class="toc-number">3.2.3.3.</span> <span class="toc-text">通过 pub&#x2F;sub 实现客户端事件通知</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%E4%B8%8E%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E"><span class="toc-number">3.2.4.</span> <span class="toc-text">注意事项与配置说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4"><span class="toc-number">3.3.</span> <span class="toc-text">集群</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-Cluster"><span class="toc-number">3.3.1.</span> <span class="toc-text">为什么需要 Cluster</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Cluster-%E9%9B%86%E7%BE%A4"><span class="toc-number">3.3.2.</span> <span class="toc-text">什么是 Cluster 集群</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E7%82%B9%E9%97%B4%E7%9A%84%E6%8F%A1%E6%89%8B"><span class="toc-number">3.3.3.</span> <span class="toc-text">节点间的握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.3.4.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%88%86%E6%88%90%E5%A4%9A%E4%BB%BD%E5%AD%98%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%AE%9E%E4%BE%8B%E4%B8%8A"><span class="toc-number">3.3.4.1.</span> <span class="toc-text">将数据分成多份存在不同实例上</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E6%A7%BD%E4%B8%8E-Redis-%E5%AE%9E%E4%BE%8B%E6%98%A0%E5%B0%84"><span class="toc-number">3.3.4.2.</span> <span class="toc-text">哈希槽与 Redis 实例映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E5%88%B6%E4%B8%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.3.4.3.</span> <span class="toc-text">复制与故障转移</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E6%A3%80%E6%B5%8B"><span class="toc-number">3.3.4.3.1.</span> <span class="toc-text">故障检测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB"><span class="toc-number">3.3.4.3.2.</span> <span class="toc-text">故障转移</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E4%B8%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">3.3.4.3.3.</span> <span class="toc-text">选主流程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E8%A1%A8%E4%BF%9D%E5%AD%98%E9%94%AE%E5%80%BC%E5%AF%B9%E5%92%8C%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%8F%AF%E8%A1%8C%E4%B9%88"><span class="toc-number">3.3.4.4.</span> <span class="toc-text">用表保存键值对和实例的关联关系可行么</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E6%95%B0%E6%8D%AE%E6%89%80%E5%9C%A8%E5%AE%9E%E4%BE%8B"><span class="toc-number">3.3.5.</span> <span class="toc-text">客户端如何定位数据所在实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E5%93%88%E5%B8%8C%E6%A7%BD"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">重新分配哈希槽</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#MOVED-%E9%94%99%E8%AF%AF"><span class="toc-number">3.3.5.1.1.</span> <span class="toc-text">MOVED 错误</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ASK-%E9%94%99%E8%AF%AF"><span class="toc-number">3.3.5.1.2.</span> <span class="toc-text">ASK 错误</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E7%BE%A4%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E5%A4%9A%E5%A4%A7"><span class="toc-number">3.3.6.</span> <span class="toc-text">集群可以设置多大</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Gossip-%E6%B6%88%E6%81%AF"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">Gossip 消息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E7%9A%84%E9%80%9A%E4%BF%A1%E9%A2%91%E7%8E%87"><span class="toc-number">3.3.6.2.</span> <span class="toc-text">实例的通信频率</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">4.</span> <span class="toc-text">基础命令</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">4.1.</span> <span class="toc-text">远程连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keys-pattern"><span class="toc-number">4.2.</span> <span class="toc-text">keys pattern</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#del-key1-key2%E2%80%A6"><span class="toc-number">4.3.</span> <span class="toc-text">del key1 key2…</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exists-key"><span class="toc-number">4.4.</span> <span class="toc-text">exists key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-key"><span class="toc-number">4.5.</span> <span class="toc-text">type key</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select"><span class="toc-number">4.6.</span> <span class="toc-text">select</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#move"><span class="toc-number">4.7.</span> <span class="toc-text">move</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#info"><span class="toc-number">4.8.</span> <span class="toc-text">info</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Help"><span class="toc-number">4.9.</span> <span class="toc-text">Help</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">Redis的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E7%9A%845%E7%A7%8D%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">Redis的5种基本类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#String-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.1.1.</span> <span class="toc-text">String(字符串)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-2"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hash-%E5%93%88%E5%B8%8C%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.2.</span> <span class="toc-text">Hash(哈希类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-3"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-1"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#List-%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.3.</span> <span class="toc-text">List(列表类型)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-4"><span class="toc-number">5.1.3.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-2"><span class="toc-number">5.1.3.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Set-%E6%97%A0%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">5.1.4.</span> <span class="toc-text">Set(无序集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-5"><span class="toc-number">5.1.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-3"><span class="toc-number">5.1.4.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sorted-ZSet-%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88"><span class="toc-number">5.1.5.</span> <span class="toc-text">Sorted ZSet(有序集合)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0-6"><span class="toc-number">5.1.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E5%92%8C%E5%88%97%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.5.2.</span> <span class="toc-text">有序集合和列表类型区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-4"><span class="toc-number">5.1.5.3.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">5.1.6.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E6%96%B0%E7%9A%843%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">Redis新的3种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bitmaps-%E4%BD%8D%E6%93%8D%E4%BD%9C%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.2.1.</span> <span class="toc-text">Bitmaps(位操作字符串)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-5"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bitmaps%E4%B8%8Eset%E6%AF%94%E8%BE%83"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">bitmaps与set比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HyperLoglog-%E5%9F%BA%E6%95%B0%E7%BB%9F%E8%AE%A1"><span class="toc-number">5.2.2.</span> <span class="toc-text">HyperLoglog(基数统计)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4-6"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Geographic-%E5%9C%B0%E7%90%86%E4%BF%A1%E6%81%AF"><span class="toc-number">5.2.3.</span> <span class="toc-text">Geographic(地理信息)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-2"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">常见命令</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.</span> <span class="toc-text">Redis的持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%A6%82%E8%BF%B0"><span class="toc-number">6.1.</span> <span class="toc-text">持久化概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RDB%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">RDB持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">6.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">6.2.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">6.2.3.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">6.3.</span> <span class="toc-text">AOF持久化机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-1"><span class="toc-number">6.3.2.</span> <span class="toc-text">缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-1"><span class="toc-number">6.3.3.</span> <span class="toc-text">配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E5%90%AFAOF%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">6.3.3.1.</span> <span class="toc-text">开启AOF持久化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOF%E6%8C%81%E4%B9%85%E5%8C%96%E6%97%B6%E6%9C%BA"><span class="toc-number">6.3.3.2.</span> <span class="toc-text">AOF持久化时机</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E4%B8%8E%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">7.</span> <span class="toc-text">过期与淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E5%8D%A0%E7%94%A8%E5%86%85%E5%AD%98"><span class="toc-number">7.1.</span> <span class="toc-text">设置占用内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5"><span class="toc-number">7.2.</span> <span class="toc-text">过期策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">7.3.</span> <span class="toc-text">淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="toc-number">7.3.1.</span> <span class="toc-text">文件设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BF%AE%E6%94%B9"><span class="toc-number">7.3.2.</span> <span class="toc-text">命令修改</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.3.</span> <span class="toc-text">LRU算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8Redis%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">在Redis中的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%91%E4%BC%BCLRU%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.3.1.1.</span> <span class="toc-text">近似LRU算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Redis3-0%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">7.3.3.1.2.</span> <span class="toc-text">Redis3.0的优化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LFU%E7%AE%97%E6%B3%95"><span class="toc-number">7.3.4.</span> <span class="toc-text">LFU算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LRU%E4%B8%8ELFU%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.3.5.</span> <span class="toc-text">LRU与LFU的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.</span> <span class="toc-text">缓存设计</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">8.1.</span> <span class="toc-text">缓存穿透</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">8.1.1.</span> <span class="toc-text">什么是缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F"><span class="toc-number">8.1.2.</span> <span class="toc-text">有什么解决方案来防止缓存穿透</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">8.1.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">8.2.</span> <span class="toc-text">缓存击穿</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是缓存击穿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">8.2.2.</span> <span class="toc-text">问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.3.</span> <span class="toc-text">解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81-mutex-key"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">使用互斥锁(mutex key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E5%89%8D%E4%BD%BF%E7%94%A8%E4%BA%92%E6%96%A5%E9%94%81-mutex-key"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">提前使用互斥锁(mutex key)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%BF%87%E6%9C%9F"><span class="toc-number">8.2.3.3.</span> <span class="toc-text">永远不过期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.2.3.4.</span> <span class="toc-text">资源保护</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-2"><span class="toc-number">8.2.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">8.3.</span> <span class="toc-text">缓存雪崩</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">8.3.1.</span> <span class="toc-text">什么是缓存雪崩</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">8.3.2.</span> <span class="toc-text">缓存雪崩问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%9D%A5%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%EF%BC%9F"><span class="toc-number">8.3.3.</span> <span class="toc-text">有什么解决方案来防止缓存雪崩？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-3"><span class="toc-number">8.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">8.4.</span> <span class="toc-text">缓存预热</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BC%93%E5%AD%98%E9%A2%84%E7%83%AD"><span class="toc-number">8.4.1.</span> <span class="toc-text">什么是缓存预热</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5-1"><span class="toc-number">8.4.2.</span> <span class="toc-text">问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E4%BB%80%E4%B9%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">8.4.3.</span> <span class="toc-text">有什么解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-4"><span class="toc-number">8.4.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E9%99%8D%E7%BA%A7"><span class="toc-number">8.5.</span> <span class="toc-text">缓存降级</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Jedis%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">9.</span> <span class="toc-text">Jedis的基本使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8B%E7%BB%8D"><span class="toc-number">9.1.</span> <span class="toc-text">介绍</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text">基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API"><span class="toc-number">9.2.1.</span> <span class="toc-text">常用API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C"><span class="toc-number">9.2.2.</span> <span class="toc-text">代码操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">9.3.</span> <span class="toc-text">连接池的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.3.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8API-1"><span class="toc-number">9.3.1.1.</span> <span class="toc-text">常用API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%93%8D%E4%BD%9C-1"><span class="toc-number">9.3.2.</span> <span class="toc-text">代码操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">9.4.</span> <span class="toc-text">连接池工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-1"><span class="toc-number">9.4.1.</span> <span class="toc-text">配置文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">9.4.2.</span> <span class="toc-text">工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81"><span class="toc-number">9.4.3.</span> <span class="toc-text">测试代码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Servelet%E6%95%B4%E5%90%88Redis"><span class="toc-number">10.</span> <span class="toc-text">Servelet整合Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%80%E6%B1%82"><span class="toc-number">10.1.</span> <span class="toc-text">需求</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6-2"><span class="toc-number">10.2.</span> <span class="toc-text">配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#druid-properties"><span class="toc-number">10.2.1.</span> <span class="toc-text">druid.properties</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jedis-properties"><span class="toc-number">10.2.2.</span> <span class="toc-text">jedis.properties</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E7%B1%BB"><span class="toc-number">10.3.</span> <span class="toc-text">实体类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Province-java"><span class="toc-number">10.3.1.</span> <span class="toc-text">Province.java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB-1"><span class="toc-number">10.4.</span> <span class="toc-text">工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JdbcUtils-java"><span class="toc-number">10.4.1.</span> <span class="toc-text">JdbcUtils.java</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JedisUtils-java"><span class="toc-number">10.4.2.</span> <span class="toc-text">JedisUtils.java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">10.5.</span> <span class="toc-text">过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CharchaterFilter-java"><span class="toc-number">10.5.1.</span> <span class="toc-text">CharchaterFilter.java</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2"><span class="toc-number">10.6.</span> <span class="toc-text">页面</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#index-jsp"><span class="toc-number">10.6.1.</span> <span class="toc-text">index.jsp</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91"><span class="toc-number">10.7.</span> <span class="toc-text">逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SelectProvinceServelt"><span class="toc-number">10.7.1.</span> <span class="toc-text">SelectProvinceServelt</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProvinceService"><span class="toc-number">10.7.2.</span> <span class="toc-text">ProvinceService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ProvinceDao"><span class="toc-number">10.7.3.</span> <span class="toc-text">ProvinceDao</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#SpringBoot%E6%95%B4%E5%90%88Redis"><span class="toc-number">11.</span> <span class="toc-text">SpringBoot整合Redis</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96"><span class="toc-number">11.1.</span> <span class="toc-text">依赖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-2"><span class="toc-number">11.2.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Redis%E4%BA%8B%E5%8A%A1"><span class="toc-number">11.3.</span> <span class="toc-text">Redis事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-3"><span class="toc-number">11.3.1.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E8%AE%AE"><span class="toc-number">11.3.2.</span> <span class="toc-text">建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StringRedisTemplate-%E5%92%8C-RedisTemplate"><span class="toc-number">11.4.</span> <span class="toc-text">StringRedisTemplate 和 RedisTemplate</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9"><span class="toc-number">11.4.1.</span> <span class="toc-text">选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB"><span class="toc-number">11.4.2.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#RedisTemplate%E7%94%A8%E6%B3%95"><span class="toc-number">12.</span> <span class="toc-text">RedisTemplate用法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#String%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.1.</span> <span class="toc-text">String数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Set%E8%AE%BE%E7%BD%AE"><span class="toc-number">12.1.1.</span> <span class="toc-text">Set设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Get%E8%8E%B7%E5%8F%96"><span class="toc-number">12.1.2.</span> <span class="toc-text">Get获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Append-%E8%BF%BD%E5%8A%A0%E3%80%81Size%E9%95%BF%E5%BA%A6"><span class="toc-number">12.1.3.</span> <span class="toc-text">Append 追加、Size长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increment-%E5%A2%9E%E9%87%8F"><span class="toc-number">12.1.4.</span> <span class="toc-text">increment 增量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.</span> <span class="toc-text">List数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE"><span class="toc-number">12.2.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96"><span class="toc-number">12.2.2.</span> <span class="toc-text">获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%AA%E5%8F%96"><span class="toc-number">12.2.3.</span> <span class="toc-text">截取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4"><span class="toc-number">12.2.4.</span> <span class="toc-text">移除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Hash%E6%95%B0%E6%8D%AE%E6%9C%BA%E6%9E%84"><span class="toc-number">12.3.</span> <span class="toc-text">Hash数据机构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-1"><span class="toc-number">12.3.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-1"><span class="toc-number">12.3.2.</span> <span class="toc-text">获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4-1"><span class="toc-number">12.3.3.</span> <span class="toc-text">移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD"><span class="toc-number">12.3.4.</span> <span class="toc-text">判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.4.</span> <span class="toc-text">Set数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-2"><span class="toc-number">12.4.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-2"><span class="toc-number">12.4.2.</span> <span class="toc-text">获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4-2"><span class="toc-number">12.4.3.</span> <span class="toc-text">移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E5%8A%A8"><span class="toc-number">12.4.4.</span> <span class="toc-text">移动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A4%E6%96%AD-1"><span class="toc-number">12.4.5.</span> <span class="toc-text">判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86"><span class="toc-number">12.4.6.</span> <span class="toc-text">交集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86"><span class="toc-number">12.4.7.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%AE%E9%9B%86"><span class="toc-number">12.4.8.</span> <span class="toc-text">差集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ZSet%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">12.5.</span> <span class="toc-text">ZSet数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE-3"><span class="toc-number">12.5.1.</span> <span class="toc-text">设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-3"><span class="toc-number">12.5.2.</span> <span class="toc-text">获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%BB%E9%99%A4-3"><span class="toc-number">12.5.3.</span> <span class="toc-text">移除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E9%9B%86-1"><span class="toc-number">12.5.4.</span> <span class="toc-text">并集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E9%9B%86-1"><span class="toc-number">12.5.5.</span> <span class="toc-text">交集</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2"><span class="toc-number">12.6.</span> <span class="toc-text">模糊查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Key"><span class="toc-number">12.6.1.</span> <span class="toc-text">查询Key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2Hash%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84HK"><span class="toc-number">12.6.2.</span> <span class="toc-text">查询Hash数据中的HK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.6.3.</span> <span class="toc-text">序列化</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">13.</span> <span class="toc-text">发布订阅</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.1.</span> <span class="toc-text">命令行实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A2%E9%98%85%E4%B8%BB%E9%A2%98"><span class="toc-number">13.1.1.</span> <span class="toc-text">订阅主题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E8%AE%A2%E9%98%85"><span class="toc-number">13.1.2.</span> <span class="toc-text">模式匹配订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E5%B8%83%E6%B6%88%E6%81%AF"><span class="toc-number">13.1.3.</span> <span class="toc-text">发布消息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E8%AE%A2%E9%98%85"><span class="toc-number">13.1.4.</span> <span class="toc-text">取消订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95"><span class="toc-number">13.1.5.</span> <span class="toc-text">测试</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SpringBoot%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.2.</span> <span class="toc-text">SpringBoot实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Stream"><span class="toc-number">13.3.</span> <span class="toc-text">Stream</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">14.</span> <span class="toc-text">使用规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E5%80%BC%E5%AF%B9%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">14.1.</span> <span class="toc-text">键值对使用规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#key-%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">14.1.1.</span> <span class="toc-text">key 命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-bigkey"><span class="toc-number">14.1.2.</span> <span class="toc-text">不要使用 bigkey</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%AB%98%E6%95%88%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8E%8B%E7%BC%A9%E6%96%B9%E6%B3%95"><span class="toc-number">14.1.3.</span> <span class="toc-text">使用高效序列化和压缩方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%95%B4%E6%95%B0%E5%AF%B9%E8%B1%A1%E5%85%B1%E4%BA%AB%E6%B1%A0"><span class="toc-number">14.1.4.</span> <span class="toc-text">使用整数对象共享池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83"><span class="toc-number">14.2.</span> <span class="toc-text">命令使用规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%A6%81%E7%94%A8%E7%9A%84%E6%8C%87%E4%BB%A4"><span class="toc-number">14.2.1.</span> <span class="toc-text">生产禁用的指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%8E%E7%94%A8-MONITOR-%E5%91%BD%E4%BB%A4"><span class="toc-number">14.2.2.</span> <span class="toc-text">慎用 MONITOR 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%8E%E7%94%A8%E5%85%A8%E9%87%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4"><span class="toc-number">14.2.3.</span> <span class="toc-text">慎用全量操作命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E8%A7%84%E8%8C%83"><span class="toc-number">14.3.</span> <span class="toc-text">数据保存规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B7%E7%83%AD%E6%95%B0%E6%8D%AE%E5%88%86%E7%A6%BB"><span class="toc-number">14.3.1.</span> <span class="toc-text">冷热数据分离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E6%95%B0%E6%8D%AE%E9%9A%94%E7%A6%BB"><span class="toc-number">14.3.2.</span> <span class="toc-text">业务数据隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E7%BD%AE%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">14.3.3.</span> <span class="toc-text">设置过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%8D%95%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%86%85%E5%AD%98%E5%AE%B9%E9%87%8F"><span class="toc-number">14.3.4.</span> <span class="toc-text">控制单实例的内存容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9"><span class="toc-number">14.3.5.</span> <span class="toc-text">防止缓存雪崩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%BB%B4%E8%A7%84%E8%8C%83"><span class="toc-number">14.4.</span> <span class="toc-text">运维规范</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87"><span class="toc-number">15.</span> <span class="toc-text">监控指标</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87-Performance"><span class="toc-number">15.1.</span> <span class="toc-text">性能指标 Performance</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%8C%87%E6%A0%87-Memory"><span class="toc-number">15.2.</span> <span class="toc-text">内存指标 Memory</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%B4%BB%E5%8A%A8%E6%8C%87%E6%A0%87-Basic-activity"><span class="toc-number">15.3.</span> <span class="toc-text">基本活动指标 Basic activity</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%E6%8C%87%E6%A0%87-Persistence"><span class="toc-number">15.4.</span> <span class="toc-text">持久性指标 Persistence</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E6%8C%87%E6%A0%87-Error"><span class="toc-number">15.5.</span> <span class="toc-text">错误指标 Error</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%96%B9%E5%BC%8F"><span class="toc-number">15.6.</span> <span class="toc-text">监控方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-benchmark"><span class="toc-number">15.6.1.</span> <span class="toc-text">redis-benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-stat"><span class="toc-number">15.6.2.</span> <span class="toc-text">redis-stat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-faina"><span class="toc-number">15.6.3.</span> <span class="toc-text">redis-faina</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redislive"><span class="toc-number">15.6.4.</span> <span class="toc-text">redislive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#redis-cli"><span class="toc-number">15.6.5.</span> <span class="toc-text">redis-cli</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#slowlog"><span class="toc-number">15.6.5.1.</span> <span class="toc-text">slowlog</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#info-1"><span class="toc-number">15.6.5.2.</span> <span class="toc-text">info</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2021/12/08/Xx7Fw6ApNDICcsz.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">灵熙云工作室</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Redis 教程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-08-17 11:17:39"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-08-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-06-02 11:16:25"><i class="fas fa-history fa-fw"></i> 更新于 2022-06-02</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">52.3k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 196 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2020/08/17/Redis/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/08/17/Redis/" itemprop="commentCount"></span></a></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="什么是Redis"><a href="#什么是Redis" class="headerlink" title="什么是Redis"></a>什么是Redis</h2><p>　　Redis是用C语言开发的一个开源的高性能<code>键值对（key-value）非关系性数据库</code>，官方提供测试数据，50个并发执行100000个请求,读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s，且Redis通过提供多种键值数据类型来适应不同场景下的存储需求，目前为止Redis支持的键值数据类型如下：</p>
<blockquote>
<ol>
<li>字符串类型 string</li>
<li>散列类型 hash</li>
<li>列表类型 list</li>
<li>集合类型 set</li>
<li>有序集合类型 sortedset</li>
</ol>
</blockquote>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>缓存<br>数据查询、短连接、新闻内容、商品内容、对象缓存、全页缓存热点数据等等</li>
<li>聊天室的在线好友列表</li>
<li>任务队列<br>秒杀、抢购、12306等等</li>
<li>限流<br>int类型，incr方法；以访问者的ip和其他信息作为key，访问一次增加一次计数，超过次数则返回false</li>
<li>购物车<br>String 或hash。所有String可以做的hash都可以做</li>
<li>商品标签</li>
<li>商品筛选</li>
<li>用户关注、推荐模型</li>
<li>应用排行榜</li>
<li>网站访问统计</li>
<li>计数器<br>int类型，incr方法，例如：文章的阅读量、微博点赞数、允许一定的延迟，先写入Redis再定时同步到数据库</li>
<li>位统计<br>String类型的bitcount（1.6.6的bitmap数据结构），字符是以8位二进制存储的</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span> k1 a</span><br><span class="line">setbit k1 6 1</span><br><span class="line">setbit k1 7 0</span><br><span class="line">get k1 </span><br><span class="line">/* 6 7 代表的a的二进制位的修改</span><br><span class="line"></span><br><span class="line">a 对应的ASCII码是97，转换为二进制数据是01100001</span><br><span class="line">b 对应的ASCII码是98，转换为二进制数据是01100010</span><br><span class="line"></span><br><span class="line">因为bit非常节省空间（1 MB=8388608 bit），可以用来做大数据量的统计。</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>

<p>例如：在线用户统计，留存用户统计</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">setbit onlineusers 01 </span><br><span class="line">setbit onlineusers 11 </span><br><span class="line">setbit onlineusers 20</span><br></pre></td></tr></table></figure>

<p>支持按位与、按位或等等操作</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BITOPANDdestkeykey[key...] ，对一个或多个 key 求逻辑并，并将结果保存到 destkey 。       </span><br><span class="line">BITOPORdestkeykey[key...] ，对一个或多个 key 求逻辑或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPXORdestkeykey[key...] ，对一个或多个 key 求逻辑异或，并将结果保存到 destkey 。 </span><br><span class="line">BITOPNOTdestkeykey ，对给定 key 求逻辑非，并将结果保存到 destkey 。</span><br></pre></td></tr></table></figure>

<p>计算出7天都在线的用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BITOP <span class="string">&quot;AND&quot;</span> <span class="string">&quot;7_days_both_online_users&quot;</span> <span class="string">&quot;day_1_online_users&quot;</span> <span class="string">&quot;day_2_online_users&quot;</span> ...  <span class="string">&quot;day_7_online_users&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>全局ID<br>int类型，incrby，利用原子性，分库分表的场景，一次性拿一段。</li>
<li>数据过期处理（可以精确到毫秒)</li>
<li>分布式集群架构中的session分离</li>
<li>分布式锁<br>String类型setnx方法，只有不存在时才能添加成功，返回true</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">getLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    <span class="type">Long</span> <span class="variable">flag</span> <span class="operator">=</span> jedis.setnx(key, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">        jedis.expire(key, <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">return</span> <span class="variable">flag</span> <span class="operator">=</span>= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">releaseLock</span><span class="params">(String key)</span> &#123;</span><br><span class="line">    jedis.del(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>抽奖<br>自带一个随机获得值：spop myset</p>
</li>
<li><p>点赞、签到、打卡<br>假如ID是t1001，用户ID是u3001，用 like:t1001 来维护 t1001 这条微博的所有点赞用户</p>
</li>
</ul>
<blockquote>
<p>点赞了这条微博：sadd like:t1001 u3001<br>取消点赞：srem like:t1001 u3001<br>是否点赞：sismember like:t1001 u3001<br>点赞的所有用户：smembers like:t1001<br>点赞数：scard like:t1001</p>
</blockquote>
<p>　　总结，只要希望查询快就可以使用redis，但是mysql中的数据如果频繁的更新，就不建议使用redis了，否则redis会频繁的从mysql不断更新数据，会导致redis慢了。<code>redis适合存储经常查询又不经常更新的数据。</code></p>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><p>从GitHub上下载window版的Redis（本文Window环境使用<code>Redis-x64-3.2.100</code>版本），下载地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/MSOpenTech/redis/tags">https://github.com/MSOpenTech/redis/tags</a></p>
</blockquote>
<h3 id="Redis-单机"><a href="#Redis-单机" class="headerlink" title="Redis 单机"></a>Redis 单机</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>window版的安装及其简单，<code>解压Redis压缩包即可</code></p>
<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><p>解压Redis压缩包后，见到如下目录机构：<br><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/rlCWPm3OVGipa4q.png"></p>
<h4 id="启动与关闭"><a href="#启动与关闭" class="headerlink" title="启动与关闭"></a>启动与关闭</h4><p>双击Redis目录中<code>redis-server.exe</code>可以启动redis服务，Redis服务占用的端口是<code>6379</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/LzhMBTHvpO1acCi.png"><br><code>关闭Redis的控制台窗口就可以关闭Redis服务</code></p>
<h4 id="redis客户端"><a href="#redis客户端" class="headerlink" title="redis客户端"></a>redis客户端</h4><p>双击Redis目录中<code>redis-cli.exe</code>，启动<code>redis客户端</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/dXZ6vB1owNSzFEj.png" alt="15.png"></p>
<p><code>注：redis所在的硬盘位置的盘符，硬盘空间必须有20G以上。redis解压到非中文目录里面，目录结构不要太深</code>
　</p>
<h3 id="Redis-集群"><a href="#Redis-集群" class="headerlink" title="Redis 集群"></a>Redis 集群</h3><p><code>redis-trib.rb</code>是采用Ruby实现的Redis<code>集群管理工具</code>。内部通过Cluster(集群)相关命令帮我们<code>简化集群创建、检查、槽迁移和均衡等常见运维操作</code>，使用之前需要安装 Ruby 依赖环境。</p>
<blockquote>
<p><code>注：redis-trib.rb没有实现哨兵机制，需另配置</code></p>
</blockquote>
<h4 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h4><p>使用<code>redis-trib.rb工具</code>创建Redis集群，由于该文件是用ruby语言写的，所以需要安装<code>Ruby开发环境</code>，以及<code>驱动redis-xxxx.gem</code>，所以除了Redis安装文件外，还需要下载如上所述三个文件：</p>
<ul>
<li>redis-trib.rb文件，下载地址：(<code>Redis-x64-3.2.100 解压目录中已有redis-trib.rb文件，无需下载</code>，3.0以上版本应该都有)</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/beebol/redis-trib.rb">https://github.com/beebol/redis-trib.rb</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/kEFB4DsipoUTIbw.png"></p>
<ul>
<li>安装ruby开发环境（本文使用<code>rubyinstaller-2.2.4-x64.exe</code>安装版），下载地址：</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://dl.bintray.com/oneclick/rubyinstaller/">http://dl.bintray.com/oneclick/rubyinstaller/</a></p>
</blockquote>
<p>双击<code>rubyinstaller-2.2.4-x64.exe</code>，选中如图两个选项（意义为<code>将ruby添加到系统环境变量中，在cmd命令中能直接使用ruby命令</code>），之后就是傻瓜式安装啦</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/VcChtk7JTrdsjF6.png"></p>
<ul>
<li>安装驱动redis-xxxx.gem（本文使用<code>3.2.2</code>版本），下载地址：</li>
</ul>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://rubygems.org/gems/redis/versions">https://rubygems.org/gems/redis/versions</a></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/O8CvrSjLexUB2tq.png"></p>
<p><code>将驱动redis-xxxx.gem拷贝到Ruby安装根目录下</code>，在此目录执行cmd命令安装</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install --<span class="built_in">local</span> path_to_gem/filename.gem  </span><br></pre></td></tr></table></figure>

<h4 id="准备6个实例"><a href="#准备6个实例" class="headerlink" title="准备6个实例"></a>准备6个实例</h4><h5 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h5><p><code>在Redis安装根目录下，创建编码格式为utf-8的配置文件：redis.6380.conf、redis.6381.conf、redis.6382.conf、redis.6383.conf、redis.6384.conf、redis.6385.conf。</code>（Redis默认端口为6379，这里使用6380-6385六个端口）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 以redis.6380.conf</span></span><br><span class="line">port 6380      </span><br><span class="line">loglevel notice    </span><br><span class="line">logfile <span class="string">&quot;E:/Redis-Cluster/Redis-x64-3.2.100/Logs/redis6380_log.txt&quot;</span>       </span><br><span class="line">appendonly <span class="built_in">yes</span></span><br><span class="line">appendfilename <span class="string">&quot;appendonly.6380.aof&quot;</span>   </span><br><span class="line">cluster-enabled <span class="built_in">yes</span>                                    </span><br><span class="line">cluster-config-file nodes.6380.conf</span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">cluster-slave-validity-factor 10</span><br><span class="line">cluster-migration-barrier 1</span><br><span class="line">cluster-require-full-coverage <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>属性解析：</p>
<ol>
<li>其他配置文件<code>只需将port、logfile、appendfilename、cluster-config-file中的6380修改为相应的端口号即可</code></li>
<li>loglevel：日志的记录级别，<code>notice是适合生产环境</code>的</li>
<li>logfile：指定log的保存路径（默认是创建在Redis安装目录下），此处手动创建Logs目录</li>
<li>appendonly：<code>持久化模式为aof格式</code></li>
<li>appendfilename：持久化文件</li>
<li>cluster-config-file：节点配置文件</li>
<li>cluster-enabled：<code>是否开启集群</code></li>
</ol>
</blockquote>
<h5 id="安装redis服务"><a href="#安装redis服务" class="headerlink" title="安装redis服务"></a>安装redis服务</h5><p><code>使用完整路径，避免集群出现问题</code>　</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6380.conf --service-name redis6380</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6381.conf --service-name redis6381</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6382.conf --service-name redis6382</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6383.conf --service-name redis6383</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6384.conf --service-name redis6384</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-install E:/Redis-Cluster/Redis-x64-3.2.100/redis.6385.conf --service-name redis6385</span><br></pre></td></tr></table></figure>

<h5 id="卸载redis服务"><a href="#卸载redis服务" class="headerlink" title="卸载redis服务"></a>卸载redis服务</h5><p>只需把安装命令中的<code>--service-install</code>修改为<code>--service-uninstall</code>即可，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-uninstall E:/Redis-Cluster/Redis-x64-3.2.100/redis.6380.conf --service-name redis6380</span><br></pre></td></tr></table></figure>


<h5 id="启动redis服务"><a href="#启动redis服务" class="headerlink" title="启动redis服务"></a>启动redis服务</h5><p><code>使用完整路径，避免集群出现问题</code>　</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6380</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6381</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6382</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6383</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6384</span><br><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-start --service-name redis6385</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/fFJlM5ZpQo8kymg.png"></p>
<blockquote>
<p><code>注：如果服务状态在正在运行时执行了卸载命令，这时服务窗口的Redis服务还是会显示，只有当服务停止后才不会再显示</code></p>
</blockquote>
<h5 id="停止redis服务"><a href="#停止redis服务" class="headerlink" title="停止redis服务"></a>停止redis服务</h5><p>只需把安装命令中的<code>--service-start</code>修改为<code>--service-stop</code>即可，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-server.exe --service-stop --service-name redis6380</span><br></pre></td></tr></table></figure>



<h4 id="redis-trib-rb创建集群"><a href="#redis-trib-rb创建集群" class="headerlink" title="redis-trib.rb创建集群"></a>redis-trib.rb创建集群</h4><p>将<code>redis-trib.rb文件拷贝到Redis安装目录下</code>，在此目录执行cmd命令创建集群(<code>若解压目录中有redis-trib.rb文件，可直接执行cmd命令创建集群</code>)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">E:/Redis-Cluster/Redis-x64-3.2.100/redis-trib.rb create --replicas 1 127.0.0.1:6380 127.0.0.1:6381 127.0.0.1:6382 127.0.0.1:6383 127.0.0.1:6384 127.0.0.1:6385</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.&#x2F;redis-trib.rb create –replicas X<br>X：指定集群中<code>每个主节点配备几个从节点</code>，这里设置为1</p>
</blockquote>
<p>启动信息（<code>中间会提示是否设置配置，输入yes</code>）,<code>每个主节点分配的哈希槽信息和主从分配信息在此都可查看</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Creating cluster</span><br><span class="line">Connecting to node 127.0.0.1:6380: OK</span><br><span class="line">Connecting to node 127.0.0.1:6381: OK</span><br><span class="line">Connecting to node 127.0.0.1:6382: OK</span><br><span class="line">Connecting to node 127.0.0.1:6383: OK</span><br><span class="line">Connecting to node 127.0.0.1:6384: OK</span><br><span class="line">Connecting to node 127.0.0.1:6385: OK</span><br><span class="line">&gt;&gt;&gt; Performing <span class="built_in">hash</span> slots allocation on 6 nodes...</span><br><span class="line">Using 3 masters:</span><br><span class="line">127.0.0.1:6380</span><br><span class="line">127.0.0.1:6381</span><br><span class="line">127.0.0.1:6382</span><br><span class="line">Adding replica 127.0.0.1:6383 to 127.0.0.1:6380</span><br><span class="line">Adding replica 127.0.0.1:6384 to 127.0.0.1:6381</span><br><span class="line">Adding replica 127.0.0.1:6385 to 127.0.0.1:6382</span><br><span class="line">M: bb6ef615bb0ae13275943caec0db9d30b9f35c5e 127.0.0.1:6380   slots:0-5460      (5461 slots) master</span><br><span class="line">M: b4d120f2983ad683f7b68992e1ba414722238db7 127.0.0.1:6381   slots:5461-10922  (5462 slots) master</span><br><span class="line">M: 837779b3965e2c9d4dd4385750aaaaf9a9039fb0 127.0.0.1:6382   slots:10923-16383 (5461 slots) master</span><br><span class="line">S: 5d154137180284d926ef51a91fc75f9438249ef8 127.0.0.1:6383   replicates bb6ef615bb0ae13275943caec0db9d30b9f35c5e</span><br><span class="line">S: ad151680a3e36cf2083ef822be0bdb075a7d36de 127.0.0.1:6384   replicates b4d120f2983ad683f7b68992e1ba414722238db7</span><br><span class="line">S: 9a2260a5a6a2add84b622a453a6a7b86a29d180d 127.0.0.1:6385   replicates 837779b3965e2c9d4dd4385750aaaaf9a9039fb0</span><br><span class="line">Can I <span class="built_in">set</span> the above configuration? (<span class="built_in">type</span> <span class="string">&#x27;yes&#x27;</span> to accept): <span class="built_in">yes</span></span><br><span class="line">&gt;&gt;&gt; Nodes configuration updated</span><br><span class="line">&gt;&gt;&gt; Assign a different config epoch to each node</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER MEET messages to <span class="built_in">join</span> the cluster</span><br><span class="line">Waiting <span class="keyword">for</span> the cluster to <span class="built_in">join</span>...</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 127.0.0.1:6380)M: bb6ef615bb0ae13275943caec0db9d30b9f35c5e 127.0.0.1:6380   slots:0-5460      (5461 slots) master</span><br><span class="line">M: b4d120f2983ad683f7b68992e1ba414722238db7 127.0.0.1:6381   slots:5461-10922  (5462 slots) master</span><br><span class="line">M: 837779b3965e2c9d4dd4385750aaaaf9a9039fb0 127.0.0.1:6382   slots:10923-16383 (5461 slots) master</span><br><span class="line">M: 5d154137180284d926ef51a91fc75f9438249ef8 127.0.0.1:6383   slots:            (0 slots)    master   replicates bb6ef615bb0ae13275943caec0db9d30b9f35c5e</span><br><span class="line">M: ad151680a3e36cf2083ef822be0bdb075a7d36de 127.0.0.1:6384   slots:            (0 slots)    master   replicates b4d120f2983ad683f7b68992e1ba414722238db7</span><br><span class="line">M: 9a2260a5a6a2add84b622a453a6a7b86a29d180d 127.0.0.1:6385   slots:            (0 slots)    master   replicates 837779b3965e2c9d4dd4385750aaaaf9a9039fb0</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>

<ul>
<li><code>redis-trib.rb工具的使用</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#创建集群</span><br><span class="line">create          host1:port1 ... hostN:portN  </span><br><span class="line">                  --replicas &lt;arg&gt; #带上该参数表示是否有从，arg表示从的数量</span><br><span class="line">#检查集群</span><br><span class="line">check           host:port</span><br><span class="line">#查看集群信息</span><br><span class="line">info            host:port</span><br><span class="line">#修复集群</span><br><span class="line">fix             host:port</span><br><span class="line">                  --timeout &lt;arg&gt;</span><br><span class="line">#在线迁移slot  </span><br><span class="line">reshard         host:port       #个是必传参数，用来从一个节点获取整个集群信息，相当于获取集群信息的入口</span><br><span class="line">                  --from &lt;arg&gt;  #需要从哪些源节点上迁移slot，可从多个源节点完成迁移，以逗号隔开，传递的</span><br><span class="line">					是节点的node id，还可以直接传递--from all，这样源节点就是集群的所有节点，</span><br><span class="line">					不传递该参数的话，则会在迁移过程中提示用户输入</span><br><span class="line">                  --to &lt;arg&gt;    #slot需要迁移的目的节点的node id，目的节点只能填写一个，不传递该参数的</span><br><span class="line">					话，则会在迁移过程中提示用户输入。</span><br><span class="line">                  --slots &lt;arg&gt; #需要迁移的slot数量，不传递该参数的话，则会在迁移过程中提示用户输入。</span><br><span class="line">                  --yes         #设置该参数，可以在打印执行reshard计划的时候，提示用户输入yes确认后再执</span><br><span class="line">					行reshard</span><br><span class="line">                  --timeout &lt;arg&gt;  #设置migrate命令的超时时间。</span><br><span class="line">                  --pipeline &lt;arg&gt; #定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值</span><br><span class="line">					为10。</span><br><span class="line">#平衡集群节点slot数量  </span><br><span class="line">rebalance       host:port</span><br><span class="line">                  --weight &lt;arg&gt;</span><br><span class="line">                  --auto-weights</span><br><span class="line">                  --use-empty-masters</span><br><span class="line">                  --timeout &lt;arg&gt;</span><br><span class="line">                  --simulate 不会真正迁移，测试用的</span><br><span class="line">                  --pipeline &lt;arg&gt; 一次迁移多少分数据</span><br><span class="line">                  --threshold &lt;arg&gt;</span><br><span class="line">#将新节点加入集群 </span><br><span class="line">add-node        new_host:new_port existing_host:existing_port</span><br><span class="line">                  --slave</span><br><span class="line">                  --master-id &lt;arg&gt;</span><br><span class="line">#从集群中删除节点</span><br><span class="line">del-node        host:port node_id</span><br><span class="line">#设置集群节点间心跳连接的超时时间</span><br><span class="line">set-timeout     host:port milliseconds</span><br><span class="line">#在集群全部节点上执行命令</span><br><span class="line">call            host:port command arg arg .. arg</span><br><span class="line">#将外部redis数据导入集群</span><br><span class="line">import          host:port</span><br><span class="line">                  --from &lt;arg&gt;</span><br><span class="line">                  --copy</span><br><span class="line">                  --replace</span><br></pre></td></tr></table></figure>

<h4 id="sentinel哨兵配置"><a href="#sentinel哨兵配置" class="headerlink" title="sentinel哨兵配置"></a>sentinel哨兵配置</h4><h5 id="创建sentinel-conf"><a href="#创建sentinel-conf" class="headerlink" title="创建sentinel.conf"></a>创建sentinel.conf</h5><p>在Redis安装根目录下，<code>创建sentinel6380.conf文件</code>，然后复制5份<code>sentinel6381.conf、sentinel6382.conf、sentinel6383.conf、sentinel6384.conf、sentinel6385.conf</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6380</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6380 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6381</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6381 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6382</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6382 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6383</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6383 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6384</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6384 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6385</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6385 2</span><br><span class="line">sentinel down-after-milliseconds mymaster 10000</span><br><span class="line">sentinel failover-timeout mymaster 15000</span><br></pre></td></tr></table></figure>

<h5 id="启动哨兵服务"><a href="#启动哨兵服务" class="headerlink" title="启动哨兵服务"></a>启动哨兵服务</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-server.exe sentinel6380.conf --sentinel</span><br><span class="line">redis-server.exe sentinel6381.conf --sentinel</span><br><span class="line">redis-server.exe sentinel6382.conf --sentinel</span><br><span class="line">redis-server.exe sentinel6383.conf --sentinel</span><br><span class="line">redis-server.exe sentinel6384.conf --sentinel</span><br><span class="line">redis-server.exe sentinel6385.conf --sentinel</span><br></pre></td></tr></table></figure>

<h4 id="查看主从变化"><a href="#查看主从变化" class="headerlink" title="查看主从变化"></a>查看主从变化</h4><p>自主关闭或启动服务，进入Redis安装根目录下，在<code>cmd窗口</code>中执行命令，查看主从变化，如下查看6379</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli.exe -h 127.0.0.1 -p 6379</span><br><span class="line">info replication</span><br></pre></td></tr></table></figure>


<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p>本文使用的环境</p>
<blockquote>
<p>Linux：CentOS7<br>Jdk:1.7以上版本</p>
</blockquote>
<p>官网提供了Linux版的Redis下载，官网下载地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://redis.io/download">http://redis.io/download</a></p>
</blockquote>
<h3 id="Redis-单机-1"><a href="#Redis-单机-1" class="headerlink" title="Redis 单机"></a>Redis 单机</h3><h4 id="环境准备-1"><a href="#环境准备-1" class="headerlink" title="环境准备"></a>环境准备</h4><p>Redis安装在Linux上，<code>redis是c语言开发的，需要依赖gcc-c++环境</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum -y install cpp binutils glibc glibc-kernheaders glibc-common glibc-devel gcc make gcc-c++ libstdc++-devel tcl</span><br></pre></td></tr></table></figure>

<p>如果安装过则不会执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make gcc-c++ libstdc++-devel tcl</span><br></pre></td></tr></table></figure>

<h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><p>在安装之前可以先查看是否已经启动了redis，执行<code>ps –ef | grep redis</code>命令，再使用<code>kill -9 redis进程号</code>杀进程；删除已经安装的redis文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis &amp;&amp; <span class="built_in">rm</span> –rf bin</span><br></pre></td></tr></table></figure>

<p>进入root目录，并上传压缩包<code>redis-3.2.4.tar.gz</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/software</span><br></pre></td></tr></table></figure>

<p>解压安装包，并进入解压的文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxvf redis-3.2.4.tar.gz &amp;&amp; <span class="built_in">cd</span> redis-3.2.4</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/07/plYGuFkDwUhQNrm.png" alt="1.png"></p>
<p>执行安装，并<code>指定安装路径</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">make install PREFIX=/usr/local/redis</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/07/oVB72dFcGXmxWSA.png" alt="2.png"></p>
<p>查看安装目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis/bin/</span><br></pre></td></tr></table></figure>

<p>常用的是客户端和服务端：<code>redis-cli 是客户端</code>；<code>redis-server 是服务端</code></p>
<h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><h5 id="前端启动（不推荐）"><a href="#前端启动（不推荐）" class="headerlink" title="前端启动（不推荐）"></a>前端启动（不推荐）</h5><p><code>这里的前端启动，指的是系统的操作界面</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server</span><br></pre></td></tr></table></figure>

<p>确认redis安装正常，效果：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/07/lhqSERpC2gTa8VL.png" alt="3.png"></p>
<h5 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h5><p>从安装包中<code>复制redis.conf文件到/usr/local/redis/bin中</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> /root/software/redis-3.2.4/redis.conf ./</span><br></pre></td></tr></table></figure>

<p>修改<code>redis.conf</code>配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure>

<p><code>设置后台启动redis</code>，修改如下，<code>默认为no</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">daemonize <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p><code>设置不仅限制本地访问</code>，<code>注释掉</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>

<p><code>禁用保护模式</code>，默认<code>无密码</code>的情况下redis的<code>安全模式protected-mode</code>是开启的，<code>不禁用保护模式的话，必须给redis设置一个访问密码</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">把 `protected-mode yes` 改为 `protected-mode no `</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>小技巧</code>：vim打开文件中查找内容的方式为底行模式按 &#x2F;，然后输入要查找的内容即可(shift + n下一个)。如果被选中了后不想被选中则可以随意输入查找来消除选中效果</p>
</blockquote>
<p>启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-server redis.conf</span><br></pre></td></tr></table></figure>

<p>查看启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<h4 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h4><h5 id="使用redis-cli客户端连接"><a href="#使用redis-cli客户端连接" class="headerlink" title="使用redis-cli客户端连接"></a>使用redis-cli客户端连接</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli</span><br></pre></td></tr></table></figure>

<p><code>输入ping ,返回pong</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/07/I7PNXcTW3H5EjQl.png" alt="4.png"></p>
<h5 id="图形化界面连接"><a href="#图形化界面连接" class="headerlink" title="图形化界面连接"></a>图形化界面连接</h5><p>使用图形化界面测试访问<code>192.168.12.168</code>为例，redis默认端口为<code>6379</code>；<code>示例图工具是Redis Desktop Manager</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/07/BJpFs5SRfqT8lNQ.png" alt="5.png"></p>
<h3 id="Redis-集群（重点）"><a href="#Redis-集群（重点）" class="headerlink" title="Redis 集群（重点）"></a>Redis 集群（<code>重点</code>）</h3><h4 id="准备6个实例-1"><a href="#准备6个实例-1" class="headerlink" title="准备6个实例"></a>准备6个实例</h4><p>为了<code>保证可以进行投票，至少需要3个主节点</code>。<code>每个主节点都需要至少一个从节点，所以需要至少3个从节点</code>。一共需要6台redis服务器；可以使用6个redis实例。<code>6个redis实例的端口号：7001~7006</code></p>
<h5 id="复制实例"><a href="#复制实例" class="headerlink" title="复制实例"></a>复制实例</h5><p>如果有安装过<code>单机版</code>，那么先<code>停止单机版redis</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-cli shutdown</span><br></pre></td></tr></table></figure>

<p>如果有安装过<code>集群版</code>，那么先停止集群版redis；使用命令找出当前的所有redis进程，然后kill</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="built_in">kill</span> 进程号 进程号 ...</span><br></pre></td></tr></table></figure>

<p>把bin目录里面的<code>rdb和aof</code>持久文件删除，<code>准备干净的redis</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis/bin</span><br><span class="line"><span class="built_in">rm</span> -rf appendonly.aof </span><br><span class="line"><span class="built_in">rm</span> -f dump.rdb </span><br></pre></td></tr></table></figure>


<p><code>删除</code>原有的redis-cluster</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">rm</span> –rf redis-cluster</span><br></pre></td></tr></table></figure>

<p><code>创建</code>redis-cluster目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> redis-cluster</span><br></pre></td></tr></table></figure>

<p>把bin复制6份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r bin redis-cluster/redis1 &amp;&amp; <span class="built_in">cp</span> -r bin redis-cluster/redis2 &amp;&amp; <span class="built_in">cp</span> -r bin redis-cluster/redis3</span><br><span class="line"><span class="built_in">cp</span> -r bin redis-cluster/redis4 &amp;&amp; <span class="built_in">cp</span> -r bin redis-cluster/redis5 &amp;&amp; <span class="built_in">cp</span> -r bin redis-cluster/redis6</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/7SiIeH1ZGoRhDsm.png" alt="9.png"></p>
<h5 id="修改端口号"><a href="#修改端口号" class="headerlink" title="修改端口号"></a>修改端口号</h5><p>依次修改端口号为<code>7001~7006</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis1</span><br><span class="line">vi redis.conf</span><br></pre></td></tr></table></figure>

<p><code>修改第84行，端口6379为7001</code>，其它5个一样修改</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/ViombEHJu7Q2T4M.png" alt="10.png"></p>
<h5 id="同时启动6个实例"><a href="#同时启动6个实例" class="headerlink" title="同时启动6个实例"></a>同时启动6个实例</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis/redis-cluster</span><br></pre></td></tr></table></figure>

<p>编写<code>启动脚本</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi start-all.sh</span><br></pre></td></tr></table></figure>

<p>在文件中输入如下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> redis1</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> redis2</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> redis3</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> redis4</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> redis5</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> redis6</span><br><span class="line">./redis-server redis.conf</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>

<p>设置脚本<code>启动权限</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> u+x start-all.sh </span><br></pre></td></tr></table></figure>

<p><code>执行脚本</code>启动6个实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-all.sh </span><br></pre></td></tr></table></figure>

<p>查看启动是否正常</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/qmeUaoP1cVIn8t6.png" alt="11.png"></p>
<p>停止6个redis，<code>后续使用redis-trib.rb集群管理工具启动集群</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="built_in">kill</span> 进程号 进程号 ...</span><br></pre></td></tr></table></figure>

<h4 id="安装环境"><a href="#安装环境" class="headerlink" title="安装环境"></a>安装环境</h4><p><code>redis集群的管理工具使用的是ruby脚本语言，安装集群需要ruby环境</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install ruby</span><br></pre></td></tr></table></figure>

<p>安装Ruby的打包系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure>

<p>使用工具上传<code>redis-3.2.1.gem</code>到<code>/root/software</code>后，安装redis的ruby驱动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gem install redis-3.2.1.gem</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/26yFisgYa9OPMXl.png" alt="12.png"></p>
<h4 id="创建redis集群"><a href="#创建redis集群" class="headerlink" title="创建redis集群"></a>创建redis集群</h4><h5 id="配置集群节点"><a href="#配置集群节点" class="headerlink" title="配置集群节点"></a>配置集群节点</h5><p>需要<code>修改每个实例的redis.conf配置文件</code>，开启redis-cluster</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis/redis-cluster/</span><br><span class="line">vi redis1/redis.conf</span><br></pre></td></tr></table></figure>

<p>开启集群(记得修改6个节点)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster-enabled <span class="built_in">yes</span></span><br></pre></td></tr></table></figure>

<p>重启redis实例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure>

<h5 id="集群启动"><a href="#集群启动" class="headerlink" title="集群启动"></a>集群启动</h5><p>集群管理工具<code>redis-trib.rb</code>在<code>redis解压文件 src 文件夹中</code>；使用<code>redis-cluster的集群管理工具</code>启动集群。先进入集群管理工具所在的路径</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /root/software/redis-3.2.4/src/</span><br></pre></td></tr></table></figure>

<p><code>启动命令（如下连接中的ip最好不用127.0.0.1和默认端口）</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.12.168:7001 192.168.12.168:7002 192.168.12.168:7003 192.168.12.168:7004 192.168.12.168:7005 192.168.12.168:7006</span><br></pre></td></tr></table></figure>

<blockquote>
<p>.&#x2F;redis-trib.rb create –replicas X<br><code>X：指定集群中每个主节点配备几个从节点，这里设置为1</code></p>
</blockquote>
<blockquote>
<p><code>redis-trib.rb 启动信息和工具的使用，与 Windows 集群版的一致，在此不再累述</code></p>
</blockquote>
<h4 id="节点的增删查改"><a href="#节点的增删查改" class="headerlink" title="节点的增删查改"></a>节点的增删查改</h4><h5 id="增加主节点"><a href="#增加主节点" class="headerlink" title="增加主节点"></a>增加主节点</h5><ul>
<li>增加节点</li>
</ul>
<p>增加节点7007，把bin复制一份到redis-cluster目录下，如上述修改配置文件端口，再启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> -r bin redis-cluster/redis7</span><br></pre></td></tr></table></figure>

<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 前面一个[ip]:[port]是新建需要加入的服务节点(7007)，后面一个是目标服务节点(7001)</span></span><br><span class="line"><span class="comment">#./redis-trib.rb add-node [ip]:[port] [ip]:[port]</span></span><br><span class="line"></span><br><span class="line">./redis-trib.rb add-node 192.168.12.168:7007 192.168.12.168:7001</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Adding node 192.168.12.168:7007 to cluster 192.168.12.168:7001</span><br><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.12.168:7001)</span><br><span class="line">M: 28b8be6f285e363a957a275143dc6c5a16640d27 192.168.12.168:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1826fa69c51853431725f156dbe902958e96a564 192.168.12.168:7003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1157115d9b1f5b15939d13cd01f447423acd3e6 192.168.12.168:7002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 9dad6428a9f199c0ffd5a0a9b3de1853dec1ca1a 192.168.12.168:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1826fa69c51853431725f156dbe902958e96a564</span><br><span class="line">S: a49bb2d84beb4d531345f6b92561454458908a41 192.168.12.168:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b1157115d9b1f5b15939d13cd01f447423acd3e6</span><br><span class="line">S: 201c1643327b7cf07039f14e95383edade027316 192.168.12.168:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 28b8be6f285e363a957a275143dc6c5a16640d27</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">&gt;&gt;&gt; Send CLUSTER MEET to node 192.168.12.168:7007 to make it <span class="built_in">join</span> the cluster.</span><br><span class="line">[OK] New node added correctly.</span><br></pre></td></tr></table></figure>

<ul>
<li>查看节点信息</li>
</ul>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>可以看到7007已经加入集群，但是还没有分配哈希槽</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">28b8be6f285e363a957a275143das56da161z4ca 192.168.12.168:7007 master - 0 1481537186131 0 connected</span><br></pre></td></tr></table></figure>

<ul>
<li>分配哈希槽</li>
</ul>
<p>命令，redis安装目录src文件夹下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#./redis-trib.rb reshard [ip]:[port]</span></span><br><span class="line">./redis-trib.rb reshard 192.168.12.168:7007</span><br></pre></td></tr></table></figure>

<p>执行命令后，第一步确认<code>分哈希槽数量(2000)</code>，第二步确认<code>目标节点的ID(28b8be6f285e363a957a275143das56da161z4ca)</code>，第三步确认<code>是否节点均分（#1:all）</code>；所有确认完成开始节点调整</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.12.168:7001)</span><br><span class="line">M: 28b8be6f285e363a957a275143dc6c5a16640d27 192.168.12.168:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1826fa69c51853431725f156dbe902958e96a564 192.168.12.168:7003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1157115d9b1f5b15939d13cd01f447423acd3e6 192.168.12.168:7002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 28b8be6f285e363a957a275143das56da161z4ca 192.168.12.168:7007</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">S: 9dad6428a9f199c0ffd5a0a9b3de1853dec1ca1a 192.168.12.168:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1826fa69c51853431725f156dbe902958e96a564</span><br><span class="line">S: a49bb2d84beb4d531345f6b92561454458908a41 192.168.12.168:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b1157115d9b1f5b15939d13cd01f447423acd3e6</span><br><span class="line">S: 201c1643327b7cf07039f14e95383edade027316 192.168.12.168:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 28b8be6f285e363a957a275143dc6c5a16640d27</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)?2000</span><br><span class="line">What is the receiving node ID? 28b8be6f285e363a957a275143das56da161z4ca</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:all</span></span><br></pre></td></tr></table></figure>

<ul>
<li>再次查看节点信息</li>
</ul>
<p>命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>可以看到7007已经加入集群，并且分配哈希槽</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">28b8be6f285e363a957a275143das56da161z4ca 192.168.12.168:7007 master - 0 1481537186131 7 connected 0-665 5461-6127 10923-11588</span><br></pre></td></tr></table></figure>

<h5 id="增加从节点"><a href="#增加从节点" class="headerlink" title="增加从节点"></a>增加从节点</h5><p>上述已增加7007新节点，至此无需分配哈希槽，直接让7007新节点成为192.168.12.168:7001的从节点，<code>[nodeid]为192.168.12.168:7001的节点ID</code>(28b8be6f285e363a957a275143dc6c5a16640d27)，命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis-cli -c -p [port] cluster replicate [nodeid]</span></span><br><span class="line">redis-cli -c -p 7007 cluster replicate 28b8be6f285e363a957a275143dc6c5a16640d27</span><br></pre></td></tr></table></figure>

<p>查看7007是否已经成为7001的从节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p 7007 cluster nodes | grep slave | grep 28b8be6f285e363a957a275143dc6c5a16640d27</span><br></pre></td></tr></table></figure>


<h5 id="删除主节点"><a href="#删除主节点" class="headerlink" title="删除主节点"></a>删除主节点</h5><ul>
<li>回收哈希槽</li>
</ul>
<p>命令，redis安装目录src文件夹下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#./redis-trib.rb reshard [ip]:[port]</span></span><br><span class="line">./redis-trib.rb reshard 192.168.12.168:7007</span><br></pre></td></tr></table></figure>

<p>执行命令后，第一步确认<code>回收哈希槽数量(2000)</code>，第二步确认<code>接收哈希槽的节点ID(28b8be6f285e363a957a275143dc6c5a16640d27)</code>，第三步确认<code>会被回收哈希槽的节点ID(28b8be6f285e363a957a275143das56da161z4ca)</code>，第四步<code>输入 done  表示输入完毕</code>；所有确认完成开始节点调整</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Performing Cluster Check (using node 192.168.12.168:7001)</span><br><span class="line">M: 28b8be6f285e363a957a275143dc6c5a16640d27 192.168.12.168:7001</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 1826fa69c51853431725f156dbe902958e96a564 192.168.12.168:7003</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: b1157115d9b1f5b15939d13cd01f447423acd3e6 192.168.12.168:7002</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: 28b8be6f285e363a957a275143das56da161z4ca 192.168.12.168:7007</span><br><span class="line">   slots: (0 slots) master</span><br><span class="line">   0 additional replica(s)</span><br><span class="line">S: 9dad6428a9f199c0ffd5a0a9b3de1853dec1ca1a 192.168.12.168:7006</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 1826fa69c51853431725f156dbe902958e96a564</span><br><span class="line">S: a49bb2d84beb4d531345f6b92561454458908a41 192.168.12.168:7005</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b1157115d9b1f5b15939d13cd01f447423acd3e6</span><br><span class="line">S: 201c1643327b7cf07039f14e95383edade027316 192.168.12.168:7004</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates 28b8be6f285e363a957a275143dc6c5a16640d27</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br><span class="line">How many slots <span class="keyword">do</span> you want to move (from 1 to 16384)?2000</span><br><span class="line">What is the receiving node ID? 28b8be6f285e363a957a275143dc6c5a16640d27</span><br><span class="line">Please enter all the <span class="built_in">source</span> node IDs.</span><br><span class="line">  Type <span class="string">&#x27;all&#x27;</span> to use all the nodes as <span class="built_in">source</span> nodes <span class="keyword">for</span> the <span class="built_in">hash</span> slots.</span><br><span class="line">  Type <span class="string">&#x27;done&#x27;</span> once you entered all the <span class="built_in">source</span> nodes IDs.</span><br><span class="line">Source node <span class="comment">#1:28b8be6f285e363a957a275143das56da161z4ca</span></span><br><span class="line">Source node <span class="comment">#2:done</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除节点</li>
</ul>
<p>命令，需要删除节点的ip和端口，nodeid是该节点的id</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#./redis-trib.rb del-node [ip]:[port] [nodeid]</span></span><br><span class="line">./redis-trib.rb del-node 192.168.12.168:7007 28b8be6f285e363a957a275143das56da161z4ca</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; Removing node 28b8be6f285e363a957a275143das56da161z4ca from cluster 192.168.12.168:7007</span><br><span class="line">&gt;&gt;&gt; Sending CLUSTER FORGET messages to the cluster...</span><br><span class="line">&gt;&gt;&gt; SHUTDOWN the node.</span><br></pre></td></tr></table></figure>


<ul>
<li>查看节点信息</li>
</ul>
<p>命令，可以看到7007节点已经被删除了，哈希槽已经被分配到7001节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cluster nodes</span><br></pre></td></tr></table></figure>

<p>可以看到7007节点的哈希槽已经被分配到7001节点</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">28b8be6f285e363a957a275143das56da161z4ca 192.168.12.168:7007 master - 0 1481537186131 0 connected</span><br></pre></td></tr></table></figure>

<h5 id="删除从节点"><a href="#删除从节点" class="headerlink" title="删除从节点"></a>删除从节点</h5><p>无需回收哈希槽，直接删除，<code>[ip]:[port]为需删除从节点的主节点</code>(192.168.12.168:7001)，<code>[nodeid]为需删除的从节点ID</code>(28b8be6f285e363a957a275143das56da161z4ca)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ./redis-trib.rb del-node [ip]:[port] [nodeid]</span></span><br><span class="line">./redis-trib.rb del-node 192.168.12.168:7001 28b8be6f285e363a957a275143das56da161z4ca</span><br></pre></td></tr></table></figure>


<h4 id="sentinel哨兵配置-1"><a href="#sentinel哨兵配置-1" class="headerlink" title="sentinel哨兵配置"></a>sentinel哨兵配置</h4><p>实现主从自动切换，<code>sentinel.conf在redis安装目录下</code></p>
<h5 id="修改文件配置"><a href="#修改文件配置" class="headerlink" title="修改文件配置"></a>修改文件配置</h5><ul>
<li>除sentinel默认端口<code>26379</code>可不用修改，其它<code>没有注释的选项全注释掉</code></li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/27/TfYxo7HlAOPtgCV.png"></p>
<ul>
<li>添加监控的master信息</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/27/rgdz4qHWTYoXcfK.png"></p>
<h5 id="启动sentinel"><a href="#启动sentinel" class="headerlink" title="启动sentinel"></a>启动sentinel</h5><p>在redis安装目录下src文件夹下执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./redis-sentinel ../sentinel.conf</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/27/Q87pXLPYoZcKdrm.png" alt="SouthEast (2).png"></p>
<blockquote>
<p>可以测试当7001节点shutdown后，7004会变成主节点，并继承7001的哈希槽。再次启动7001，会发现7001变成了7004的从节点。并且sentinel.conf会自动修改</p>
</blockquote>
<h4 id="Redis集群连接"><a href="#Redis集群连接" class="headerlink" title="Redis集群连接"></a>Redis集群连接</h4><h5 id="工具连接"><a href="#工具连接" class="headerlink" title="工具连接"></a>工具连接</h5><p><code>redis的单机版，默认是16个数据库</code>，但是redis-Cluster集群版，有多少个主节点，就有多少个数据库（整个集群才是一个完整的数据库）。</p>
<ul>
<li>使用redis命令行客户端连接</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/local/redis/bin</span><br><span class="line">./redis-cli -h 192.168.12.168 -p 7006 -c</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/12/eosavtlprEIbM84.png" alt="13.png"></p>
<blockquote>
<p><code>注：一定要加 -c 参数，节点之间则可以互相跳转，不然get key的时候会报错</code></p>
</blockquote>
<ul>
<li>使用图形客户端连接</li>
</ul>
<p>因为有3台主redis数据库，所以需要连接3台。<code>如上述linux单机图形化界面连接</code></p>
<h5 id="代码连接"><a href="#代码连接" class="headerlink" title="代码连接"></a>代码连接</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisClusterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">		<span class="comment">// 设置集群节点</span></span><br><span class="line">		Set&lt;HostAndPort&gt; nodes = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7001</span>));</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7002</span>));</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7003</span>));</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7004</span>));</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7005</span>));</span><br><span class="line">		nodes.add(<span class="keyword">new</span> <span class="title class_">HostAndPort</span>(<span class="string">&quot;192.168.12.168&quot;</span>, <span class="number">7006</span>));</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建jedis集群对象</span></span><br><span class="line">		<span class="type">JedisCluster</span> <span class="variable">jedisCluster</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisCluster</span>(nodes);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 设置值</span></span><br><span class="line">		jedisCluster.set(<span class="string">&quot;jedisCluster_msg&quot;</span>, <span class="string">&quot;redis-集群&quot;</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取键值</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">msg</span> <span class="operator">=</span> jedisCluster.get(<span class="string">&quot;jedisCluster_msg&quot;</span>);</span><br><span class="line">		System.out.println(msg);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭jedisCluster连接(在程序执行完之后,才能关闭,他的内部已经封装了连接池)</span></span><br><span class="line">		jedisCluster.close();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置详情"><a href="#配置详情" class="headerlink" title="配置详情"></a>配置详情</h2><h3 id="redis-conf"><a href="#redis-conf" class="headerlink" title="redis.conf"></a>redis.conf</h3><ul>
<li>Redis<code>默认不是以守护进程的方式运行</code>，可修改<code>daemonize为yes</code>启用守护进程</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">daemonize no</span><br></pre></td></tr></table></figure>

<ul>
<li>当Redis以守护进程方式运行时，Redis<code>默认会把pid(进程ID)写入/var/run/redis.pid文件</code>，可以通过pidfile指定</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidfile /var/run/redis.pid</span><br></pre></td></tr></table></figure>

<ul>
<li>指定Redis监听端口，默认端口为6379</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 6379</span><br></pre></td></tr></table></figure>

<ul>
<li>绑定的主机地址</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bind 127.0.0.1</span><br></pre></td></tr></table></figure>

<ul>
<li>当客户端闲置多长时间后关闭连接，如果<code>指定为0，表示关闭该功能</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">timeout 300</span><br></pre></td></tr></table></figure>

<ul>
<li>指定<code>日志记录级别</code>，Redis总共支持四个级别：<code>debug、verbose、notice、warning</code>，<code>默认为verbose</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">loglevel verbose</span><br></pre></td></tr></table></figure>

<ul>
<li><code>日志记录方式，默认为标准输出</code>，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给&#x2F;dev&#x2F;null</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">logfile stdout</span><br></pre></td></tr></table></figure>

<ul>
<li>设置数据库，<code>默认数据库为0</code>，可以使用<code>SELECT [dbid]</code>命令在连接上指定数据库id</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 9</span><br></pre></td></tr></table></figure>

<ul>
<li>指定在多长时间内，有多少次更新操作，就<code>将数据同步到数据文件</code>，可以多个条件配合</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save &lt;seconds&gt; &lt;changes&gt;</span><br></pre></td></tr></table></figure>

<p>Redis默认配置文件中提供了三个条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure>

<p>分别表示<code>900秒（15分钟）内有1个更改</code>，<code>300秒（5分钟）内有10个更改</code>以及<code>60秒内有10000个更改</code>。</p>
<ul>
<li>指定存储至本地数据库时<code>是否压缩数据，默认为yes</code>，Redis采用LZF压缩，如果为了<code>节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rdbcompression yes</span><br></pre></td></tr></table></figure>

<ul>
<li>指定本地<code>数据库文件名</code>，<code>默认值为dump.rdb</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dbfilename dump.rdb</span><br></pre></td></tr></table></figure>

<ul>
<li>指定本地数据库<code>存放目录</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dir ./</span><br></pre></td></tr></table></figure>

<ul>
<li>设置当本机为slave服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slaveof &lt;masterip&gt; &lt;masterport&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>当master服务设置了密码</code>保护时，<code>slave服务连接master的密码</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masterauth &lt;master-password&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>设置<code>Redis连接密码</code>，如果配置了连接密码，客户端在连接Redis时需要通过AUTH <password>命令提供密码，<code>默认关闭</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">requirepass 密码</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>方式一</code>：redis.conf配置文件设置(<code>永久方式</code>)</p>
</blockquote>
<p>找到<code># requirepass foobared</code>，去掉<code>#注释</code>，配置密码（或者干脆另起一行，照着写就是），需要重启Redis服务</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/21/6SiL8I3cA9hBJPf.png"></p>
<blockquote>
<p><code>方式二</code>：命令设置(<code>临时方式</code>)</p>
</blockquote>
<p>密码信息保存在<code>服务器内存</code>中，不需要重启Redis服务，但服务器<code>重启后将失效</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">config <span class="built_in">set</span> requirepass 密码 <span class="comment">#设置密码</span></span><br><span class="line">config get requirepass <span class="comment">#查看密码</span></span><br></pre></td></tr></table></figure>


<ul>
<li><code>设置同一时间最大客户端连接数，默认无限制</code>，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果<code>设置 maxclients 0，表示不作限制</code>。<code>当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxclients 128</span><br></pre></td></tr></table></figure>

<ul>
<li><code>指定Redis最大内存限制</code>，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">maxmemory &lt;bytes&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>指定是否在每次更新操作后进行日志记录，<code>Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失</code>。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。<code>默认为no</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendonly no</span><br></pre></td></tr></table></figure>

<ul>
<li>指定更新日志文件名，默认为appendonly.aof</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfilename appendonly.aof</span><br></pre></td></tr></table></figure>

<ul>
<li>指定更新日志条件</li>
</ul>
<p>共有3个可选值： </p>
<blockquote>
<p><code>no</code>：表示等操作系统进行数据缓存同步到磁盘<code>（快）</code><br><code>always</code>：表示每次更新操作后手动调用fsync()将数据写到磁盘<code>（慢，安全）</code><br><code>everysec</code>：表示每秒同步一次<code>（折衷，默认值）</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">appendfsync everysec</span><br></pre></td></tr></table></figure>
<ul>
<li>指定<code>是否启用虚拟内存机制，默认值为no</code>，VM机制将数据分页存放，由Redis将<code>访问量较少</code>的页即冷数据swap到<code>磁盘</code>上，<code>访问多</code>的页面由<code>磁盘自动换出到内存中</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-enabled no</span><br></pre></td></tr></table></figure>

<ul>
<li>虚拟<code>内存文件路径</code>，默认值为<code>/tmp/redis.swap</code>，<code>不可多个Redis实例共享</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-swap-file /tmp/redis.swap</span><br></pre></td></tr></table></figure>

<ul>
<li>将所有大于vm-max-memory的数据存入虚拟内存，无论vm-max-memory设置多小，所有索引数据都是内存存储的(Redis的索引数据 就是keys)，也就是说，<code>当vm-max-memory设置为0的时候，其实是所有value都存在于磁盘。默认值为0</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-max-memory 0</span><br></pre></td></tr></table></figure>

<ul>
<li>Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，建议如果存储很多小对象，<code>page大小最好设置为32或者64bytes</code>；如果存储很大大对象，则可以使用更大的page，如果不确定，就使用默认值</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-page-size 32</span><br></pre></td></tr></table></figure>

<ul>
<li><code>设置swap文件中的page数量</code>，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，在磁盘上每8个pages将消耗1byte的内存。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-pages 134217728</span><br></pre></td></tr></table></figure>

<ul>
<li><code>设置访问swap文件的线程数，最好不要超过机器的核数</code>，如果设置为0，那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。<code>默认值为4</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vm-max-threads 4</span><br></pre></td></tr></table></figure>
<ul>
<li>设置在向客户端应答时，是否把较小的包合并为一个包发送，<code>默认为开启</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">glueoutputbuf yes</span><br></pre></td></tr></table></figure>
<ul>
<li>指定<code>在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hash-max-zipmap-entries 64</span><br><span class="line"></span><br><span class="line">hash-max-zipmap-value 512</span><br></pre></td></tr></table></figure>
<ul>
<li>指定<code>是否激活重置哈希</code>，<code>默认为开启</code></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">activerehashing yes</span><br></pre></td></tr></table></figure>
<ul>
<li>指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">include /path/to/local.conf</span><br></pre></td></tr></table></figure>

<h3 id="redis-sentinel-conf"><a href="#redis-sentinel-conf" class="headerlink" title="redis-sentinel.conf"></a>redis-sentinel.conf</h3><ul>
<li>sentinel监听端口，<code>默认是26379，可以修改</code>。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">port 26379</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</code></li>
</ul>
<p>sentinel去<code>监听地址为 ip:port 的一个master</code>，<code>master-name可自定义</code>，<code>quorum是一个数字，指明当有多少个sentinel认为一个master失效时，master才算真正失效</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor mymaster 192.168.0.5 6379 2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>master-name：只能包含<code>英文字母</code>，<code>数字</code>，和<code>“.-_”</code>这三个字符，<br>master-ip：要写<code>真实的ip</code>地址，而<code>不要用回环地址（127.0.0.1）</code>。</p>
</blockquote>
<ul>
<li><code>sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</code></li>
</ul>
<p><code>设置连接master和slave时的密码</code>，注意的是sentinel不能分别为master和slave设置不同的密码，因此<code>master和slave的密码必须设置相同</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel auth-pass mymaster 0123passw0rd</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sentinel down-after-milliseconds &lt;master-name&gt; &lt;milliseconds&gt; </code></li>
</ul>
<p>指定<code>需要多少失效时间，一个master才会被这个sentinel主观地认为是不可用的</code>。 单位是毫秒，<code>默认为30秒</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel down-after-milliseconds mymaster 30000</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sentinel parallel-syncs &lt;master-name&gt; &lt;numslaves&gt; </code></li>
</ul>
<p>指定<code>在发生failover主备切换时最多可以有多少个slave同时对新的master进行同步</code>，<code>数字越小，完成failover所需的时间就越长</code>，<code>数字越大，就意味着越多的slave因为replication而不可用</code>。将值<code>设为 1</code> 来保证每次只有一个slave 处于不能处理命令请求的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel parallel-syncs mymaster 1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sentinel failover-timeout &lt;master-name&gt; &lt;milliseconds&gt;</code></li>
</ul>
<p>failover-timeout 可以用在以下这些方面： </p>
<blockquote>
<ol>
<li>同一个sentinel对同一个master两次failover之间的间隔时间。</li>
<li>当一个slave从一个错误的master那里同步数据开始计算时间。直到slave被纠正为向正确的master那里同步数据时。</li>
<li>当想要取消一个正在进行的failover所需要的时间。  </li>
<li>当进行failover时，配置所有slaves指向新的master所需的最大时间。不过，即使过了这个超时，slaves依然会被正确配置为指向master，但是就不按parallel-syncs所配置的规则来了。</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel failover-timeout mymaster1 20000</span><br></pre></td></tr></table></figure>
<ul>
<li>sentinel的<code>notification-script</code>和<code>reconfig-script</code>是用来配置当某一事件发生时所需要执行的脚本，可以通过脚本来通知管理员，例如当系统运行不正常时发邮件通知相关人员。对于脚本的运行结果有以下规则：</li>
</ul>
<ol>
<li>若脚本执行后<code>返回1</code>，那么该脚本<code>稍后将会被再次执行</code>，重复次数目前<code>默认为10</code></li>
<li>若脚本执行后<code>返回2或者比2更高的一个返回值</code>，脚本将<code>不会重复执行</code>。</li>
<li>如果脚本在执行过程中由于收到系统中断信号被<code>终止了，则同返回值为1时的行为相同</code>。</li>
<li>一个脚本的<code>最大执行时间为60s，如果超过这个时间，脚本将会被一个SIGKILL信号终止，之后重新执行</code>。</li>
</ol>
<blockquote>
<ul>
<li><code>sentinel notification-script &lt;master-name&gt; &lt;script-path&gt; </code></li>
</ul>
</blockquote>
<p>通知型脚本：当sentinel有任何警告级别的事件发生时（比如说redis实例的主观失效和客观失效等等），将会去调用这个脚本，这时这个脚本应该通过邮件，SMS等方式去通知系统管理员关于系统不正常运行的信息。调用该脚本时，将<code>传给脚本两个参数</code>，一个是<code>事件的类型</code>，一个是<code>事件的描述</code>。如果sentinel.conf配置文件中配置了这个脚本路径，那么必须保证这个脚本存在于这个路径，并且是可执行的，否则sentinel无法正常启动成功。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel notification-script mymaster /var/redis/notify.sh</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>sentinel client-reconfig-script &lt;master-name&gt; &lt;script-path&gt;</code></li>
</ul>
</blockquote>
<p>当一个master由于failover而发生改变时，这个脚本将会被调用，通知相关的客户端关于master地址已经发生改变的信息。以下<code>参数将会在调用脚本时传给脚本</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;master-name&gt; &lt;role&gt; &lt;state&gt; &lt;from-ip&gt; &lt;from-port&gt; &lt;to-ip&gt; &lt;to-port&gt;</span><br></pre></td></tr></table></figure>

<p>目前<code>&lt;role&gt;</code>是“leader”或者“observer”中的一个，<code>&lt;state&gt;</code>总是“failover”。 参数<code>from-ip, from-port, to-ip, to-port</code>是用来和旧的master和新的master(即旧的slave)通信的。这个脚本应该是通用的，能被多次调用，不是针对性的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel client-reconfig-script mymaster /var/redis/reconfig.sh</span><br></pre></td></tr></table></figure>




<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><p><code>高可用有两个含义：一是数据尽量不丢失，二是服务尽可能提供服务</code>。<code>AOF和RDB保证了数据持久化</code>尽量不丢失，而<code>主从复制就是增加副本</code>，一份数据保存到多个实例上。即使有一个实例宕机，其他实例依然可以提供服务。</p>
<h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Redis提供了主从模式，通过主从复制，将数据冗余一份复制到其他Redis服务器。前者称为<code>主节点(master)</code>，后者称为<code>从节点(slave)</code>；<code>数据的复制是单向的，只能由主节点到从节点</code>。默认情况下，每台Redis服务器都是主节点；<code>且一个主节点可以有多个从节点(或没有从节点)，但一个从节点只能有一个主节点</code>。</p>
<blockquote>
<ul>
<li><code>数据如何保证一致性</code><br>为了保证副本数据的一致性，主从架构采用了<code>读写分离的方式</code>。</li>
</ul>
<ol>
<li>读操作：主、从库都可以执行；</li>
<li>写操作：主库先执行，之后将写操作同步到从库；</li>
</ol>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/20/euamkMc91Sw6f3q.jpg"></p>
<blockquote>
<ul>
<li><code>为何要采用读写分离的方式</code><br>可以假设主从库都可以执行写指令，假如对同一份数据分别修改了多次，每次修改发送到不同的主从实例上，就导致是实例的副本数据不一致了。<br>如果为了保证数据一致，Redis 需要加锁，协调多个实例的修改，Redis 自然不会这么干！</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>主从复制还有其他作用么</code></li>
</ul>
<ol>
<li><code>故障恢复</code>：当主节点宕机，其他节点依然可以提供服务；</li>
<li><code>负载均衡</code>：Master 节点提供写服务，Slave节点提供读服务，<code>分担压力</code>；</li>
<li><code>高可用基石</code>：是<code>哨兵和集群(cluster)实施</code>的基础，是<code>高可用的基石</code>。</li>
</ol>
</blockquote>
<h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><p><code>主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。</code>可以通过<code>replicaof（Redis5.0之前使用slaveof）</code>命令形成主库和从库的关系。</p>
<blockquote>
<ul>
<li><code>在从节点开启主从复制，有 3 种方式：</code></li>
</ul>
<ol>
<li>配置文件<br>在从服务器的配置文件中加入 <code>replicaof [masterip] [masterport]</code></li>
<li>启动命令<br>redis-server 启动命令后面加入 <code>--replicaof [masterip] [masterport]</code></li>
<li>客户端命令<br>启动多个 Redis 实例后，直接通过客户端执行命令：<code>replicaof [masterip] [masterport]</code>，则该 Redis 实例成为从节点。</li>
</ol>
</blockquote>
<p>比如假设现在有实例 <code>1（172.16.88.1）</code>、<code>实例 2（172.16.88.2）</code>和<code>实例 3 (172.16.88.3)</code>，在实例 2 和实例 3 上分别执行以下命令，实例 2 和 实例 3 就成为了实例 1 的从库，实例 1 成为 Master。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">replicaof 172.16.88.1 6379</span><br></pre></td></tr></table></figure>

<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>主从库模式一旦<code>采用了读写分离，所有数据的写操作只会在主库上进行</code>，不用协调三个实例。主库有了最新的数据后，会<code>同步给从库</code>，这样，主从库的数据就是一致的。</p>
<blockquote>
<ul>
<li>主从库同步是如何完成的呢？主库数据是一次性传给从库，还是分批同步？正常运行中又怎么同步呢？要是主从库间的网络断连了，重新连接后数据还能保持一致吗？<code>同步分为三种情况：</code></li>
</ul>
<ol>
<li>第一次主从库全量复制；</li>
<li>主从库间网络断开重连同步。</li>
<li>主从正常运行期间的同步；</li>
</ol>
</blockquote>
<h4 id="主从库第一次全量复制"><a href="#主从库第一次全量复制" class="headerlink" title="主从库第一次全量复制"></a>主从库第一次全量复制</h4><p>主从库第一次复制过程大体可以<code>分为3个阶段</code>：<code>连接建立阶段（即准备阶段）</code>、<code>主库同步数据到从库阶段</code>、<code>发送同步期间新写命令到从库阶段</code>；</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/21/iYuyCof2bOU79FA.jpg"></p>
<h5 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h5><p>该阶段的主要作用是在主从节点之间建立连接，为数据全量同步做好准备。<code>从库会和主库建立连接，从库执行replicaof并发送psync命令并告诉主库即将进行同步，主库确认回复后，主从库间就开始同步了</code>。</p>
<blockquote>
<ul>
<li><code>从库怎么知道主库信息并建立连接的呢？</code></li>
</ul>
<ol>
<li>在<code>从节点的配置文件中的 replicaof 配置项中配置了主节点的 IP 和 port 后</code>，从节点就知道自己要和那个主节点进行连接了。</li>
<li>从节点内部维护了两个字段，<code>masterhost 和 masterport，用于存储主节点的 IP 和 port 信息</code>。</li>
<li>从库执行 <code>replicaof</code> 并发送 <code>psync 命</code>令，表示要执行数据同步，主库收到命令后根据参数启动复制。命令包含了<code>主库的 runID</code> 和 <code>复制进度 offset</code> 两个参数。</li>
</ol>
</blockquote>
<blockquote>
<p><code>runID</code>：每个 Redis 实例<code>启动都会自动生成一个 唯一标识 ID</code>，第一次主从复制，还<code>不知道主库 runID，参数设置为 「?」</code>。<br><code>offset</code>：<code>第一次复制设置为 -1，表示第一次复制</code>，记录复制进度偏移量。</p>
</blockquote>
<p><code>主库收到 psync 命令后</code>，会用 <code>FULLRESYNC 响应命令</code>带上两个参数：<code>主库 runID 和主库目前的复制进度 offset，返回给从库。</code>从库收到响应后，会记录下这两个参数。</p>
<blockquote>
<p><code>FULLRESYNC 响应表示第一次复制采用的全量复制</code>，也就是说，主库会把当前所有的数据都复制给从库。</p>
</blockquote>
<h5 id="主库同步数据给从库"><a href="#主库同步数据给从库" class="headerlink" title="主库同步数据给从库"></a>主库同步数据给从库</h5><p>master 执行 bgsave命令生成 RDB 文件，并将文件发送给从库，同时主库为每一个 slave(从库) 开辟一块<code>replication buffer缓冲区记录从生成RDB文件开始收到的所有写命令</code>。</p>
<p>从库收到 RDB 文件后保存到磁盘，并清空当前数据库的数据，再加载 RDB 文件数据到内存中。</p>
<blockquote>
<ul>
<li><code>主库将数据同步到从库过程中，可以正常接受请求么？</code><br>主库不会被阻塞，在生成 RDB 文件之后的写操作并没有记录到刚刚的 RDB 文件中，为了保证主从库数据的一致性，所以主库会在内存中使用一个叫 replication buffer 记录 RDB 文件生成后的所有写操作。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>为啥从库收到 RDB 文件后要清空当前数据库？</code><br>因为从库在通过 replcaof命令开始和主库同步前可能保存了其他数据，防止主从数据之间的影响。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><code>replication buffer 到底是什么玩意？</code><br>一个在 master 端上创建的缓冲区，存放的数据是下面三个时间内所有的 master 数据写操作。</li>
</ul>
<ol>
<li><code>master 执行 bgsave</code> 产生 RDB 的期间的写操作；</li>
<li><code>master 发送 RDB 到 slave</code> 网络传输期间的写操作；</li>
<li><code>slave load RDB </code>文件把数据恢复到内存的期间的写操作。</li>
</ol>
</blockquote>
<p>Redis 和客户端通信也好，和从库通信也好，Redis 都分配一个内存 buffer 进行数据交互，客户端就是一个 client，从库也是一个 client，我们每个 client 连上 Redis 后，Redis 都会分配一个专有 client buffer，所有数据交互都是通过这个 buffer 进行的。</p>
<p>Master 先把数据写到这个 buffer 中，然后再通过网络发送出去，这样就完成了数据交互。</p>
<p>不管是主从在增量同步还是全量同步时，master 会为其分配一个 buffer ，只不过这个 buffer 专门用来<code>传播写命令</code>到从库，保证主从数据一致，我们通常把它叫做 replication buffer。</p>
<blockquote>
<ul>
<li><code>replication buffer 太小会引发的问题？</code><br><code>replication buffer</code> 由 <code>client-output-buffer-limit slave</code> 设置，当这个值太小会导致<code>主从复制连接断开</code>。</li>
</ul>
<ol>
<li>当 master-slave 复制连接断开，master 会释放连接相关的数据。replication buffer 中的数据也就丢失了，此时主从之间重新开始复制过程。</li>
<li>还有个更严重的问题，<code>主从复制连接断开，导致主从上出现重新执行 bgsave 和 rdb 重传操作无限循环</code>。</li>
</ol>
</blockquote>
<p>当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；</p>
<p>这种情况可能引起<code>全量复制 -&gt; replication buffer 溢出导致连接中断 -&gt; 重连 -&gt; 全量复制 -&gt; replication buffer 缓冲区溢出导致连接中断……的循环</code>。</p>
<p>因而<code>推荐</code>把 <code>replication buffer</code> 的 <code>hard/soft limit</code> 设置成 <code>512M</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config set client-output-buffer-limit &quot;slave 536870912 536870912 0&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>主从库复制为何不使用 AOF 呢？相比 RDB 来说，丢失的数据更少。</code></li>
</ul>
<ol>
<li>RDB 文件是二进制文件，<code>网络传输 RDB 和写入磁盘的 IO 效率都要比 AOF 高</code>。</li>
<li>从库进行数据恢复的时候，<code>RDB 的恢复效率也要高于 AOF</code>。</li>
</ol>
</blockquote>
<h5 id="发送新写命令到从库"><a href="#发送新写命令到从库" class="headerlink" title="发送新写命令到从库"></a>发送新写命令到从库</h5><p><code>从节点加载 RDB 完成后，主节点将 replication buffer 缓冲区的数据发送到从节点</code>，Slave 接收并执行，从节点同步至主节点相同的状态。</p>
<h4 id="增量复制"><a href="#增量复制" class="headerlink" title="增量复制"></a>增量复制</h4><p>在 <code>Redis 2.8 之前</code>，<code>如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大</code>。从 <code>Redis 2.8 开始</code>，<code>网络断了之后，主从库会采用增量复制的方式继续同步</code>。</p>
<blockquote>
<p>增量复制：<code>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。</code></p>
</blockquote>
<blockquote>
<ul>
<li><code>repl_backlog_buffer</code></li>
</ul>
<p>断开重连增量复制的实现奥秘就是 <code>repl_backlog_buffer</code> 缓冲区，不管在什么时候 master 都会将写指令操作记录在 <code>repl_backlog_buffer</code> 中，因为内存有限， <code>repl_backlog_buffer</code> 是一个定长的环形数组，<code>如果数组内容满了，就会从头开始覆盖前面的内容</code>。</p>
</blockquote>
<p><code>master</code> 使用 <code>master_repl_offset</code>记录自己写到的位置偏移量，<code>slave</code> 则使用 <code>slave_repl_offset</code>记录已经读取到的偏移量。</p>
<p>master 收到写操作，偏移量则会增加。从库持续执行同步的写指令后，在 repl_backlog_buffer 的已复制的偏移量 slave_repl_offset 也在不断增加。</p>
<p>正常情况下，这两个偏移量基本相等。<code>在网络断连阶段，主库可能会收到新的写操作命令，所以 master_repl_offset会大于 slave_repl_offset</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/21/SP2UXGJ6FsLvNg3.jpg"></p>
<p>当主从断开重连后，<code>slave 会先发送 psync 命令给 master，同时将自己的 runID，slave_repl_offset发送给 master</code>。</p>
<p>master 只需要<code>把 master_repl_offset与 slave_repl_offset之间的命令同步给从库即可</code>。</p>
<p>增量复制执行流程如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/21/8GxEO7lvkioLTUf.jpg"></p>
<blockquote>
<ul>
<li><code>repl_backlog_buffer 太小的话从库还没读取到就被 Master 的新写操作覆盖了咋办？</code></li>
</ul>
<p>要想办法避免这个情况，一旦被覆盖就会执行全量复制。可以<code>调整 repl_backlog_size 这个参数用于控制缓冲区大小</code>。计算公式：<br><code>repl_backlog_buffer = second * write_size_per_second</code></p>
</blockquote>
<blockquote>
<p><code>second</code>：从服务器断开重连主服务器所需的平均时间；<br><code>write_size_per_second</code>：master 平均每秒产生的命令数据量大小（写命令和数据大小总和）；<br/></p>
</blockquote>
<p>例如，如果<code>主服务器平均每秒产生 1 MB 的写数据</code>，而<code>从服务器断线之后平均要 5 秒才能重新连接上主服务器</code>，那么复制积压<code>缓冲区的大小就不能低于 5 MB</code>。</p>
<p>为了安全起见，可以将复制积压缓冲区的大小设为<code>2 * second * write_size_per_second</code>，这样可以保证绝大部分断线情况都能用部分重同步来处理。</p>
<h4 id="基于长连接的命令传播"><a href="#基于长连接的命令传播" class="headerlink" title="基于长连接的命令传播"></a>基于长连接的命令传播</h4><p><code>当主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为基于长连接的命令传播</code>，使用长连接的目的就是避免频繁建立连接导致的开销。</p>
<p>在命令传播阶段，除了发送写命令，<code>主从节点还维持着心跳机制：PING 和 REPLCONF ACK。</code></p>
<p><code>主-&gt;从：PING</code><br>每隔指定的时间，<code>主节点会向从节点发送 PING 命令</code>，这个 PING 命令的作用，主要是为了让从节点进行超时判断。</p>
<p><code>从-&gt;主：REPLCONF ACK</code><br>在命令传播阶段，<code>从服务器默认会以每秒一次的频率，向主服务器发送命令</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  replication_offset 是从服务器当前的复制偏移量</span><br><span class="line">REPLCONF ACK &lt;replication_offset&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>发送<code>REPLCONF ACK</code>命令对于主从服务器有<code>三个作用</code>：</li>
</ul>
<ol>
<li>检测主从服务器的<code>网络连接状态</code>。</li>
<li>辅助实现 <code>min-slaves</code> 选项。</li>
<li>检测命令丢失, 从节点发送了自身的 slave_replication_offset，主节点会用自己的 master_replication_offset 对比，如果从节点数据缺失，主节点会从 repl_backlog_buffer缓冲区中找到并推送缺失的数据。<code>注意，offset 和 repl_backlog_buffer 缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的</code>。</li>
</ol>
</blockquote>
<h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><ul>
<li><code>如何确定执行全量同步还是部分同步？</code></li>
</ul>
<p>在 <code>Redis 2.8 及以后</code>，<code>从节点可以发送 psync 命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制</code>。关键就是 psync的执行</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/21/xOhwWCvzSH5IDEY.jpg"></p>
<blockquote>
<ul>
<li>从节点根据当前状态，发送 <code>psync</code>命令给 master：</li>
</ul>
<ol>
<li>如果从节点<code>从未执行过 replicaof</code> ，则从节点发送 <code>psync ? -1</code>，向主节点发送全量复制请求；</li>
<li>如果从节点之前<code>执行过 replicaof</code> 则发送 <code>psync [runID] [offset]</code>, runID 是上次复制保存的主节点 runID，offset 是上次复制截至时从节点保存的复制偏移量。</li>
</ol>
<ul>
<li>主节点根据接受到的psync命令和当前服务器状态，决定执行全量复制还是部分复制：</li>
</ul>
<ol>
<li>runID 与从节点发送的 runID 相同，且从节点发送的 slave_repl_offset之后的数据在 repl_backlog_buffer缓冲区中都存在，则回复 CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li>
<li>runID 与从节点发送的 runID 不同，或者从节点发送的 slave_repl_offset 之后的数据已不在主节点的 repl_backlog_buffer缓冲区中 (在队列中被挤出了)，则回复从节点 FULLRESYNC <runid> <offset>，表示要进行全量复制，其中 <code>runID 表示主节点当前的 runID</code>，<code>offset 表示主节点当前的 offset</code>，从节点保存这两个值，以备使用。</li>
</ol>
</blockquote>
<p>一个从库如果和主库断连时间过长，造成它在主库 repl_backlog_buffer的 slave_repl_offset 位置上的数据已经被覆盖掉了，此时从库和主库间将进行全量复制。</p>
<ul>
<li><code>replication buffer 和 repl_backlog_buffer</code></li>
</ul>
<blockquote>
<ol>
<li>replication buffer 对应于每个 slave，通过<code>config set client-output-buffer-limit slave</code>设置。</li>
<li><code>repl_backlog_buffer是一个环形缓冲区，整个 master 进程中只会存在一个，所有的 slave 公用</code>。repl_backlog 的大小通过 <code>repl-backlog-size</code>参数设置，<code>默认大小是 1M</code>，其大小可以根据<code>每秒产生的命令、（master 执行 rdb bgsave） +（ master 发送 rdb 到 slave） + （slave load rdb 文件）时间之和</code>来估算积压缓冲区的大小，<code>repl-backlog-size 值不小于这两者的乘积</code>。</li>
</ol>
</blockquote>
<blockquote>
<p><code>replication buffer 是主从库在进行全量复制时，主库上用于和从库连接的客户端的 buffer</code><br><code>repl_backlog_buffer 是为了支持从库增量复制，主库上用于持续保存写操作的一块专用 buffer</code>。</p>
</blockquote>
<p>repl_backlog_buffer是一块专用 buffer，在 Redis 服务器启动后，开始一直接收写操作命令，这是所有从库共享的。主库和从库会各自记录自己的复制进度，所以，不同的从库在进行恢复时，会把自己的复制进度（slave_repl_offset）发给主库，主库就可以和它独立同步。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/22/ziaCVxWFXLgHKoc.jpg"></p>
<ul>
<li><code>主从复制的场景下，从节点会删除过期数据么?</code></li>
</ul>
<p>为了主从节点的数据一致性，从节点不会主动删除数据。Redis有两种删除策略：</p>
<blockquote>
<ol>
<li>惰性删除：当客户端查询对应的数据时，Redis判断该数据是否过期，过期则删除。</li>
<li>定期删除：Redis 通过定时任务删除过期数据。</li>
</ol>
</blockquote>
<ul>
<li><code>那客户端通过从节点读取数据会不会读取到过期数据？</code></li>
</ul>
<p><code>Redis 3.2 开始</code>，通过从节点读取数据时，先判断数据是否已过期。如果过期则不返回客户端，并且删除数据。</p>
<ul>
<li><code>单机内存大小限制</code></li>
</ul>
<p>如果 Redis 单机内存达到 <code>10GB</code>，一个从节点的同步时间在<code>几分钟</code>的级别；如果<code>从节点较</code>多，恢复的速度会更<code>慢</code>。如果系统的<code>读负载很高</code>，而这段时间<code>从节点无法提供服</code>务，会对<code>系统</code>造成<code>很大</code>的<code>压力</code>。</p>
<p>如果<code>数据量过大</code>，<code>全量复制</code>阶段主节点 fork + 保存 RDB <code>文件耗时过大</code>，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入<code>全量复制-&gt;超时导致复制中断-&gt;重连-&gt;全量复制-&gt;超时导致复制中断……的循环</code>。</p>
<p>此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：<code>最好只使用 50% - 65% 的内存</code>，留下 30%-45% 的内存用于执行 bgsave 命令和创建复制缓冲区等。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol>
<li>主从复制的<code>作用</code>：AOF 和 RDB 二进制文件保证了宕机快速恢复数据，尽可能的防止丢失数据。但是宕机后依然无法提供服务，所以便演化出主从架构、读写分离。</li>
<li>主从复制<code>原理</code>：连接建立阶段、数据同步阶段、命令传播阶段；数据同步阶段又分为 全量复制和部分复制；命令传播阶段主从节点之间有 PING 和 REPLCONF ACK 命令互相进行心跳检测。</li>
<li>主从复制<code>虽然解决或缓解了数据冗余、故障恢复、读负载均衡等问题</code>，但其<code>缺陷仍很明显：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制</code>；这些问题的解决，<code>需要哨兵和集群的帮助</code></li>
</ol>
<h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="什么是哨兵（Sentinel）"><a href="#什么是哨兵（Sentinel）" class="headerlink" title="什么是哨兵（Sentinel）"></a>什么是哨兵（Sentinel）</h3><p>Redis 主从架构就好比一个武当，掌门人就是 Master。掌门人如果挂了，需要从武当七侠里面选举能人担当掌门人。这就需要一个<code>部门</code>能监控掌门人的生死和武当其他弟子的生命状态，并且能够通过<code>投票</code>从武当弟子中选举一个能者担任新掌门，接着再举行新闻发布会向世界宣布新掌门的信息。这个「部门」就是哨兵。</p>
<blockquote>
<p><code>哨兵在选举新掌门</code>会遇到以下几个问题：</p>
<ol>
<li>如何判断掌门真的挂了，有可能假死；</li>
<li>到底选择哪一个武当子弟作为新掌门？</li>
<li>通过新闻发布会将新掌门的相关信息通知到所有武当弟子（slave 和 master）和整个武林（客户端）。</li>
</ol>
</blockquote>
<p><code>哨兵部门主要负责的任务是：监控整个武当、选择新掌门，通知整个武当和整个武林。</code></p>
<h3 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h3><p>哨兵是 Redis 的一种运行模式，它专注于<code>对 Redis 实例（主节点、从节点）运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性。</code>可以知道 Redis 哨兵具备的能力有如下几个：</p>
<blockquote>
<ul>
<li><code>监控</code>：持续监控 master 、slave 是否处于预期工作状态。</li>
<li><code>自动切换主库</code>：当 Master 运行故障，哨兵启动自动故障恢复流程：从 slave 中选择一台作为新 master。</li>
<li><code>通知</code>：让 slave 执行 replicaof ，与新的 master 同步；并且通知客户端与新 master 建立连接。</li>
</ul>
</blockquote>
<p><code>哨兵也是一个 Redis进程，只是不对外提供读写服务，通常哨兵要配置成单数</code></p>
<h4 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h4><p>Sentinel 只是武当弟子中的特殊部门，在默认情况下，Sentinel 通过飞鸽传书以<code>每秒一次</code>的频率向所有武当弟子、掌门与<code>哨兵（包括 Master、Slave、其他 Sentinel 在内）发送 PING 命令，如果 slave 没有在在规定时间内响应「哨兵」的 PING 命令</code>，「哨兵」就认为这哥们可能嗝屁了，就会将他记录为「下线状态」；</p>
<p>假如 master 掌门没有在规定时间响应 「哨兵」的 PING 命令，哨兵就判定掌门下线，开始执行「自动切换 master 掌门」的流程。</p>
<blockquote>
<p>PING 命令的回复有两种情况：</p>
<ol>
<li><code>有效回复</code>：返回 +PONG、-LOADING、-MASTERDOWN 任何一种；</li>
<li><code>无效回复</code>：有效回复之外的回复，或者指定时间内返回任何回复。</li>
</ol>
</blockquote>
<p>为了防止掌门「假死」，「哨兵」设计了<code>「主观下线」</code>和<code>「客观下线」</code>两种暗号。 </p>
<h5 id="主观下线"><a href="#主观下线" class="headerlink" title="主观下线"></a>主观下线</h5><p><code>哨兵利用 PING 命令来检测掌门、 slave 的生命状态</code>。如果是无效回复，哨兵就把这个哥们标记为「主观下线」。如果检测到的是武当小弟，也就是 slave 角色。那么就直接标记「主观下线」。</p>
<p>因为 master 掌门还在，slave 的嗝屁对整个武当影响不大。依然可以对外开会，比武论剑、吃香喝辣……</p>
<p>如果检测到是master 掌门完蛋，这时候哨兵不能这么简单的标记「主观下线」，开启新掌门选举。</p>
<p>因为有可能出现误判，掌门并没有嗝屁，一旦启动了掌门切换，后续的选主、通知开发布会，slave 花时间与新 master 同步数据都会消耗大量资源。</p>
<p>所以<code>「哨兵」要降低误判的概率，误判一般会发生在集群网络压力较大、网络拥塞，或者是主库本身压力较大的情况下</code>。</p>
<p><code>既然一个人容易误判，那就多个人一起投票判断。哨兵机制也是类似的，采用多实例组成的集群模式进行部署</code>，这就是<code>哨兵集群</code>。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。</p>
<p>同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p>
<h5 id="客观下线"><a href="#客观下线" class="headerlink" title="客观下线"></a>客观下线</h5><p><code>判断 master 是否下线不能只有一个「哨兵」说了算，只有过半的哨兵判断 master 已经「主观下线」，这时候才能将 master 标记为「客观下线」</code>，也就是说这是一个客观事实，掌门真的嗝屁了，华佗再世也治不好了。</p>
<p><code>只有 master 被判定为「客观下线」，才会进一步触发哨兵开始主从切换流程</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/22/NjtsgJpDe2k1Xvc.jpg"></p>
<h5 id="主观下线与客观下线的区别"><a href="#主观下线与客观下线的区别" class="headerlink" title="主观下线与客观下线的区别"></a>主观下线与客观下线的区别</h5><p>简单来说，<code>主观下线是哨兵自己认为节点宕机，而客观下线是不但哨兵自己认为节点宕机，而且该哨兵与其他哨兵沟通后，达到一定数量的哨兵都认为该哥们嗝屁了。</code></p>
<p>这里的「一定数量」是一个<code>法定数量（Quorum），是由哨兵监控配置决定的</code>，解释一下该配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># sentinel monitor &lt;master-name&gt; &lt;master-host&gt; &lt;master-port&gt; &lt;quorum&gt;</span><br><span class="line">sentinel monitor mymaster 127.0.0.1 6379 2</span><br></pre></td></tr></table></figure>

<p>这条配置项用于告知哨兵需要监听的主节点：</p>
<blockquote>
<ul>
<li>sentinel monitor：代表监控。</li>
<li>mymaster：代表<code>主节点的名称</code>，可以自定义。</li>
<li>127.0.0.1 6379：代表监控的<code>主节点 ip</code>，<code>6379 代表端口</code>。</li>
<li>2：<code>法定数量</code>，代表只有<code>两个或两个以上的哨兵认为主节点不可用的时候，才会把 master 设置为客观下线状态</code>，然后进行 <code>failover 操作</code>。</li>
</ul>
</blockquote>
<h4 id="自动切换主库"><a href="#自动切换主库" class="headerlink" title="自动切换主库"></a>自动切换主库</h4><p>「哨兵」的第二个任务，选择新 master 掌门。需要从武当弟子中按照一定规则选择一个牛逼人物作为新掌门，完成选任掌门后，新 master 带领众弟子一起吃香喝辣。</p>
<p>按照一定的<code>「筛选条件」 + 「打分」 </code>策略，选出<code>「最强王者」</code>担任掌门，也就是通过一些条件海选过滤一些「无能之辈」，接着将通过海选的靓仔全都打分排名，将最高者选为新 master。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/22/PBz6E59RHgaAifJ.jpg"></p>
<h5 id="筛选条件"><a href="#筛选条件" class="headerlink" title="筛选条件"></a>筛选条件</h5><blockquote>
<ul>
<li>从库当前在线状态，下线的直接丢弃；</li>
<li>评估之前的网络连接状态 <code>down-after-milliseconds * 10</code>：如果从库总是和主库断连，而且断连次数超出了一定的阈值（10 次），我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</li>
</ul>
</blockquote>
<h5 id="打分"><a href="#打分" class="headerlink" title="打分"></a>打分</h5><p>过滤掉不合适的 slave 之后，则进入打分环节。打分会按照三个规则进行三轮打分，规则分别为：</p>
<blockquote>
<ol>
<li><code>slave 优先级</code>，通过 slave-priority 配置项，给不同的从库设置不同优先级（后台有人没办法），优先级高的直接晋级为新 master 掌门。</li>
<li>slave_repl_offset与 master_repl_offset进度差距（谁的武功与之前掌门的功夫越接近谁就更牛逼），如果都一样，那就继续下一个规则。其实就是<code>比较 slave 与旧 master 复制进度的差距</code>；</li>
<li>slave runID，在优先级和复制进度都相同的情况下，<code>ID 号最小的从库得分最高，会被选为新主库</code>。（论资排辈，根据 runID 的创建时间来判断，时间早的上位）；</li>
</ol>
</blockquote>
<h4 id="通知"><a href="#通知" class="headerlink" title="通知"></a>通知</h4><p>重新选举新 master 掌门这种事情，何等大事，怎能不告知天下。再者其他 slave 弟子也要知道新掌门是谁，一起追随新掌门吃香喝辣大保健。</p>
<p>最后一个任务，「哨兵」将新 「master 掌门」的连接信息发送给其他 slave 武当弟子，并且让 slave 执行 replacaof 命令，和新「master 掌门」建立连接，并进行数据复制学习新掌门的所有武功。</p>
<p>除此之外，「哨兵」还需要将新掌门的连接信息通知整个武林（客户端），使得让所有想拜访、讨教的人能找到新任掌门，这样诸多事宜才能交给新掌门做决定（<code>将读写请求转移到新 master</code>）。</p>
<h4 id="哨兵的主要任务与实现目标"><a href="#哨兵的主要任务与实现目标" class="headerlink" title="哨兵的主要任务与实现目标"></a>哨兵的主要任务与实现目标</h4><p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/22/qIxsnJGyzraOg3j.jpg"></p>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>「哨兵」部门并不是一个人，多个人共同组成一个「哨兵集群」，即使有一些「哨兵」被老王打死了，其他的「哨兵」依然可以共同协作完成监控、新掌门选举以及通知 slave 、master 以及每一个武林人士（客户端）。</p>
<p>在配置哨兵集群的时候，哨兵配置中只设置了监控的 master IP 和 port，并没有配置其他哨兵的连接信息。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;master-host&gt; &lt;master-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>

<p><code>哨兵之间是如何知道彼此的？如何知道slave并监控他们的？由哪一个「哨兵」执行主从切换呢？</code></p>
<h4 id="pub-x2F-sub-实现哨兵间通信和发现-slave"><a href="#pub-x2F-sub-实现哨兵间通信和发现-slave" class="headerlink" title="pub&#x2F;sub 实现哨兵间通信和发现 slave"></a>pub&#x2F;sub 实现哨兵间通信和发现 slave</h4><p>哨兵之间可以相互通信约会搞事情，主要归功于 Redis 的<code>pub/sub 发布/订阅机制</code>。</p>
<p>哨兵与 master 建立通信，利用 master 提供发布&#x2F;订阅机制发布自己的信息，比如身高体重、是否单身、IP、端口……</p>
<p>master 有一个 <code>__sentinel__:hello</code> 的专用通道，用于哨兵之间发布和订阅消息。这就<code>好比是 __sentinel__:hello 微信群，哨兵利用master建立的微信群发布自己的消息，同时关注其他哨兵发布的消息。</code></p>
<p>当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口，从而相互发现建立连接。</p>
<p>Redis 通过频道的方式对消息进行分别管理，这里的频道其实就是不同的微信群。</p>
<p><code>哨兵之间建立连接形成集群还不够，还需要跟slave建立连接，不然没法监控他们，无法对主从库进行心跳判断。</code></p>
<p>除此之外，如果发生了主从切换也得通知slave重新跟新master建立连接执行数据同步。</p>
<p>关键还是利用 master 来实现，哨兵向 master 发送 INFO 命令， master 掌门自然是知道自己门下所有的 salve 小弟的。所以 master 接收到命令后，便将 <code>slave 列表</code>告诉哨兵。</p>
<p>哨兵根据 master 响应的 slave 名单信息与每一个 salve 建立连接，并且根据这个连接持续监控哨兵。</p>
<p>如图所示，哨兵 2 向 Master 发送 INFO 命令，Master 就把 slave 列表返回给哨兵 2，哨兵 2 便根据 slave 列表连接信息与每一个 slave 建立连接，并基于此连接实现持续监控。</p>
<p>剩下的哨兵也同理基于此实现监控。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/22/a57ZqD1r43nWmoH.jpg"></p>
<h4 id="选择哨兵执行主从切换"><a href="#选择哨兵执行主从切换" class="headerlink" title="选择哨兵执行主从切换"></a>选择哨兵执行主从切换</h4><blockquote>
<p>哨兵这么多，那到底让哪一个哨兵来执行新 master 切换呢？</p>
</blockquote>
<p>这个跟哨兵判断 master “客观下线”类似，也是通过投票的方式选出来的。</p>
<p><code>任何一个哨兵判断 master “主观下线”后，就会给其他哨兵基友发送 is-master-down-by-addr 命令，好基友则根据自己跟 master 之间的连接状况分别响应 Y 或者 N ，Y 表示赞成票， N 就是反对。</code></p>
<p>如果某个哨兵获得了大多数哨兵的“赞成票”之后，就可以标记 master 为 “客观下线”，赞成票数是通过哨兵配置文件中的 quorum 配置项设定。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;master-host&gt; &lt;master-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure>

<p>比如一共 3 个哨兵组成集群，那么 quorum 就可以配置成 2，当一个哨兵获得了 2 张赞成票，就可以标记 master “客观下线”，当然这个票<code>包含自己的那一票</code>。</p>
<p><code>获得多数赞成票的哨兵可以向其他哨兵发送命令，申明自己想要执行主从切换</code>。并让其他哨兵进行投票，<code>投票过程就叫做 “Leader 选举”</code>。</p>
<blockquote>
<p>想要成为 “Leader”没那么简单，得有两把刷子。需要满足以下条件：</p>
<ol>
<li>获得其他哨兵基友过半的赞成票；</li>
<li>赞成票的数量还要<code>大于等于</code>配置文件的 quorum 的值。</li>
</ol>
</blockquote>
<p>如果哨兵集群有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置3个哨兵实例。这也是为啥<code>哨兵集群部署成单数的原因，双数的话多余浪费</code>。</p>
<h4 id="通过-pub-x2F-sub-实现客户端事件通知"><a href="#通过-pub-x2F-sub-实现客户端事件通知" class="headerlink" title="通过 pub&#x2F;sub 实现客户端事件通知"></a>通过 pub&#x2F;sub 实现客户端事件通知</h4><blockquote>
<p><code>新 master 选出来了，要怎么公示天下呢？</code></p>
</blockquote>
<p>当然是召开新闻发布会呀，邀请消息相关类型的媒体报道传播，感兴趣的人自然就去关注订阅相关事件，并根据事件做出行动。</p>
<p>在 Redis 也是类似，通过 pub&#x2F;sub 机制发布不同事件，让客户端在这里订阅消息。客户端可以订阅哨兵的消息，哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p>
<p>也就是在不同的“微信群”发布不同的事件，让对该事件感兴趣的人进群即可。</p>
<ul>
<li>master 下线事件</li>
</ul>
<blockquote>
<p>+sdown：进入“主观下线”状态；<br>-sdown：退出“主观下线”状态；<br>+odown：进入“客观下线”状态；<br>-odown：退出“客观下线”状态；</p>
</blockquote>
<ul>
<li>slave 重新配置事件</li>
</ul>
<blockquote>
<p>+slave-reconf-sent：哨兵发送 replicaof 命令重新配置从库；<br>+slave-reconf-inprog：slave 配置了新 master，但是尚未进行同步；<br>+slave-reconf-done：slave 配置了新 master，并与新 master 完成了数据同步；</p>
</blockquote>
<ul>
<li>新主库切换</li>
</ul>
<blockquote>
<p>+switch-master：master 地址发生了变化。</p>
</blockquote>
<p>知道了这些频道之后，就可以让客户端从哨兵这里订阅消息了。客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。</p>
<p>然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p>
<p>举个栗子：如下指令订阅<code>“所有实例进入客观下线状态的事件”</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></table></figure>

<h3 id="注意事项与配置说明"><a href="#注意事项与配置说明" class="headerlink" title="注意事项与配置说明"></a>注意事项与配置说明</h3><p>发现了没，Redis 的 pub&#x2F;sub 发布订阅机制尤其重要，有了 pub&#x2F;sub 机制，哨兵和哨兵之间、哨兵和从库之间、哨兵和客户端之间就都能建立起连接了，各种事件的发布也是通过这个机制实现。</p>
<blockquote>
<ul>
<li>down-after-milliseconds</li>
</ul>
</blockquote>
<p>Sentinel 配置文件中的 down-after-milliseconds 选项指定了 Sentinel 判断实例进入主观下线所需的时间长度：如果一个实例在 down-after-milliseconds 毫秒内，连续向 Sentinel 返回无效回复，那么 Sentinel 会修改这个实例所对应数据，以此来表示这个实例已经进入主观下线状态。</p>
<p>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds。<code>因为这个值在不同的哨兵实例上配置不一致，导致哨兵集群一直没有对有故障的主库形成共识，也就没有及时切换主库，最终的结果就是集群服务不稳定。</code></p>
<blockquote>
<ul>
<li>down-after-milliseconds * 10</li>
</ul>
</blockquote>
<p>down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p>
<h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><h3 id="为什么需要-Cluster"><a href="#为什么需要-Cluster" class="headerlink" title="为什么需要 Cluster"></a>为什么需要 Cluster</h3><blockquote>
<p>最近遇到一个糟心的问题，Redis 需要保存 800 万个键值对，占用 20 GB 的内存。<br/><br>我就使用了一台 32G 的内存主机部署，但是 Redis 响应有时候非常慢，使用 INFO 命令查看 latest_fork_usec 指标（最近一次 fork 耗时），发现特别高。</p>
</blockquote>
<p><code>主要是 Redis RDB 持久化机制导致的</code>，Redis 会 Fork 子进程完成 RDB 持久化操作，fork 执行的耗时与 Redis 数据量成正相关。</p>
<p>而 Fork 执行的时候会阻塞主线程，由于数据量过大导致阻塞主线程过长，所以出现了 Redis 响应慢的表象。</p>
<blockquote>
<p>随着业务规模的拓展，数据量越来越大。主从架构升级单个实例硬件难以拓展，且保存大数据量会导致响应慢问题，有什么办法可以解决么？</p>
</blockquote>
<p>保存大量数据，除了使用大内存主机的方式，我们还可以使用切片集群。一台机器无法保存所有数据，那就多台分担。</p>
<p><code>使用 Redis Cluster 集群，主要解决了大数据量存储导致的各种慢问题，同时也便于横向拓展。</code></p>
<blockquote>
<p>Redis 数据增多的两种拓展方案：<code>垂直扩展（scale up）</code>、<code>水平扩展（scale out）</code>。</p>
<ol>
<li>垂直拓展：<code>升级单个 Redis 的硬件配置</code>，比如增加内存容量、磁盘容量、使用更强大的 CPU。</li>
<li>水平拓展：<code>横向增加 Redis 实例个数，每个节点负责一部分数据</code>。</li>
</ol>
</blockquote>
<p>比如需要一个内存 24 GB 磁盘 150 GB 的服务器资源，有以下两种方案：<br><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/Irxn2CifGlO5ASs.jpg"></p>
<p><code>在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择。</code></p>
<blockquote>
<ul>
<li><code>那这两种方案都有什么优缺点呢？</code></li>
</ul>
<ol>
<li><code>垂直拓展部署简单</code>，但是当数据量大并且使用 RDB 实现持久化，会造成阻塞导致响应慢。另外受限于硬件和成本，拓展内存的成本太大，比如拓展到 1T 内存。</li>
<li><code>水平拓展便于拓展</code>，同时不需要担心单个实例的硬件和成本的限制。但是，切片集群会涉及多个实例的分布式管理问题，需要解决如何将数据合理分布到不同实例，同时还要让客户端能正确访问到实例上的数据。</li>
</ol>
</blockquote>
<h3 id="什么是-Cluster-集群"><a href="#什么是-Cluster-集群" class="headerlink" title="什么是 Cluster 集群"></a>什么是 Cluster 集群</h3><p>Redis 集群是一种分布式数据库方案，<code>集群通过分片（sharding）来进行数据管理，并提供复制和故障转移功能</code>。</p>
<p>将数据划分为<code>16384</code>的 slots，每个节点负责一部分槽位。槽位的信息存储于每个节点中。</p>
<p>它是去中心化的，如图所示，该集群有三个 Redis 节点组成，每个节点负责整个集群的一部分数据，每个节点负责的数据多少可能不一样。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/27MmVBPWrYfTU8F.jpg"></p>
<p>三个节点相互连接组成一个对等的集群，它们之间通过 <code>Gossip协议</code>相互交互集群信息，最后每个节点都保存着其他节点的 slots 分配情况。</p>
<blockquote>
<p>Gossip 的中文意思就是流言蜚语，该协议就像流言蜚语一样，利用一种随机、带有传染性的方式，将信息传播到整个网络中，并在一定时间内，使得系统内的所有节点数据一致。这个就是实现了最终一致性的协议。</p>
</blockquote>
<h3 id="节点间的握手"><a href="#节点间的握手" class="headerlink" title="节点间的握手"></a>节点间的握手</h3><p>一个 Redis 集群通常由多个节点（node）组成，在刚开始的时候，每个节点都是相互独立的，它们都处于一个只包含自己的集群当中，<code>要组建一个真正可工作的集群，我们必须将各个独立的节点连接起来，构成一个包含多个节点的集群。</code></p>
<p>连接各个节点的工作可以通过<code>CLUSTER MEET</code>命令完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLUSTER MEET &lt;ip&gt; &lt;port&gt; 。</span><br></pre></td></tr></table></figure>
<p>向一个节点 node 发送 <code>CLUSTER MEET </code>命令，可以<code>让 node 节点与 ip 和 port 所指定的节点进行握手（handshake）</code>，当握手成功时，node 节点就会将 ip 和 port 所指定的节点添加到 node 节点当前所在的集群中。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/Xbh5oku3RVE8v7m.jpg"></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote>
<p>数据切片后，需要将数据分布在不同实例上，数据和实例之间如何对应上呢？</p>
</blockquote>
<p>Redis 3.0 开始，官方提供了 Redis Cluster 方案实现了切片集群，该方案就实现了数据和实例的规则。Redis Cluster 方案采用哈希槽（Hash Slot），来处理数据和实例之间的映射关系。</p>
<h4 id="将数据分成多份存在不同实例上"><a href="#将数据分成多份存在不同实例上" class="headerlink" title="将数据分成多份存在不同实例上"></a>将数据分成多份存在不同实例上</h4><p>集群的整个数据库被分为 <code>16384 个槽（slot）</code>，数据库中的每个键都属于这 16384 个槽的其中一个，集群中的每个节点可以处理 0 个或最多 16384 个槽。</p>
<blockquote>
<p><code>Key 与哈希槽映射过程可以分为两大步骤：</code></p>
<ol>
<li>根据键值对的 key，使用 CRC16 算法，计算出一个 16 bit 的值；</li>
<li>将 16 bit 的值对 16384 执行取模，得到 0 ～ 16383 的数表示 key 对应的哈希槽。</li>
</ol>
</blockquote>
<p><code>Cluster 还允许用户强制某个 key 挂在特定槽位上</code>，通过在 key 字符串里面嵌入 tag 标记，这就可以强制 key 所挂在的槽位等于 tag 所在的槽位。</p>
<h4 id="哈希槽与-Redis-实例映射"><a href="#哈希槽与-Redis-实例映射" class="headerlink" title="哈希槽与 Redis 实例映射"></a>哈希槽与 Redis 实例映射</h4><blockquote>
<p>哈希槽又是如何映射到 Redis 实例上呢？</p>
</blockquote>
<p>在 部署集群的样例中通过<code> cluster create 创建</code>，Redis 会自动将 16384 个 哈希槽平均分布在集群实例上，<code>比如 N 个节点，每个节点上的哈希槽数 = 16384 / N 个</code>。</p>
<p>除此之外，可以通过<code> CLUSTER MEET 命令将 7000、7001、7002 三个节点连在一个集群</code>，<code>但是集群目前依然处于下线状态，因为三个实例都没有处理任何哈希槽。</code></p>
<p>可以使用 <code>cluster addslots 命令，指定每个实例上的哈希槽个数</code>。</p>
<blockquote>
<p>为啥要手动制定呢？</p>
</blockquote>
<p>能者多劳嘛，加入集群中的 Redis 实例配置不一样，如果承担一样的压力，对于垃圾机器来说就太难了，让牛逼的机器多支持一点。</p>
<p>三个实例的集群，通过下面的指令为每个实例分配哈希槽：<code>实例 1负责 0 ～ 5460 哈希槽</code>，<code>实例 2 负责 5461~10922 哈希槽</code>，<code>实例 3 负责 10923 ～ 16383 哈希槽。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 172.16.19.1 –p 6379 cluster addslots 0,5460</span><br><span class="line">redis-cli -h 172.16.19.2 –p 6379 cluster addslots 5461,10922</span><br><span class="line">redis-cli -h 172.16.19.3 –p 6379 cluster addslots 10923,16383</span><br></pre></td></tr></table></figure>

<p>键值对数据、哈希槽、Redis 实例之间的映射关系如下：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/joWHpQvFAakNCbq.jpg"></p>
<p>Redis 键值对的 key 经过 CRC16 计算后再对哈希槽总个数 16384 取模，模数结果分别映射到实例 1 与实例 3 上。</p>
<blockquote>
<p>注：<code>当 16384 个槽都分配完全，Redis 集群才能正常工作</code>。</p>
</blockquote>
<h4 id="复制与故障转移"><a href="#复制与故障转移" class="headerlink" title="复制与故障转移"></a>复制与故障转移</h4><blockquote>
<p>Redis 集群如何实现高可用呢？Master 与 Slave 还是读写分离么？</p>
</blockquote>
<p>Master 用于处理槽，Slave节点则通过主从复制方式同步主节点数据。</p>
<p><code>当 Master 下线，Slave 代替主节点继续处理请求。</code>主从节点之间并没有读写分离， <code>Slave 只用作 Master 宕机的高可用备份。</code></p>
<p>Redis Cluster 可以为每个主节点设置若干个从节点，单主节点故障时，集群会自动将其中某个从节点提升为主节点。</p>
<p><code>如果某个主节点没有从节点，那么当它发生故障时，集群将完全处于不可用状态。</code></p>
<p>不过 Redis 也提供了一个参数<code>cluster-require-full-coverage</code>可以允许部分节点故障，其它节点还可以继续提供对外访问。</p>
<p><code>比如 7000 主节点宕机，作为 slave 的 7003 成为 Master 节点继续提供服务。当下线的节点 7000 重新上线，它将成为当前 70003 的从节点。</code></p>
<h5 id="故障检测"><a href="#故障检测" class="headerlink" title="故障检测"></a>故障检测</h5><blockquote>
<p>哨兵通过监控、自动切换主库、通知客户端实现故障自动切换，Cluster 又如何实现故障自动转移呢？</p>
</blockquote>
<p>一个节点认为某个节点失联了并不代表所有的节点都认为它失联了。<code>只有当大多数负责处理 slot 节点都认定了某个节点下线了，集群才认为该节点需要进行主从切换。</code></p>
<p>Redis 集群节点采用 Gossip 协议来广播自己的状态以及自己对整个集群认知的改变。比如一个节点发现某个节点失联了 (PFail)，它会将这条信息向整个集群广播，其它节点也就可以收到这点失联信息。</p>
<p><code>如果一个节点收到了某个节点失联的数量 (PFail Count) 已经达到了集群的大多数，就可以标记该节点为确定下线状态 (Fail)，然后向整个集群广播，强迫其它节点也接收该节点已经下线的事实，并立即对该失联节点进行主从切换。</code></p>
<h5 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h5><p>当一个 Slave 发现自己的主节点进入已下线状态后，从节点将开始对下线的主节点进行故障转移。</p>
<blockquote>
<ol>
<li>从下线的 Master 及节点的 Slave 节点列表选择一个节点成为新主节点。</li>
<li>新主节点会撤销所有对已下线主节点的 slot 指派，并将这些 slots 指派给自己。</li>
<li>新的主节点向集群广播一条PONG消息，这条PONG消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收处理槽有关的命令请求，故障转移完成。</li>
</ol>
</blockquote>
<h5 id="选主流程"><a href="#选主流程" class="headerlink" title="选主流程"></a>选主流程</h5><blockquote>
<p>新的主节点如何选举产生的？</p>
</blockquote>
<ol>
<li>集群的配置纪元 +1，是一个自曾计数器，初始值0，每次执行故障转移都会 +1。</li>
<li>检测到主节点下线的从节点向集群广播一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_REQUEST</code>消息，要求所有收到这条消息、并且具有投票权的主节点向这个从节点投票。</li>
<li>这个主节点尚未投票给其他从节点，那么主节点将向要求投票的从节点返回一条<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，表示这个主节点支持从节点成为新的主节点。</li>
<li>参与选举的从节点都会接收<code>CLUSTERMSG_TYPE_FAILOVER_AUTH_ACK</code>消息，如果收集到的<code>票 &gt;= (N/2) + 1 </code>支持，那么这个从节点就被选举为新主节点。</li>
<li>如果在一个配置纪元里面没有从节点能收集到足够多的支持票，那么集群进入一个新的配置纪元，并再次进行选举，直到选出新的主节点为止。</li>
</ol>
<p>跟哨兵类似，两者都是基于 Raft 算法来实现的，流程如图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/OQZ8XFgHClry7mh.jpg"></p>
<h4 id="用表保存键值对和实例的关联关系可行么"><a href="#用表保存键值对和实例的关联关系可行么" class="headerlink" title="用表保存键值对和实例的关联关系可行么"></a>用表保存键值对和实例的关联关系可行么</h4><blockquote>
<p>Redis Cluster 方案通过哈希槽的方式把键值对分配到不同的实例上，这个过程需要对键值对的 key 做 CRC 计算并对 哈希槽总数取模映射到实例上。如果用一个表直接把键值对和实例的对应关系记录下来（例如键值对 1 在实例 2 上，键值对 2 在实例 1 上），这样就不用计算 key 和哈希槽的对应关系了，只用查表就行了，Redis 为什么不这么做呢？</p>
</blockquote>
<p>使用一个全局表记录的话，假如键值对和实例之间的关系改变（重新分片、实例增减），需要修改表。如果是单线程操作，所有操作都要串行，性能太慢。</p>
<p>多线程的话，就涉及到加锁，另外，如果键值对数据量非常大，保存键值对与实例关系的表数据所需要的存储空间也会很大。</p>
<p>而哈希槽计算，虽然也要记录哈希槽与实例时间的关系，但是哈希槽的数量少得多，只有 16384 个，开销很小。</p>
<h3 id="客户端如何定位数据所在实例"><a href="#客户端如何定位数据所在实例" class="headerlink" title="客户端如何定位数据所在实例"></a>客户端如何定位数据所在实例</h3><p>Redis 实例会将自己的哈希槽信息通过 Gossip 协议发送给集群中其他的实例，实现了哈希槽分配信息的扩散。</p>
<p>这样，集群中的每个实例都有所有哈希槽与实例之间的映射关系信息。</p>
<p>在切片数据的时候是将 key 通过 CRC16 计算出一个值再对 16384 取模得到对应的 Slot，<code>这个计算任务可以在客户端上执行发送请求的时候执行。</code></p>
<p>但是，定位到槽以后还需要进一步定位到该 Slot 所在 Redis 实例。</p>
<p>当客户端连接任何一个实例，实例就将哈希槽与实例的映射关系响应给客户端，客户端就会将哈希槽与实例映射信息缓存在本地&#96;。</p>
<p>当客户端请求时，会计算出键所对应的哈希槽，在通过本地缓存的哈希槽实例映射信息定位到数据所在实例上，再将请求发送给对应的实例。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/ReV9iznQJqN8bSf.jpg"></p>
<h4 id="重新分配哈希槽"><a href="#重新分配哈希槽" class="headerlink" title="重新分配哈希槽"></a>重新分配哈希槽</h4><blockquote>
<p>哈希槽与实例之间的映射关系由于新增实例或者负载均衡重新分配导致改变了咋办？</p>
</blockquote>
<p>集群中的实例通过 Gossip 协议互相传递消息获取最新的哈希槽分配信息，但是，客户端无法感知。</p>
<p>Redis Cluster 提供了重定向机制：<code>客户端将请求发送到实例上，这个实例没有相应的数据，该 Redis 实例会告诉客户端将请求发送到其他的实例上。</code></p>
<blockquote>
<p>Redis 如何告知客户端重定向访问新实例呢？</p>
</blockquote>
<p>分为两种情况：<code>MOVED 错误、ASK 错误。</code></p>
<h5 id="MOVED-错误"><a href="#MOVED-错误" class="headerlink" title="MOVED 错误"></a>MOVED 错误</h5><p>MOVED 错误（负载均衡，数据已经迁移到其他实例上）：<code>当客户端将一个键值对操作请求发送给某个实例，而这个键所在的槽并非由自己负责的时候，该实例会返回一个 MOVED 错误指引转向正在负责该槽的节点。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET key:value</span><br><span class="line">(error) MOVED 16330 172.17.18.2:6379</span><br></pre></td></tr></table></figure>
<p>该响应表示客户端请求的键值对所在的哈希槽 16330 迁移到了 172.17.18.2 这个实例上，端口是 6379。这样客户端就与 172.17.18.2:6379 建立连接，并发送 GET 请求。</p>
<p>同时，<code>客户端还会更新本地缓存，将该 slot 与 Redis 实例对应关系更新正确。</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/fKagB78W9tvFSxJ.jpg"></p>
<h5 id="ASK-错误"><a href="#ASK-错误" class="headerlink" title="ASK 错误"></a>ASK 错误</h5><blockquote>
<p>如果某个 slot 的数据比较多，部分迁移到新实例，还有一部分没有迁移咋办？</p>
</blockquote>
<p>如果请求的 key 在当前节点找到就直接执行命令，否则就需要 ASK 错误响应了，槽部分迁移未完成的情况下，如果需要访问的 key 所在 Slot 正在从从 实例 1 迁移到 实例 2，实例 1 会返回客户端一条 ASK 报错信息：<code>客户端请求的 key 所在的哈希槽正在迁移到实例 2 上，你先给实例 2 发送一个 ASKING 命令，接着发送操作命令。</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GET key:value</span><br><span class="line">(error) ASK 16330 172.17.18.2:6379</span><br></pre></td></tr></table></figure>

<p>比如客户端请求定位到 key &#x3D; value 的槽 16330 在实例 172.17.18.1 上，节点 1 如果找得到就直接执行命令，否则响应 ASK 错误信息，并指引客户端转向正在迁移的目标节点 172.17.18.2。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/24/kquFB5J2mo3Zaxw.jpg"></p>
<p><code>注：ASK 错误指令并不会更新客户端缓存的哈希槽分配信息。</code></p>
<p>所以客户端再次请求 Slot 16330 的数据，还是会先给 172.17.18.1 实例发送请求，只不过节点会响应 ASK 命令让客户端给新实例发送一次请求。</p>
<p><code>MOVED指令则更新客户端本地缓存，让后续指令都发往新实例。</code></p>
<h3 id="集群可以设置多大"><a href="#集群可以设置多大" class="headerlink" title="集群可以设置多大"></a>集群可以设置多大</h3><blockquote>
<p>有了 Redis Cluster，再也不怕大数据量了，我可以无限水平拓展么？</p>
</blockquote>
<p>答案是否定的，<code>Redis 官方给的 Redis Cluster 的规模上线是 1000 个实例。</code></p>
<blockquote>
<p>到底是什么限制了集群规模呢？</p>
</blockquote>
<p><code>关键在于实例间的通信开销</code>，Cluster 集群中的每个实例都保存所有哈希槽与实例对应关系信息（Slot 映射到节点的表），以及自身的状态信息。</p>
<blockquote>
<p>在集群之间每个实例通过 Gossip协议传播节点的数据，Gossip 协议工作原理大概如下：</p>
<ol>
<li><code>从集群中随机选择一些实例按照一定的频率发送 PING 消息发送给挑选(随机)出来的实例</code>，用于检测实例状态以及交换彼此的信息。PING 消息中封装了发送者自身的状态信息、部分其他实例的状态信息、Slot 与实例映射表信息。</li>
<li>实例接收到 PING 消息后，响应 PONG 消息，消息包含的信息跟 PING 消息一样。</li>
</ol>
</blockquote>
<p>集群之间通过<code>Gossip协议</code>可以在一段时间之后每个实例都能获取其他所有实例的状态信息。</p>
<p>所以在有新节点加入，节点故障，Slot 映射变更都可以<code>通过 PING，PONG 的消息传播完成集群状态在每个实例的传播同步</code>。</p>
<h4 id="Gossip-消息"><a href="#Gossip-消息" class="headerlink" title="Gossip 消息"></a>Gossip 消息</h4><p>发送的消息结构是<code>clusterMsgDataGossip</code>结构体组成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">    char nodename[CLUSTER_NAMELEN];  //40字节</span><br><span class="line">    uint32_t ping_sent; //4字节</span><br><span class="line">    uint32_t pong_received; //4字节</span><br><span class="line">    char ip[NET_IP_STR_LEN]; //46字节</span><br><span class="line">    uint16_t port;  //2字节</span><br><span class="line">    uint16_t cport;  //2字节</span><br><span class="line">    uint16_t flags;  //2字节</span><br><span class="line">    uint32_t notused1; //4字节</span><br><span class="line">&#125; clusterMsgDataGossip;</span><br></pre></td></tr></table></figure>

<p>所以每个实例发送一个 Gossip消息，就需要发送 104 字节。如果集群是 1000 个实例，那么每个实例发送一个 PING 消息则会占用 大约 10KB。</p>
<p>除此之外，实例间在传播 Slot 映射表的时候，每个消息还包含了 一个长度为 16384 bit 的 Bitmap。</p>
<p>每一位对应一个 Slot，如果值 &#x3D; 1 则表示这个 Slot 属于当前实例，这个 Bitmap 占用 2KB，所以一个 PING 消息大约 12KB。</p>
<p>PONG与PING 消息一样，一发一回两个消息加起来就是 24 KB。集群规模的增加，心跳消息越来越多就会占据集群的网络通信带宽，降低了集群吞吐量。</p>
<h4 id="实例的通信频率"><a href="#实例的通信频率" class="headerlink" title="实例的通信频率"></a>实例的通信频率</h4><blockquote>
<p>发送 PING 消息的频率也会影响集群带宽吧？</p>
</blockquote>
<p>Redis Cluster 的实例启动后，<code>默认会每秒从本地的实例列表中随机选出 5 个实例</code>，再从这 5 个实例中找出一个最久没有收到 PING 消息的实例，把 PING 消息发送给该实例。</p>
<blockquote>
<p>随机选择 5 个，但是无法保证选中的是整个集群最久没有收到 PING 通信的实例，有的实例可能一直没有收到消息，导致他们维护的集群信息早就过期了，咋办呢？</p>
</blockquote>
<p><code>Redis Cluster 的实例每 100 ms 就会扫描本地实例列表</code>，当发现有实例最近一次收到 PONG 消息的<code>时间 &gt; cluster-node-timeout / 2</code>。那么就立刻给这个实例发送 PING 消息，更新这个节点的集群状态信息。</p>
<p>当集群规模变大，就会进一步导致实例间网络通信延迟增加。可能会引起更多的 PING 消息频繁发送。</p>
<blockquote>
<ul>
<li>降低实例间的通信开销</li>
</ul>
<ol>
<li>每个实例每秒发送一条 PING消息，降低这个频率可能会导致集群每个实例的状态信息无法及时传播。</li>
<li><code>每 100 ms 检测实例 PONG消息接收是否超过 cluster-node-timeout / 2</code>，这个是 Redis 实例<code>默认的周期性检测任务频率</code>，我们不会轻易修改。</li>
</ol>
</blockquote>
<p>所以，<code>只能修改 cluster-node-timeout</code>的值：集群中判断实例是否故障的心跳时间，<code>默认 15 S</code>。</p>
<p>所以，<code>为了避免过多的心跳消息占用集群宽带，将 cluster-node-timeout调成 20 秒或者 30 秒，这样 PONG 消息接收超时的情况就会缓解。</code></p>
<p>但是，<code>也不能设置的太大，太大就会导致实例发生故障</code>，却要等待 cluster-node-timeout时长才能检测出这个故障，影响集群正常服务。</p>
<p>　　</p>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><p>在Resid安装目录下，使用<code>redis-cli客户端连接Redis数据库</code></p>
<h2 id="远程连接"><a href="#远程连接" class="headerlink" title="远程连接"></a>远程连接</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -h [ip] -p [host] -a [密码]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果Redis设置了密码，则需要使用密码连接</span></span><br></pre></td></tr></table></figure>



<h2 id="keys-pattern"><a href="#keys-pattern" class="headerlink" title="keys pattern"></a>keys pattern</h2><p><code>获取所有与pattern匹配的key</code>，返回所有与该key匹配的keys。Patterm参数解析：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/WOiUV69mgHh5DXF.png"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; keys *</span><br><span class="line">1) <span class="string">&quot;company&quot;</span></span><br><span class="line">2) <span class="string">&quot;mylist&quot;</span></span><br><span class="line">3) <span class="string">&quot;myhash&quot;</span></span><br><span class="line">4) <span class="string">&quot;myset&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="del-key1-key2…"><a href="#del-key1-key2…" class="headerlink" title="del key1 key2…"></a>del key1 key2…</h2><p><code>删除一个或多个指定的key</code>，返回值是删除key的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del company</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h2 id="exists-key"><a href="#exists-key" class="headerlink" title="exists key"></a>exists key</h2><p><code>判断该key是否存在</code>，1代表存在，0代表不存在</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; exists compnay</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; exists mylist</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="type-key"><a href="#type-key" class="headerlink" title="type key"></a>type key</h2><p><code>获取指定key的类型</code>。该命令将以字符串的格式返回。 返回的字符串为<code>string、list、set、hash</code>，如果key<code>不存在返回none</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> company</span><br><span class="line">string</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> mylist</span><br><span class="line">list</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myset</span><br><span class="line"><span class="built_in">set</span></span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> myhash</span><br><span class="line"><span class="built_in">hash</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<h2 id="select"><a href="#select" class="headerlink" title="select"></a>select</h2><p>一个Redis服务器可以包括多个数据库，客户端可以指定连接Redis中的哪个数据库，就好比一个mysql服务器中创建多个数据库，客户端连接时指定连接到哪个数据库。<code>一个Redis实例最多可提供16个数据库，下标为0到15，客户端默认连接第0个数据库，</code>也可以通过select命令选择哪个数据库。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/iIOsUeR2ZzGycSq.png"></p>
<h2 id="move"><a href="#move" class="headerlink" title="move"></a>move</h2><p>将key移到其他数据库；<code>move key 15</code> : 将当前数据库中的key移到15号数据库中</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/CEo16vHaZWelDBG.png"></p>
<h2 id="info"><a href="#info" class="headerlink" title="info"></a>info</h2><p>获取 redis 服务器的统计信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info</span><br><span class="line"><span class="comment"># Server</span></span><br><span class="line">redis_version:3.2.100</span><br><span class="line">redis_git_sha1:00000000</span><br><span class="line">redis_git_dirty:0</span><br><span class="line">redis_build_id:1fe181ad2447fe38</span><br><span class="line">redis_mode:standalone</span><br><span class="line">os:Windows</span><br><span class="line">arch_bits:64</span><br><span class="line">multiplexing_api:winsock_IOCP</span><br><span class="line">gcc_version:0.0.0</span><br><span class="line">process_id:13028</span><br><span class="line">run_id:180f539248b89f5359be251550b4b28d0171805f</span><br><span class="line">tcp_port:6379</span><br><span class="line">uptime_in_seconds:1795</span><br><span class="line">uptime_in_days:0</span><br><span class="line">hz:10</span><br><span class="line">lru_clock:4401579</span><br><span class="line">config_file:</span><br><span class="line"></span><br><span class="line"><span class="comment"># Clients</span></span><br><span class="line">connected_clients:1</span><br><span class="line">client_longest_output_list:0</span><br><span class="line">client_biggest_input_buf:0</span><br><span class="line">blocked_clients:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Memory</span></span><br><span class="line">used_memory:4360680</span><br><span class="line">used_memory_human:4.16M</span><br><span class="line">used_memory_rss:4327104</span><br><span class="line">used_memory_peak:4360680</span><br><span class="line">used_memory_peak_human:4.16M</span><br><span class="line">used_memory_lua:33792</span><br><span class="line">mem_fragmentation_ratio:0.99</span><br><span class="line">mem_allocator:dlmalloc-2.8</span><br><span class="line"></span><br><span class="line"><span class="comment"># Persistence</span></span><br><span class="line">loading:0</span><br><span class="line">rdb_changes_since_last_save:0</span><br><span class="line">rdb_bgsave_in_progress:0</span><br><span class="line">rdb_last_save_time:1598235304</span><br><span class="line">rdb_last_bgsave_status:ok</span><br><span class="line">rdb_last_bgsave_time_sec:-1</span><br><span class="line">rdb_current_bgsave_time_sec:-1</span><br><span class="line">aof_enabled:0</span><br><span class="line">aof_rewrite_in_progress:0</span><br><span class="line">aof_rewrite_scheduled:0</span><br><span class="line">aof_last_rewrite_time_sec:-1</span><br><span class="line">aof_current_rewrite_time_sec:-1</span><br><span class="line">aof_last_bgrewrite_status:ok</span><br><span class="line">aof_last_write_status:ok</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stats</span></span><br><span class="line">total_connections_received:4</span><br><span class="line">total_commands_processed:5</span><br><span class="line">instantaneous_ops_per_sec:0</span><br><span class="line">rejected_connections:0</span><br><span class="line">sync_full:0</span><br><span class="line">sync_partial_ok:0</span><br><span class="line">sync_partial_err:0</span><br><span class="line">expired_keys:0</span><br><span class="line">evicted_keys:0</span><br><span class="line">keyspace_hits:0</span><br><span class="line">keyspace_misses:0</span><br><span class="line">pubsub_channels:0</span><br><span class="line">pubsub_patterns:0</span><br><span class="line">latest_fork_usec:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># Replication</span></span><br><span class="line">role:master</span><br><span class="line">connected_slaves:0</span><br><span class="line">master_repl_offset:0</span><br><span class="line">repl_backlog_active:0</span><br><span class="line">repl_backlog_size:1048576</span><br><span class="line">repl_backlog_first_byte_offset:0</span><br><span class="line">repl_backlog_histlen:0</span><br><span class="line"></span><br><span class="line"><span class="comment"># CPU</span></span><br><span class="line">used_cpu_sys:0.05</span><br><span class="line">used_cpu_user:0.03</span><br><span class="line">used_cpu_sys_children:0.00</span><br><span class="line">used_cpu_user_children:0.00</span><br><span class="line"></span><br><span class="line"><span class="comment"># Keyspace</span></span><br><span class="line">db0:keys=1,expires=1,avg_ttl=425280</span><br></pre></td></tr></table></figure>


<h2 id="Help"><a href="#Help" class="headerlink" title="Help"></a>Help</h2><p>HELP命令可以查看redis的一些命令的用法；当忘记某个命令的使用时很有用。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/OZ4El3MFpV1eRKk.png"></p>
<h1 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h1><h2 id="Redis的5种基本类型"><a href="#Redis的5种基本类型" class="headerlink" title="Redis的5种基本类型"></a>Redis的5种基本类型</h2><p>redis是一种高级的<code>key-value的存储系统</code>，其中value支持<code>五种数据类型</code>：</p>
<blockquote>
<ol>
<li>字符串（String）</li>
<li>哈希（hash）</li>
<li>字符串列表（list）</li>
<li>字符串集合（set）</li>
<li>有序字符串集合（sorted ZSet）</li>
</ol>
</blockquote>
<p>在日常开发中主要使用比较多的有<code>字符串、哈希、字符串列表、字符串集合</code>四种类型，其中最为常用的是字符串类型。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/G4eqAvjyRBLa8Wx.png"></p>
<p>关于key的定义，注意如下几点：</p>
<blockquote>
<ol>
<li>key不要太长，最好不要超过1024个字节，这不仅会消耗内存还会降低查找效率</li>
<li>key不要太短，如果太短会降低key的可读性 </li>
<li>在项目中，key最好有一个统一的命名规范（见名知意）</li>
</ol>
</blockquote>
<h3 id="String-字符串"><a href="#String-字符串" class="headerlink" title="String(字符串)"></a>String(字符串)</h3><h4 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h4><p>字符串类型是Redis中最为基础的数据存储类型，它在Redis中是二进制安全的，这便意味着字符串类型存入和获取的数据相同。在Redis中<code>字符串类型的Value最多可以容纳的数据长度是512M</code>。</p>
<h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>set key value</li>
</ul>
<p><code>设定key的value</code>。指定字符串的value，如果该<code>key存在则进行覆盖操作</code>。总是返回”OK”</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> company <span class="string">&quot;itcast&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>get key</li>
</ul>
<p><code>获取key的value</code>。如果与该key关联的<code>value不是String类型，redis将返回错误信息</code>，因为get命令只能用于获取String value；如果该key不存在，返回(nil)。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; <span class="built_in">set</span> name <span class="string">&quot;itcast&quot;</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line"><span class="string">&quot;itcast&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>del key</li>
</ul>
<p><code>删除指定key</code>，返回影响的记录数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; del name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; get name</span><br><span class="line">(nil)</span><br></pre></td></tr></table></figure>

<h3 id="Hash-哈希类型"><a href="#Hash-哈希类型" class="headerlink" title="Hash(哈希类型)"></a>Hash(哈希类型)</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>Redis中的<code>Hash类型可看成具有String Key和String Value的map容器</code>。所以Hash类型非常适合于存储键值对的信息。如Username、Password和Age等。如果Hash中包含很少的字段，那么该类型的数据也将仅占用很少的内存空间。<code>每一个Hash可以存储4294967295个键值对。</code></p>
<h4 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>hset key field value</li>
</ul>
<p>为指定的key<code>设定</code>field&#x2F;value对（键值对）。返回影响的记录数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username haohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>hget key field</li>
</ul>
<p><code>获取</code>指定的key中的field的值</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset myhash username haohao</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line"><span class="string">&quot;haohao&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hmset key field value [field1 value1 field2 value2…]</li>
</ul>
<p><code>设置</code>key中的<code>多个filed/value</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmset myhash username jack age 21</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<ul>
<li>hmget key fileds</li>
</ul>
<p><code>获取</code>key中的<code>多个filed的值</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hmget myhash username age </span><br><span class="line">1)”jack”</span><br><span class="line">2)”18”</span><br></pre></td></tr></table></figure>

<ul>
<li>hgetall key</li>
</ul>
<p><code>获取</code>key中所有<code>map的key和value</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hset h_user <span class="built_in">id</span> 1</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hmset h_user age 12 name itcast gender 1</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; hgetall h_user</span><br><span class="line">1) <span class="string">&quot;id&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;age&quot;</span></span><br><span class="line">4) <span class="string">&quot;12&quot;</span></span><br><span class="line">5) <span class="string">&quot;name&quot;</span></span><br><span class="line">6) <span class="string">&quot;itcast&quot;</span></span><br><span class="line">7) <span class="string">&quot;gender&quot;</span></span><br><span class="line">8) <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>hdel key field [field … ]</li>
</ul>
<p>可以<code>删除一个或多个字段</code>，返回值是被删除的字段个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hdel myhash username age</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; hget myhash username</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>HEXISTS key field</li>
</ul>
<p>查看哈希表 key 中，<code>判断域field 是否存在</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hexists myhash name</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; hexists myhash birthday</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<ul>
<li>HKEYS key和HVALS key</li>
</ul>
<p><code>HKEYS key</code>：<code>获取</code>哈希表Key的<code>所有域field</code>；<code>HVALS key</code>：<code>获取</code>哈希表key的<code>所有域field对应的值</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hkeys h_user</span><br><span class="line">1) <span class="string">&quot;id&quot;</span></span><br><span class="line">2) <span class="string">&quot;name&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; hvals h_user</span><br><span class="line">1) <span class="string">&quot;1&quot;</span></span><br><span class="line">2) <span class="string">&quot;itcast&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>HLEN key</li>
</ul>
<p>返回哈希表 key 中域<code>field的数量</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hlen h_user</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br></pre></td></tr></table></figure>


<h3 id="List-列表类型"><a href="#List-列表类型" class="headerlink" title="List(列表类型)"></a>List(列表类型)</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/qEirlLuhsSjv1cQ.png"></p>
<p>在Redis中，<code>List类型是按照插入顺序排序的字符串链表（java中的linkedlist）</code>。和数据结构中的普通链表一样，可以在其头部(left)和尾部(right)添加新的元素。在插入时，如果该键并不存在，Redis将为该键创建一个新的链表。与此相反，如果链表中所有的元素均被移除，那么该键也将会被从数据库中删除。<code>List中可以包含的最大元素数量是4294967295，list类型允许有重复元素</code></p>
<h4 id="常用命令-2"><a href="#常用命令-2" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>lpush key value1 value2 …</li>
</ul>
<p>如果该key不存在，该命令在插入的之前创建一个与该key关联的空链表，之后再向该链表的<code>头部插入数据</code>。插入成功，返回元素的个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>注意：是左边添加，所以最终最左边的元素为c</code></p>
</blockquote>
<ul>
<li>rpush key value1 value2 …</li>
</ul>
<p>如果该key不存在，该命令在插入之前创建一个与该key对应的空链表，再<code>从尾部插入数据</code>。插入成功，返回元素的个数。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; rpush l_users d e</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>注意：是右边添加，所以最终最右边的元素为e</code></p>
</blockquote>
<ul>
<li>lrange key start end</li>
</ul>
<p><code>获取</code>链表中从start到end的元素的值，<code>索引从0开始，如果为负数，-1表示倒数第一个元素，-2表示倒数第二个元素，以此类推。</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange l_users 0 -1</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">6) <span class="string">&quot;d&quot;</span></span><br><span class="line">7) <span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>lpop key，<code>从头部移除元素</code></li>
</ul>
<p>返回并弹出指定的key关联的链表中的第一个元素，即头部元素。如果该key不存在，返回nil；若key存在，则返回链表的头部元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; lpop mylist</span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>rpop key，<code>从尾部移除元素</code></li>
</ul>
<p>返回并弹出指定的key关联的链表中的最后一个元素，即尾部元素。如果该key不存在，返回nil；若key存在，则返回链表的尾部元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; rpop mylist</span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LLEN key</li>
</ul>
<p><code>返回</code>指定key对应链表中<code>元素的个数</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrange l_users 0 -1</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;3&quot;</span></span><br><span class="line">4) <span class="string">&quot;2&quot;</span></span><br><span class="line">5) <span class="string">&quot;1&quot;</span></span><br><span class="line">6) <span class="string">&quot;d&quot;</span></span><br><span class="line">7) <span class="string">&quot;e&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; llen l_users</span><br><span class="line">(<span class="built_in">integer</span>) 7</span><br></pre></td></tr></table></figure>

<ul>
<li>LREM key count value</li>
</ul>
<p>LREM命令会<code>删除列表中前count个值为value的元素，返回实际删除的元素个数</code>。根据count值的不同，该命令的执行方式会有所不同：</p>
<blockquote>
<ol>
<li>当<code>count&gt;0</code>时， LREM会从列表<code>左边(头部)开始删除</code>。</li>
<li>当<code>count&lt;0</code>时， LREM会从列表<code>后边(尾部)开始删除</code>。</li>
<li>当<code>count=0</code>时， LREM<code>删除所有值为value的元素</code>。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush l_users 1 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 10</span><br><span class="line">127.0.0.1:6379&gt; lrange l_users 0 -1</span><br><span class="line"> 1) <span class="string">&quot;3&quot;</span></span><br><span class="line"> 2) <span class="string">&quot;2&quot;</span></span><br><span class="line"> 3) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 4) <span class="string">&quot;b&quot;</span></span><br><span class="line"> 5) <span class="string">&quot;a&quot;</span></span><br><span class="line"> 6) <span class="string">&quot;3&quot;</span></span><br><span class="line"> 7) <span class="string">&quot;2&quot;</span></span><br><span class="line"> 8) <span class="string">&quot;1&quot;</span></span><br><span class="line"> 9) <span class="string">&quot;d&quot;</span></span><br><span class="line">10) <span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<p>删除列表l_users中2个值为3的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lrem l_users 2 3</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; lrange l_users 0 -1</span><br><span class="line">1) <span class="string">&quot;2&quot;</span></span><br><span class="line">2) <span class="string">&quot;1&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;a&quot;</span></span><br><span class="line">5) <span class="string">&quot;2&quot;</span></span><br><span class="line">6) <span class="string">&quot;1&quot;</span></span><br><span class="line">7) <span class="string">&quot;d&quot;</span></span><br><span class="line">8) <span class="string">&quot;e&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>LINDEX key index</li>
</ul>
<p>获得<code>指定索引的元素值</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lindex l_users 3</span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Set-无序集合"><a href="#Set-无序集合" class="headerlink" title="Set(无序集合)"></a>Set(无序集合)</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p>在Redis中，将<code>Set类型看作为没有排序的字符集合</code>，和List类型一样，也可以在该类型的数据值上执行添加、删除或判断某一元素是否存在等操作。<code>set集合类型可包含的最大元素数量是4294967295，</code>和List类型不同的是，set集合类型中<code>不允许出现重复的元素，且无序</code>。</p>
<h4 id="常用命令-3"><a href="#常用命令-3" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li>sadd key values[value1 value2 …]</li>
</ul>
<p>向set中无序<code>添加一个或多个数据</code>，如果该key的值<code>已存在则不会重复添加</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset a b c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<ul>
<li>smembers key</li>
</ul>
<p><code>获取</code>set中所有的成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">2) <span class="string">&quot;a&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>srem key members[member1、member2…]</li>
</ul>
<p><code>删除</code>set中指定的成员</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; srem myset a b</span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; smembers myset</span><br><span class="line">1) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>SISMEMBER key member</li>
</ul>
<p><code>判断</code>元素是否存在集合中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sismember myset c</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<ul>
<li>SCARD key</li>
</ul>
<p><code>获得</code>集合中元素的个数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scard myset</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="Sorted-ZSet-有序集合"><a href="#Sorted-ZSet-有序集合" class="headerlink" title="Sorted ZSet(有序集合)"></a>Sorted ZSet(有序集合)</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>在集合类型的基础上<code>有序集合类型（sorted ZSet）为集合中的每个元素都关联一个分数</code>，这使得我们不仅可以完成插入、删除和判断元素是否存在在集合中，还能够获得分数最高或最低的前N个元素、获取指定分数范围内的元素等与分数有关的操作。</p>
<h4 id="有序集合和列表类型区别"><a href="#有序集合和列表类型区别" class="headerlink" title="有序集合和列表类型区别"></a>有序集合和列表类型区别</h4><ul>
<li>相同点：</li>
</ul>
<blockquote>
<ol>
<li>二者都是有序的。</li>
<li>二者都可以获得某一范围的元素。</li>
</ol>
</blockquote>
<ul>
<li>不同点：</li>
</ul>
<blockquote>
<ol>
<li><code>列表类型</code>是通过<code>链表</code>实现的，获取靠近两端的数据速度极快，而当元素增多后，<code>访问中间数据的速度会变慢</code>。</li>
<li><code>有序集合类型</code>使用<code>散列表</code>实现，所以即使<code>读取位于中间部分的数据也很快</code>。</li>
<li>列表中不能简单的<code>调整某个元素的位置</code>，但是有序集合可以（通过更改分数实现）</li>
<li>有序集合要比列表类型<code>更耗内存</code>。</li>
</ol>
</blockquote>
<h4 id="常用命令-4"><a href="#常用命令-4" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li><code>增加元素</code>：ZADD key score member [score member …]</li>
</ul>
<p>向有序集合中加入一个元素和该元素的分数，<code>如果该元素已经存在则会用新的分数替换原有的分数</code>。返回值是新加入到集合中的元素个数，不包含之前已经存在的元素。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zadd z_users 10 a 20 b 30 c</span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br></pre></td></tr></table></figure>

<ul>
<li><code>获取指定区间元素</code>：ZRANGE key start stop [WITHSCORES]</li>
</ul>
<p>返回有序集合key 中，指定区间内的成员。其中<code>成员的位置按 score 值递增 (从小到大) 来排序</code>。start开始位置，stop结束位置（<code>-1则为最后一个元素</code>）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zrange z_users 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br><span class="line">3) <span class="string">&quot;c&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange z_users 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;10&quot;</span></span><br><span class="line">3) <span class="string">&quot;b&quot;</span></span><br><span class="line">4) <span class="string">&quot;20&quot;</span></span><br><span class="line">5) <span class="string">&quot;c&quot;</span></span><br><span class="line">6) <span class="string">&quot;30&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照<code>排名</code>范围<code>删除</code>元素：ZREMRANGEBYRANK key start stop</li>
</ul>
<p>删除排名（按分数排）范围在第3的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zremrangebyrank z_users 2 2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange z_users 0 -1</span><br><span class="line">1) <span class="string">&quot;a&quot;</span></span><br><span class="line">2) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>按照<code>分数</code>范围删除元素：ZREMRANGEBYSCORE key min max</li>
</ul>
<p>删除分数范围为5-10（包括端点值5和10）的元素</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; zremrangebyscore z_users 5 10</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; zrange z_users 0 -1</span><br><span class="line">1) <span class="string">&quot;b&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/14/3IR7NLMixqGwPeA.png"></p>
<h2 id="Redis新的3种数据类型"><a href="#Redis新的3种数据类型" class="headerlink" title="Redis新的3种数据类型"></a>Redis新的3种数据类型</h2><h3 id="Bitmaps-位操作字符串"><a href="#Bitmaps-位操作字符串" class="headerlink" title="Bitmaps(位操作字符串)"></a>Bitmaps(位操作字符串)</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>现代计算机使用二进制（位）作为信息的基本单位，<code>1个字节等于8位</code>，例如“abc”字符串是有3个字节组成，但实际在计算机内存储时将其使用二进制表示，“abc”分别对应的ASCII码是：97、98、99，对应的二进制分别是01100001、01100010、01100011，如下图</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/28/JXrdwD42SZFVENa.png"></p>
<p><code>合理地使用位操作能够有效地提高内存使用率和开发效率</code></p>
<blockquote>
<ul>
<li>Redis提供了Bitmaps这个“数据类型”可以实现对位的操作：</li>
</ul>
<ol>
<li><code>Bitmaps本身不是一种数据类型，实际上它就是字符串（key-value）</code>，但是它可以对字符串的位进行操作，<code>字符串中每个字符对应1个字节，也就是8位，一个字符可以存储8个bit位信息</code>。</li>
<li>Bitmaps单独提供了一套命令， 所以在Redis中使用Bitmaps和使用字符串的方法不太相同。 可以把<code>Bitmaps想象成一个以位为单位的数组</code>， 数组的每个单元<code>只能存储0和1</code>， 数组的<code>下标</code>在Bitmaps中叫做<code>偏移量</code>。</li>
</ol>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/28/YdomfHlS9vCyEP1.png"></p>
<h4 id="常用命令-5"><a href="#常用命令-5" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li><code>setbit</code>：<code>设置</code>某个偏移量的值（0或1）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SETBIT key offset value</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>设置offset偏移位的值为value，o<code>ffset的值是从0开始的，n代表第n+1个bit位置的</code>。</li>
<li><code>offset 参数必须大于或等于 0</code> ，<code>小于 2^32 </code>(bit 映射被<code>限制在 512 MB 之内</code>)。</li>
<li>value的值只能为0或1</li>
<li>返回值：指定<code>偏移量原来储存的位</code>。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; SETBIT bit 10086 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GETBIT bit 10086</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GETBIT bit 100   <span class="comment"># bit 默认被初始化为 0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<p>如：每个独立用户是否访问过网站存放在bitmaps中，将访问的用户记做1，没有访问的用户记做0，用户id作为offset。现在有20个用户，userid&#x3D;1,6,11,15,19的用户对网站进行了访问，那么当前bitmaps初始化结果如图</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/28/VdEevL3R8o4Bm56.png"></p>
<p><code>users:20220409</code>这个bitmaps中表示2022-04-09这天独立访问的用户，如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 6 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 11 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 15 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span>:20220409 19 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>getbit</code>：<code>获取</code>某个偏移位的值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GETBIT key offset</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>获取</code>key所对应的bitmaps中<code>offset偏移位的值</code>。</li>
<li>返回值：0或者1</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment">#清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setbit <span class="built_in">users</span> 1001 1 <span class="comment">#设置偏移量1001的bit位的值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; getbit <span class="built_in">users</span> 1001 <span class="comment">#获取偏移位1001的bit位的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; getbit <span class="built_in">users</span> 1000 <span class="comment">#获取偏移位1000的bit位的值，未设置，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bitcount</code>：<code>统计</code>bit位都为1的数量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BITCOUNT key [start] [end]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计字符串被设置为1的bit数，一般情况下，给定的整个字符串都会被进行统计，通过指定额外的start或者end参数，可以让计数只在特定的位上进行，<code>start 和 end 参数，都可以使用负数值</code>(比如 -1 表示最后一个位，而 -2 表示倒数第二个位，以此类推)。<br><code>注：start、end是指bit组的字节的下标数，一个直接对应8个bit，所以[a,b]对应的offset范围是[8a,8b+7]</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment"># 清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; setbit user 7 1 <span class="comment"># 设置user这个bitmaps中偏移量为7的bit为值为1，也就是第8个bit位的值</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit user 15 1 <span class="comment"># 设置user这个bitmaps中偏移量为15的bit为值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; setbit user 23 1 <span class="comment"># 设置user这个bitmaps中偏移量为23的bit为值为1</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; bitcount user <span class="comment"># 获取user这个bitmaps中1的数量</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; bitcount user 0 1 <span class="comment"># 获取[0,1]这个字节内bit位上1的数量，也就是offset是[0,15]的位置上1的数量，所以是2个</span></span><br><span class="line">(<span class="built_in">integer</span>) 2</span><br><span class="line">127.0.0.1:6379&gt; bitcount user 0 0 <span class="comment"># 获取[0,0]这个字节内bit位上1的数量，也就是offset是[0,7]的位置上1的数量，只有7这个位置，所以是1个</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>bittop</code>：对<code>一个多个bitmaps</code>执行位操作</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">BITOP operation destkey key [key ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>对一个或多个保存二进制位的字符串 key 进行位元操作，并<code>将结果保存到 destkey 上</code>。</li>
<li><code>operation</code> 可以是 <code>AND 、 OR 、 NOT 、 XOR</code> 这四种操作中的任意一种：</li>
</ul>
<ol>
<li><code>BITOP AND destkey key [key ...] </code>，对一个或多个 key 求逻辑<code>并</code>，并将结果保存到 destkey 。</li>
<li><code>BITOP OR destkey key [key ...] </code>，对一个或多个 key 求逻辑<code>或</code>，并将结果保存到 destkey 。</li>
<li><code>BITOP XOR destkey key [key ...] </code>，对一个或多个 key 求逻辑<code>异或</code>，并将结果保存到 destkey 。</li>
<li><code>BITOP NOT destkey key </code>，对给定 key 求<code>逻辑非</code>，并将结果保存到 destkey 。</li>
</ol>
<ul>
<li>除了 NOT 操作之外，其他操作都可以接受一个或多个 key 作为输入。</li>
<li>返回值：保存到 destkey 的字符串的<code>长度，和输入 key 中最长的字符串长度相等</code>。</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis&gt; SETBIT bits-1 0 1        <span class="comment"># bits-1 = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SETBIT bits-1 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SETBIT bits-2 0 1        <span class="comment"># bits-2 = 1011</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SETBIT bits-2 1 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; SETBIT bits-2 3 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; BITOP AND and-result bits-1 bits-2</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GETBIT and-result 0      <span class="comment"># and-result = 1001</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">redis&gt; GETBIT and-result 1</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GETBIT and-result 2</span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">redis&gt; GETBIT and-result 3</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h4 id="bitmaps与set比较"><a href="#bitmaps与set比较" class="headerlink" title="bitmaps与set比较"></a>bitmaps与set比较</h4><p>假设网站有 1 亿用户， 每天独立访问的用户有 5 千万， 如果每天用集合类型和 Bitmaps 分别存储活跃用户可以得到表：</p>
<ul>
<li>set 和 Bitmaps 存储<code>一天活跃用户对比</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">每个用户 id 占用空间</th>
<th align="center">需要存储的用户量</th>
<th align="center">全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set集合</td>
<td align="center">64 位</td>
<td align="center">50000000</td>
<td align="center">64 位 * 50000000 &#x3D; 400MB (<code>64 ÷ 8 * 50000000 ÷ 1000000 = 400MB</code>)</td>
</tr>
<tr>
<td align="center">Bitmaps</td>
<td align="center">1位</td>
<td align="center">100000000</td>
<td align="center">1 位 * 100000000 &#x3D; 12.5MB (<code>1 ÷ 8 * 100000000 ÷ 1000000 = 12.5MB</code>)</td>
</tr>
</tbody></table>
<blockquote>
<p><code>1 byte(字节) = 8 bit(位)、1 MB(兆字节) = 1000000 B(字节)</code></p>
</blockquote>
<p>很明显， 这种情况下使用 <code>Bitmaps 能节省很多的内存空间</code>， 尤其是<code>随着时间推移节省的内存还是非常可观的</code>。</p>
<ul>
<li>set 和 Bitmaps 存储<code>独立用户空间对比</code></li>
</ul>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">一天</th>
<th align="center">一月</th>
<th align="center">一年</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set集合</td>
<td align="center">400MB</td>
<td align="center">12GB</td>
<td align="center">144GB</td>
</tr>
<tr>
<td align="center">Bitmaps</td>
<td align="center">12.5MB</td>
<td align="center">375MB</td>
<td align="center">4.5GB</td>
</tr>
</tbody></table>
<p>假如该网站每天的独立访问用户很少，例如只有 10 万（大量的僵尸用户）， 那么两者的对比如下表所示，很显然， 这时候使用Bitmaps就不太合适了，因为基本上<code>大部分位</code>都是<code> 0</code>。</p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">每个 userid 占用空间</th>
<th align="center">需要存储的用户量</th>
<th align="center">全部内存量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">set集合</td>
<td align="center">64 位</td>
<td align="center">100000</td>
<td align="center">64 位 * 100000 &#x3D; 800KB</td>
</tr>
<tr>
<td align="center">Bitmaps</td>
<td align="center">1 位</td>
<td align="center">100000000</td>
<td align="center">1 位 * 100000000 &#x3D; 12.5MB</td>
</tr>
</tbody></table>
<h3 id="HyperLoglog-基数统计"><a href="#HyperLoglog-基数统计" class="headerlink" title="HyperLoglog(基数统计)"></a>HyperLoglog(基数统计)</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p>在工作当中，经常会遇到与统计相关的功能需求，比如统计<code>网站 PV（PageView 页面访问量）</code>，可以使用 Redis 的 incr、incrby 轻松实现。但像 <code>UV（UniqueVisitor 独立访客）</code>、<code>独立 IP 数</code>、<code>搜索记录数</code>等需要<code>去重和计数</code>的问题如何解决？这种求集合中不重复元素个数的问题称为<code>基数问题</code>。</p>
<blockquote>
<ul>
<li>解决基数问题有很多种方案：</li>
</ul>
<ol>
<li>数据存储在 MySQL 表中，使用 distinct count 计算不重复个数。</li>
<li>使用 Redis 提供的 hash、set、bitmaps 等数据结构来处理。</li>
</ol>
</blockquote>
<p>以上的方案结果精确，但随着数据不断增加，导致占用空间越来越大，对于<code>非常大的数据集是不切实际的</code>。能否能够<code>降低一定的精度来平衡存储空间</code>？Redis 推出了 <code>HyperLogLog</code>。</p>
<blockquote>
<p>Redis <code>HyperLogLog 是用来做基数统计的算法</code>，HyperLogLog 的<code>优点</code>是：在输入元素的数量或者体积非常非常大时，<code>计算基数所需的空间总是固定的</code>、并且是很小的。</p>
</blockquote>
<p>在 Redis 里面，<code>每个 HyperLogLog 键只需要花费 12 KB 内存</code>，<code>就可以计算接近 2^64 个不同元素的基数</code>。这和计算基数时，元素越多耗费内存就越多的集合形成鲜明对比。</p>
<p>但是，因为 <code>HyperLogLog 只会根据输入元素来计算基数</code>，而<code>不会储存输入元素本身</code>，所以 HyperLogLog 不能像集合那样，返回输入的各个元素。</p>
<blockquote>
<p>什么是基数？<br>比如数据集 <code>&#123;1, 3, 5, 7, 5, 7, 8&#125;</code>，那么这个数据集的基数集为 <code>&#123;1, 3, 5 ,7, 8&#125;</code>，<code>基数 (不重复元素)</code> 为 5。 基数估计就是在误差可接受的范围内，快速计算基数。</p>
</blockquote>
<h4 id="常用命令-6"><a href="#常用命令-6" class="headerlink" title="常用命令"></a>常用命令</h4><ul>
<li><code>pfadd</code>：<code>添加</code>多个元素</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfadd key element [element ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>向HyperLoglog类型的key中添加一个或者多个元素。</li>
<li>添加一个或者多个元素到key对应的集合中。</li>
<li>返回值：1：添加成功、0：添加失败</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment"># 清空db方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java php c c++ <span class="comment"># program中添加4个元素[java,php,c,c++]，添加成功发，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java <span class="comment"># 再次添加java，由于已经存在，所以添加失败，返回0</span></span><br><span class="line">(<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; pfadd program java js <span class="comment"># 再次添加2个元素，java已经存在了，但是js不存在，添加成功，返回1</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pfcount</code>：<code>获取</code>多个HLL合并后元素的个数</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfcount key1 key2 ...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>统计一个或者多个key去重后元素的数量。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment"># 清空db方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv1 a b c d e <span class="comment">#uv1中5个元素：[a,b,c,d,e]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1 <span class="comment">#uv1中数量为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv2 b c d e f <span class="comment">#uv2中5个元素：[b,c,d,e,f]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv2 <span class="comment">#uv2中数量为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1 uv2 <span class="comment"># 获取uv1和uv2去重之后数量合集：[a,b,c,d,e,f]，数量为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br></pre></td></tr></table></figure>

<ul>
<li><code>pfmerge</code>：将多个HLL<code>合并</code>后元素放入另外一个HLL</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pfmerge destkey sourcekey [sourcekey ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将多个<code>sourcekey合并</code>后放<code>到destkey</code>中。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment"># 清空db方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv1 a b c d e <span class="comment">#uv1中5个元素：[a,b,c,d,e]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv1 <span class="comment">#uv1中数量为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfadd uv2 b c d e f <span class="comment">#uv2中5个元素：[b,c,d,e,f]</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv2 <span class="comment">#uv2中数量为5</span></span><br><span class="line">(<span class="built_in">integer</span>) 5</span><br><span class="line">127.0.0.1:6379&gt; pfmerge uv_dest uv1 uv2 <span class="comment">#将uv1和uv2合并后放入uv_dest</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; pfcount uv_dest <span class="comment">#uv_dest元素个数为6</span></span><br><span class="line">(<span class="built_in">integer</span>) 6</span><br></pre></td></tr></table></figure>

<h3 id="Geographic-地理信息"><a href="#Geographic-地理信息" class="headerlink" title="Geographic(地理信息)"></a>Geographic(地理信息)</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><code>Reids3.2 中增加了对GEO类型的支持</code>，GEO（Geographic）<code>地理信息</code>的缩写。该类型就是元素的<code>二维坐标</code>(<code>经纬度</code>)，redis基于该类型提供了<code>经纬度设置、查询、范围查询、距离查询，经纬度Hash</code>等常见操作。</p>
<h4 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h4><ul>
<li><code>geoadd</code>：<code>添加多个</code>位置的<code>经纬度</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geoadd key longitude latitude member [longitude latitude member ...]</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>longitude</code> 经度<br><code>latitude</code> 纬度<br><code>member</code> 名称</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment">#清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai <span class="comment">#添加上海的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing <span class="comment">#添加重庆、深圳、北京 3 个城市的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; <span class="built_in">type</span> china:city <span class="comment">#发现geo实际上使用zset类型存储的</span></span><br><span class="line">zset</span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">3) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">4) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">127.0.0.1:6379&gt; zrange china:city 0 -1 withscores</span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;4026042091628984&quot;</span></span><br><span class="line">3) <span class="string">&quot;shenzhen&quot;</span></span><br><span class="line">4) <span class="string">&quot;4046432193584628&quot;</span></span><br><span class="line">5) <span class="string">&quot;shanghai&quot;</span></span><br><span class="line">6) <span class="string">&quot;4054803462927619&quot;</span></span><br><span class="line">7) <span class="string">&quot;beijing&quot;</span></span><br><span class="line">8) <span class="string">&quot;4069885332386336&quot;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li><code>两级无法直接添加</code>，一般会下载城市数据，直接通过java程序一次性导入</li>
<li>有效的<code>经纬度从-180度到180度</code>，有效的<code>维度从-85.05112878度到85.05112878度</code>。</li>
<li>当坐标位置<code>超出指定范围</code>时，该命令将会<code>返回一个错误</code>。</li>
<li><code>已经添加的数据</code>，是<code>无法再</code>次往里面<code>添加</code>的。</li>
</ol>
</blockquote>
<ul>
<li><code>geopos</code>：<code>获取多个</code>位置的<code>坐标值</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geopos key member [member ...]</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment">#清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai <span class="comment">#添加上海的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing <span class="comment">#添加重庆、深圳、北京 3 个城市的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geopos china:city wuhan beijing chongqing <span class="comment">#获取武汉、北京、重庆 3个城市的坐标，由于没有添加武汉的数据，所以没有获取到，其他2个获取到了</span></span><br><span class="line">1) (nil)</span><br><span class="line">2) 1) <span class="string">&quot;116.38000041246414185&quot;</span></span><br><span class="line">   2) <span class="string">&quot;39.90000009167092543&quot;</span></span><br><span class="line">3) 1) <span class="string">&quot;106.49999767541885376&quot;</span></span><br><span class="line">   2) <span class="string">&quot;29.52999957900659211&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>geodist</code>：<code>获取</code>两个位置的<code>直线距离</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">geodist key member1 member2 [m|km|ft|mi]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单位：[m|km|ft|mi] -&gt;&gt; [米|千米|英里|英尺]，<code>默认为米</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment">#清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai <span class="comment">#添加上海的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing <span class="comment">#添加重庆、深圳、北京 3 个城市的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; geodist china:city beijing chongqing km <span class="comment">#获取北京到重庆的直线距离</span></span><br><span class="line"><span class="string">&quot;1462.9505&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>georadius</code>：<code>以给定的经纬度为中心</code>，找出某一<code>半径内的元素</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">georadius key longitude latitude radius m|km|ft|mi</span><br></pre></td></tr></table></figure>

<blockquote>
<p>单位：[m|km|ft|mi] -&gt;&gt; [米|千米|英里|英尺]，<code>默认为米</code></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; flushdb <span class="comment">#清空db，方便测试</span></span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 121.47 31.23 shanghai <span class="comment">#添加上海的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br><span class="line">127.0.0.1:6379&gt; geoadd china:city 106.50 29.53 chongqing 114.05 22.52 shenzhen 116.38 39.90 beijing <span class="comment">#添加重庆、深圳、北京 3 个城市的经纬度</span></span><br><span class="line">(<span class="built_in">integer</span>) 3</span><br><span class="line">127.0.0.1:6379&gt; georadius china:city 110 30 1000 km <span class="comment">#在china:city中检索：以经纬度(110,30)为中心，半径为1000km内的位置列表</span></span><br><span class="line">1) <span class="string">&quot;chongqing&quot;</span></span><br><span class="line">2) <span class="string">&quot;shenzhen&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h1><h2 id="持久化概述"><a href="#持久化概述" class="headerlink" title="持久化概述"></a>持久化概述</h2><p>Redis的高性能是由于其将所有数据都存储在了内存中，为了使Redis在重启之后仍能保证数据不丢失，需要将数据从内存中同步到硬盘中，这一过程就是持久化。<code>Redis支持两种方式的持久化，一种是RDB方式，一种是AOF方式。可以单独使用其中一种或将二者结合使用。</code></p>
<blockquote>
<ul>
<li><code>RDB持久化（默认支持，无需配置）</code><br>该机制是在指定的<code>时间间隔内将内存中的数据集快照写入磁盘</code>。</li>
<li><code>AOF持久化</code><br>该机制将以日志的形式<code>记录服务器所处理的每一个写操作</code>，在Redis服务器<code>启动之初会读取该文件来重新构建数据库</code>，以保证启动后数据库中的数据是完整的。</li>
<li><code>无持久化</code><br>可以通过配置的方式禁用Redis服务器的持久化功能，这样可以将Redis视为一个功能加强版的memcached了。</li>
<li>Redis可以<code>同时使用RDB和AOF</code></li>
</ul>
</blockquote>
<h2 id="RDB持久化机制"><a href="#RDB持久化机制" class="headerlink" title="RDB持久化机制"></a>RDB持久化机制</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ol>
<li>一旦采用该方式，那么整个Redis数据库将<code>只包含一个rdb文件</code>，这对于文件备份而言是非常完美的。比如，可能打算每个小时归档一次最近24小时的数据，同时还要每天归档一次最近30天的数据。通过这样的备份策略，一旦系统出现灾难性故障，可以非常容易的进行恢复。</li>
<li>对于灾难恢复而言，RDB是非常不错的选择。因为可以非常轻松的将一个单独的文件压缩后再转移到其它存储介质上</li>
<li><code>性能最大化</code>。对于Redis的服务进程而言，在开始持久化时，它唯一需要做的只是fork（分叉）出子进程，之后再由子进程完成这些持久化的工作，这样就可以极大的避免服务进程执行IO操作了。<code>相比于AOF机制，如果数据集很大，RDB的启动效率会更高</code></li>
</ol>
</blockquote>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ol>
<li>如果想保证数据的高可用性（就是内存数据不丢失），即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统<code>一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失</code>。</li>
<li>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果<code>当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟</code></li>
</ol>
</blockquote>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>在redis.windows.conf配置文件中有如下配置：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/WQp4DUeunvTHNwX.png"></p>
<p>其中，上面配置的是RDB方式数据持久化时机，可以多个条件配合</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/Npj1Gsm84fP3zew.png"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/LVhyrgU6G8JTdXM.png"></p>
<h2 id="AOF持久化机制"><a href="#AOF持久化机制" class="headerlink" title="AOF持久化机制"></a>AOF持久化机制</h2><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><blockquote>
<ol>
<li>该机制可以带来<code>更高的数据安全性</code>，即数据持久性。Redis中提供了<code>3种同步策略，即每秒同步、每修改同步和不同步</code>。事实上，每秒同步也是异步完成的，其效率也是非常高的，所差的是一旦系统出现宕机现象，那么这一秒钟之内修改的数据将会丢失。而每修改同步，可以将其视为同步持久化，即每次发生的数据变化都会被立即记录到磁盘中。可以预见，这种方式在效率上是最低的。至于无同步，无需多言。</li>
<li>由于该机制<code>对日志文件的写入操作采用的是append模式</code>，因此在写入过程中即使出现宕机现象，也不会破坏日志文件中已经存在的内容。然而如果本次操作只是<code>写入了一半数据就出现了系统崩溃问题，不用担心，在Redis下一次启动之前，可以通过redis-check-aof工具来帮助我们解决数据一致性的问题</code>。</li>
<li>如果<code>日志过大，Redis可以自动启用rewrite机制</code>。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</li>
<li>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。<code>可以通过该文件完成数据的重建</code></li>
</ol>
</blockquote>
<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><blockquote>
<ol>
<li>对于相同数量的数据集而言，<code>AOF文件通常要大于RDB文件</code></li>
<li>根据同步策略的不同，<code>AOF在运行效率上往往会慢于RDB</code></li>
</ol>
</blockquote>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><h4 id="开启AOF持久化"><a href="#开启AOF持久化" class="headerlink" title="开启AOF持久化"></a>开启AOF持久化</h4><p>在redis.windows.conf配置文件中有如下配置：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/wBD2WvHrakPzyO5.png"></p>
<p>将<code>appendonly修改为yes，开启aof持久化机制</code>，默认会<code>在目录下产生一个appendonly.aof文件</code>，启动需要指定配置文件</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/IUujFNZEvCBxcVD.png"></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/w9dbJgyOiMtUG4R.png"></p>
<h4 id="AOF持久化时机"><a href="#AOF持久化时机" class="headerlink" title="AOF持久化时机"></a>AOF持久化时机</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment">#appendfsync no</span></span><br></pre></td></tr></table></figure>

<p>上述配置为aof持久化的时机，解释如下：</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/ABU1SDX6qIe93HV.png"></p>
<h1 id="过期与淘汰策略"><a href="#过期与淘汰策略" class="headerlink" title="过期与淘汰策略"></a>过期与淘汰策略</h1><p>长期将Redis作为缓存使用，难免会遇到内存空间存储瓶颈，当Redis内存超出物理内存限制时，Redis性能将急剧下降。此时如何淘汰无用数据释放空间，存储新数据就变得尤为重要了。</p>
<h2 id="设置占用内存"><a href="#设置占用内存" class="headerlink" title="设置占用内存"></a>设置占用内存</h2><ul>
<li>文件配置</li>
</ul>
<p>找到<code># maxmemory &lt;bytes&gt;，去掉#注释</code>，设置maxmemory参数，<code>maxmemory是bytes字节类型，注意转换</code>，一般<code>推荐Redis设置使用内存为最大物理内存的四分之三</code>，Redis服务<code>重启后不会失效</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/24/oa6WdOB9ZN7GeM5.png"></p>
<blockquote>
<p><code>在线文件大小换算</code>：<a target="_blank" rel="noopener" href="https://www.bejson.com/convert/filesize/">https://www.bejson.com/convert/filesize/</a></p>
</blockquote>
<ul>
<li>命令修改</li>
</ul>
<p>使用redis-cli客户端命令修改，Redis服务<code>重启后将失效</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/24/4on5pqOXCvKVrDw.png"></p>
<blockquote>
<p>如果<code>不设置 最大内存大小</code>或者<code>设置 最大内存大小为0</code>，<code>在64位操作系统下不限制内存大小，在32位操作系统下最多使用3GB内存</code></p>
</blockquote>
<h2 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h2><p>Redis采用的过期策略是：<code>定期删除 + 惰性删除策略</code>。</p>
<blockquote>
<ul>
<li>为什么不用定时删除策略?</li>
</ul>
</blockquote>
<p>定时删除，用一个定时器来负责监视key，过期则自动删除。虽然内存及时释放，但是十分消耗CPU资源。在大并发请求下，CPU要将时间应用在处理请求，而不是删除key。因此没有采用这一策略.</p>
<blockquote>
<ul>
<li>定期删除 + 惰性删除是如何工作的呢?</li>
</ul>
</blockquote>
<p>定期删除，redis默认每个100ms检查一次，随机抽取进行检查(如果每隔100ms，全部key进行检查，redis岂不是卡死)。因此，如果只采用定期删除策略，会导致很多key到时间没有删除。于是，惰性删除派上用场。也就是说在你获取某个key的时候，redis会检查一下，这个key如果设置了过期时间那么是否过期了？如果过期了此时就会删除。</p>
<blockquote>
<ul>
<li>采用定期删除+惰性删除就没其他问题了么?</li>
</ul>
</blockquote>
<p>不是的，如果定期删除没删除key。然后也没即时去请求key，也就是说惰性删除也没生效。这样，redis的内存会越来越高。那么就应该采用<code>内存淘汰策略</code>。</p>
<h2 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h2><p>Redis定义了六种策略用来处理这种情况：</p>
<blockquote>
<ol>
<li><code>noeviction(默认策略)</code>：对于写请求不再提供服务，直接返回错误（DEL请求和部分特殊请求除外）</li>
<li><code>allkeys-lru</code>：从<code>所有key</code>中，使用<code>LRU算法</code>进行淘汰<code>最近最少使用的数据</code></li>
<li><code>allkeys-random</code>：从<code>所有key</code>中，<code>随机选择数据淘汰</code></li>
<li><code>volatile-lru</code>：从设置了<code>过期时间的key</code>中，使用<code>LRU算法</code>进行淘汰<code>最近最少使用的数据</code></li>
<li><code>volatile-random</code>：从设置了<code>过期时间的key</code>中，<code>随机选择数据淘汰</code></li>
<li><code>volatile-ttl</code>：在设置了<code>过期时间的key</code>中，根据key的过期时间进行淘汰，<code>越早过期的越优先被淘汰</code></li>
</ol>
</blockquote>
<p>注：</p>
<blockquote>
<ol>
<li>当使用<code>volatile-lru、volatile-random、volatile-ttl</code>这三种策略时，如果key没有设置 expire(过期时间)，则和noeviction一样返回错误</li>
<li>将key<code>设置过期时间实际上会消耗更多的内存</code>，因此<code>建议使用allkeys-lru策略</code>从而更有效率的使用内存</li>
</ol>
</blockquote>
<h3 id="文件设置"><a href="#文件设置" class="headerlink" title="文件设置"></a>文件设置</h3><p>找到<code># maxmemory-policy</code>，<code>去掉#注释</code>，在maxmemory-policy后设置淘汰策略，Redis<code>重启后不会失效</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/24/ZOPa9UKnzNg1Rxb.png"></p>
<h3 id="命令修改"><a href="#命令修改" class="headerlink" title="命令修改"></a>命令修改</h3><p>使用redis-cli客户端命令修改，Redis服务<code>重启后将失效</code></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/24/mnVFoqdKxOcgaL4.png"></p>
<h3 id="LRU算法"><a href="#LRU算法" class="headerlink" title="LRU算法"></a>LRU算法</h3><blockquote>
<p><code>LRU(Least Recently Used)，即最近最少使用，是一种缓存置换算法</code>。在使用内存作为缓存的时候，缓存的大小一般是固定的。当缓存被占满，这个时候继续往缓存里面添加数据，就需要淘汰一部分老的数据，释放内存空间用来存储新的数据。这个时候就可以使用LRU算法了。</p>
</blockquote>
<p><code>核心思想</code>是：如果一个数据在最近一段时间没有被用到，那么将来被使用到的可能性也很小，所以就可以被淘汰掉。</p>
<h4 id="在Redis中的实现"><a href="#在Redis中的实现" class="headerlink" title="在Redis中的实现"></a>在Redis中的实现</h4><h5 id="近似LRU算法"><a href="#近似LRU算法" class="headerlink" title="近似LRU算法"></a>近似LRU算法</h5><p><code>Redis使用的是近似LRU算法</code>，它跟常规的LRU算法还不太一样。近似LRU算法通过随机采样法淘汰数据，<code>每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</code></p>
<blockquote>
<p>可以通过<code>maxmemory-samples</code>参数修改采样数量<br>例：<code>maxmemory-samples 10</code><br>maxmenory-samples配置的越大，淘汰的结果越接近于严格的LRU算法</p>
</blockquote>
<p>Redis为了实现近似LRU算法，给每个key增加了一个额外增加了一个24bit的字段，用来存储该key最后一次被访问的时间。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/24/p7uSwkCLXROVaiz.png"></p>
<h5 id="Redis3-0的优化"><a href="#Redis3-0的优化" class="headerlink" title="Redis3.0的优化"></a>Redis3.0的优化</h5><p><code>Redis3.0</code>对近似LRU算法进行了一些优化。新算法会<code>维护一个候选池（大小为16）</code>，池中的数据<code>根据访问时间进行排序</code>，第一次随机选取的key都会放入池中，随后每次随机选取的key，只有在访问时间小于池中最小的时间才会放入池中，直到候选池被放满。当放满后，如果有新的key需要放入，则将池中最后访问时间最大（最近被访问）的移除。</p>
<p>当需要淘汰的时候，则直接从池中选取最近访问时间最小（最久没被访问）的key淘汰掉就行。</p>
<h3 id="LFU算法"><a href="#LFU算法" class="headerlink" title="LFU算法"></a>LFU算法</h3><p><code>LFU算法</code>是<code>Redis4.0</code>里面新加的一种<code>淘汰策略</code>。它的全称是<code>Least Frequently Used</code>，它的<code>核心思想</code>是根据key的最近被访问的频率进行淘汰，<code>很少被访问的优先被淘汰</code>，被访问的多的则被留下来。</p>
<blockquote>
<p>LFU一共有两种策略：</p>
<ol>
<li><code>volatile-lfu</code>：在设置了过期时间的key中，使用LFU算法淘汰key</li>
<li><code>allkeys-lfu</code>：在所有的key中，使用LFU算法淘汰数据</li>
</ol>
</blockquote>
<p>设置使用这两种淘汰策略跟前面讲的一样，不过要注意的一点是这两种策略只能在Redis4.0及以上设置，如果在Redis4.0以下设置会报错</p>
<h3 id="LRU与LFU的区别"><a href="#LRU与LFU的区别" class="headerlink" title="LRU与LFU的区别"></a>LRU与LFU的区别</h3><p>LFU算法能更好的表示一个key被访问的热度。假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了(Redis不直接使用LRU算法的原因)。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。</p>
<h1 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h1><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><h3 id="什么是缓存穿透"><a href="#什么是缓存穿透" class="headerlink" title="什么是缓存穿透"></a>什么是缓存穿透</h3><p>缓存穿透是指用户查询数据，在数据库没有，自然在缓存中也不会有。这样就导致用户查询的时候，在缓存中找不到对应key的value，每次都要去数据库再查询一遍，然后返回空（相当于进行了两次无用的查询）。</p>
<blockquote>
<p><code>在流量大时，要是有人利用不存在的key频繁攻击我们的应用，可能DB就挂掉了，这就是漏洞</code>。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/20/EUNaPtZJTwGp2gm.jpg"></p>
<h3 id="有什么解决方案来防止缓存穿透"><a href="#有什么解决方案来防止缓存穿透" class="headerlink" title="有什么解决方案来防止缓存穿透"></a>有什么解决方案来防止缓存穿透</h3><ul>
<li>缓存空值</li>
</ul>
<p>如果一个查询返回的数据为空（不管是数据不存在，还是系统故障）我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过5分钟。通过这个设置的默认值存放到缓存，这样第二次到缓存中获取就有值了，而不会继续访问数据库</p>
<ul>
<li>采用布隆过滤器BloomFilter</li>
</ul>
<blockquote>
<p><code>优势：占用内存空间很小，位存储；性能特别高，使用key的hash判断key存不存在</code></p>
</blockquote>
<p>将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截掉，从而避免了对底层存储系统的查询压力<br><code>在缓存之前在加一层BloomFilter，在查询的时候先去BloomFilter去查询key是否存在</code>，如果不存在就直接返回，存在再去查询缓存，缓存中没有再去查询数据库</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿访问了不存在的数据，跳过了合法数据的redis数据缓存阶段，每次访问数据库，导致对数据库服务器造成压力。通常此类数据的出现量是一个较低的值，当出现此类情况以毒攻毒，并及时报警。应对策略应该在临时预案防范方面多做文章。无论是黑名单还是白名单，都是对整体系统的压力，警报解除后尽快移除。</p>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><h3 id="什么是缓存击穿"><a href="#什么是缓存击穿" class="headerlink" title="什么是缓存击穿"></a>什么是缓存击穿</h3><p>在平常高并发的系统中，大量的请求同时查询一个key时，<code>此时这个key正好失效了，就会导致大量的请求都打到数据库上面去</code>。这种现象我们称为缓存击穿</p>
<h3 id="问题排查"><a href="#问题排查" class="headerlink" title="问题排查"></a>问题排查</h3><blockquote>
<ol>
<li>Redis中某个key过期，该key访问量巨大</li>
<li>多个数据请求从服务器直接压到Redis后，均未命中</li>
<li>Redis在短时间内发起了大量对数据库中同一数据的访问</li>
</ol>
</blockquote>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="使用互斥锁-mutex-key"><a href="#使用互斥锁-mutex-key" class="headerlink" title="使用互斥锁(mutex key)"></a>使用互斥锁(mutex key)</h4><p>业界比较常用的做法，是使用mutex。简单地来说，就是<code>在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存</code>；<code>否则，就重试整个get缓存的方法</code>。</p>
<blockquote>
<p><code>SETNX</code>，是「<code>SET if Not eXists</code>」的缩写，也就是只有<code>不存在的时候才设置</code>，可以<code>利用它来实现锁</code>的效果。在<code>redis2.6.1之前版本未实现setnx的过期时间</code>，下面给出两种版本代码参考：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.6.1前单机版本锁</span></span><br><span class="line">String <span class="title function_">get</span><span class="params">(String key)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">   <span class="keyword">if</span> (value  == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// 3分钟超时以避免互斥锁持有者崩溃</span></span><br><span class="line">        redis.expire(key_mutex, <span class="number">3</span> * <span class="number">60</span>)</span><br><span class="line">        value = db.get(key);</span><br><span class="line">        redis.set(key, value);</span><br><span class="line">        redis.delete(key_mutex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他线程休息50毫秒后重试</span></span><br><span class="line">        Thread.sleep(<span class="number">50</span>);</span><br><span class="line">        get(key);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.6.1后单机版本锁</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">get</span><span class="params">(key)</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">      <span class="comment">//代表缓存值过期</span></span><br><span class="line">      <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123; </span><br><span class="line">          <span class="comment">//设置3min的超时，防止del操作失败的时候，下次缓存过期一直不能load db</span></span><br><span class="line">          <span class="comment">//代表设置成功</span></span><br><span class="line">          <span class="keyword">if</span> (redis.setnx(key_mutex, <span class="number">1</span>, <span class="number">3</span> * <span class="number">60</span>) == <span class="number">1</span>) &#123;  </span><br><span class="line">               value = db.get(key);</span><br><span class="line">               redis.set(key, value, expire_secs);</span><br><span class="line">               redis.del(key_mutex);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">              <span class="comment">//这个时候代表同时候的其他线程已经load db并回设到缓存了，这时候重试获取缓存值即可</span></span><br><span class="line">                   sleep(<span class="number">50</span>);</span><br><span class="line">                   get(key);  <span class="comment">//重试</span></span><br><span class="line">              &#125;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">return</span> value;</span><br><span class="line">          &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memcache代码</span></span><br><span class="line"><span class="keyword">if</span> (memcache.get(key) == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 3分钟超时以避免互斥锁持有者崩溃</span></span><br><span class="line">    <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">        value = db.get(key);</span><br><span class="line">        memcache.set(key, value);</span><br><span class="line">        memcache.delete(key_mutex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">50</span>);</span><br><span class="line">        retry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="提前使用互斥锁-mutex-key"><a href="#提前使用互斥锁-mutex-key" class="headerlink" title="提前使用互斥锁(mutex key)"></a>提前使用互斥锁(mutex key)</h4><p>在value内部设置1个超时值(timeout1), <code>timeout1比实际的memcache timeout(timeout2)小</code>。</p>
<p><code>当从cache读取到timeout1发现它已经过期时候，马上延长timeout1并重新设置到cache。然后再从数据库加载数据并设置到cache中</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// memcache伪代码如下：</span></span><br><span class="line"></span><br><span class="line">v = memcache.get(key);</span><br><span class="line"><span class="keyword">if</span> (v == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">        value = db.get(key);</span><br><span class="line">        memcache.set(key, value);</span><br><span class="line">        memcache.delete(key_mutex);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">50</span>);</span><br><span class="line">        retry();</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (v.timeout &lt;= now()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (memcache.add(key_mutex, <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>) == <span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 延长超时时间</span></span><br><span class="line">            v.timeout += <span class="number">3</span> * <span class="number">60</span> * <span class="number">1000</span>;</span><br><span class="line">            memcache.set(key, v, KEY_TIMEOUT * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 从db加载最新值</span></span><br><span class="line">            v = db.get(key);</span><br><span class="line">            v.timeout = KEY_TIMEOUT;</span><br><span class="line">            memcache.set(key, value, KEY_TIMEOUT * <span class="number">2</span>);</span><br><span class="line">            memcache.delete(key_mutex);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sleep(<span class="number">50</span>);</span><br><span class="line">            retry();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="永远不过期"><a href="#永远不过期" class="headerlink" title="永远不过期"></a>永远不过期</h4><p>这里的“永远不过期”包含两层意思：</p>
<blockquote>
<ol>
<li>从redis上看，确实没有设置过期时间，这就保证了，不会出现热点key过期问题，也就是“物理”不过期。</li>
<li>从功能上看，如果不过期，那不就成静态的了吗？所以我们把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建，也就是“逻辑”过期</li>
</ol>
</blockquote>
<p>从实战看，这种方法<code>对于性能非常友好</code>，<code>唯一不足的就是构建缓存时候，其余线程(非构建缓存的线程)可能访问的是老数据</code>，但是对于一般的互联网功能来说这个还是可以忍受。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/20/dHwha1KLSjGe7Jv.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String <span class="title function_">get</span><span class="params">(<span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        <span class="type">V</span> <span class="variable">v</span> <span class="operator">=</span> redis.get(key);</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> v.getValue();</span><br><span class="line">        <span class="type">long</span> <span class="variable">timeout</span> <span class="operator">=</span> v.getTimeout();</span><br><span class="line">        <span class="keyword">if</span> (v.timeout &lt;= System.currentTimeMillis()) &#123;</span><br><span class="line">            <span class="comment">// 异步更新后台异常执行</span></span><br><span class="line">            threadPool.execute(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">keyMutex</span> <span class="operator">=</span> <span class="string">&quot;mutex:&quot;</span> + key;</span><br><span class="line">                    <span class="keyword">if</span> (redis.setnx(keyMutex, <span class="string">&quot;1&quot;</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 3分钟超时以避免互斥锁持有者崩溃</span></span><br><span class="line">                        redis.expire(keyMutex, <span class="number">3</span> * <span class="number">60</span>);</span><br><span class="line">                        <span class="type">String</span> <span class="variable">dbValue</span> <span class="operator">=</span> db.get(key);</span><br><span class="line">                        redis.set(key, dbValue);</span><br><span class="line">                        redis.delete(keyMutex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="资源保护"><a href="#资源保护" class="headerlink" title="资源保护"></a>资源保护</h4><p>采用netflix的hystrix，可以做资源的隔离保护主线程池，如果把这个应用到缓存的构建也未尝不可。</p>
<p>四种解决方案：没有最佳只有最合适</p>
<table>
<thead>
<tr>
<th align="center">解决方案</th>
<th align="center">优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">简单分布式锁(Tim yang)</td>
<td align="center">1. 思路简单<br/>2. 保证一致性</td>
<td>1. 代码复杂度增大<br/>2. 存在死锁的风险<br/>3. 存在线程池阻塞的风险</td>
</tr>
<tr>
<td align="center">加另外一个过期时间(Tim yang)</td>
<td align="center">保证一致性</td>
<td>同上</td>
</tr>
<tr>
<td align="center">不过期(本文)</td>
<td align="center">异步构建缓存，不会阻塞线程池</td>
<td>1. 不保证一致性。<br/>2. 代码复杂度增大(每个value都要维护一个timekey)。<br/>3. 占用一定的内存空间(每个value都要维护一个timekey)。</td>
</tr>
<tr>
<td align="center">资源隔离组件hystrix(本文)</td>
<td align="center">hystrix技术成熟，有效保证后端。<br/>hystrix监控强大。</td>
<td>部分访问存在降级策略。</td>
</tr>
</tbody></table>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>缓存击穿就是单个高热数据过期的瞬间，数据访问量较大，未命中redis后，发起了大量对同一数据的数据库访问，导致对数据库服务器造成压力。<code>应对策略应该在业务数据分析与预防方面进行，配合运行监控测试与即时调整策略</code>，毕竟单个key的过期监控难度较高，<code>配合雪崩处理策略即可</code>。</p>
<h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><h3 id="什么是缓存雪崩"><a href="#什么是缓存雪崩" class="headerlink" title="什么是缓存雪崩"></a>什么是缓存雪崩</h3><p>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到DB，DB瞬时压力过重雪崩。由于原有缓存失效，新缓存未到期间所有原本应该访问缓存的请求都去查询数据库了，而对数据库CPU和内存造成巨大压力，严重的会造成数据库宕机。</p>
<h3 id="缓存雪崩问题排查"><a href="#缓存雪崩问题排查" class="headerlink" title="缓存雪崩问题排查"></a>缓存雪崩问题排查</h3><ol>
<li>在一个较短的时间内，缓存中较多的key集中过期</li>
<li>此周期内请求访问过期的数据，redis未命中，redis向数据库获取数据</li>
<li>数据库同时接收到大量的请求无法及时处理</li>
<li>Redis大量请求被积压，开始出现超时现象</li>
<li>数据库流量激增，数据库崩溃</li>
<li>重启后仍然面对缓存中无数据可用</li>
<li>Redis服务器资源被严重占用，Redis服务器崩溃</li>
<li>Redis集群呈现崩塌，集群瓦解</li>
<li>应用服务器无法及时得到数据响应请求，来自客户端的请求数量越来越多，应用服务器崩溃</li>
<li>应用服务器，redis，数据库全部重启，效果不理想</li>
</ol>
<h3 id="有什么解决方案来防止缓存雪崩？"><a href="#有什么解决方案来防止缓存雪崩？" class="headerlink" title="有什么解决方案来防止缓存雪崩？"></a>有什么解决方案来防止缓存雪崩？</h3><ol>
<li><p>更多的页面静态化处理</p>
</li>
<li><p>构建多级缓存架构<br>Nginx缓存+redis缓存+ehcache缓存</p>
</li>
<li><p>检测Mysql严重耗时业务进行优化<br>对数据库的瓶颈排查：例如超时查询、耗时较高事务等</p>
</li>
<li><p>灾难预警机制</p>
</li>
</ol>
<ul>
<li>监控redis服务器性能指标</li>
<li>CPU占用、CPU使用率</li>
<li>内存容量</li>
<li>查询平均响应时间</li>
<li>线程数</li>
</ul>
<ol start="5">
<li>限流、降级<br>短时间范围内牺牲一些客户体验，限制一部分请求访问，降低应用服务器压力，待业务低速运转后再逐步放开访问</li>
<li>LRU与LFU切换</li>
<li>数据有效期策略调整</li>
</ol>
<ul>
<li>根据业务数据有效期进行分类错峰，A类90分钟，B类80分钟，C类70分钟</li>
<li>过期时间使用<code>固定时间+随机值(时间值)</code>的形式，稀释集中到期的key的数量</li>
</ul>
<ol start="8">
<li>超热数据使用永久key</li>
<li>定期维护（自动+人工）<br>对即将过期数据做访问量分析，确认是否延时，配合访问量统计，做热点数据的延时</li>
<li>加锁</li>
</ol>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>缓存雪崩就是瞬间过期数据量太大，导致对数据库服务器造成压力。如能够有效避免过期时间集中，可以有效解决雪崩现象的出现（约40%），配合其他策略一起使用，并监控服务器的运行数据，根据运行记录做快速调整。</p>
<h2 id="缓存预热"><a href="#缓存预热" class="headerlink" title="缓存预热"></a>缓存预热</h2><h3 id="什么是缓存预热"><a href="#什么是缓存预热" class="headerlink" title="什么是缓存预热"></a>什么是缓存预热</h3><p>缓存预热就是系统上线后，<code>将相关的缓存数据直接加载到缓存系统</code>。这样就可以避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题。用户直接查询事先被预热的缓存数据。如图所示：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/20/YxHgCUiSZcR9NPM.png"></p>
<p><code>如果不进行预热， 那么Redis初识状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。</code></p>
<h3 id="问题排查-1"><a href="#问题排查-1" class="headerlink" title="问题排查"></a>问题排查</h3><ul>
<li>请求数量较高</li>
<li>主从之间数据吞吐量较大，数据同步操作频度较高</li>
</ul>
<h3 id="有什么解决方案"><a href="#有什么解决方案" class="headerlink" title="有什么解决方案"></a>有什么解决方案</h3><ul>
<li>前置准备工作：</li>
</ul>
<ol>
<li>日常例行统计数据访问记录，统计访问频度较高的热点数据</li>
<li>利用LRU数据删除策略，构建数据留存队列</li>
</ol>
<blockquote>
<p>例如：storm与kafka配合</p>
</blockquote>
<ul>
<li>准备工作：</li>
</ul>
<ol>
<li>将统计结果中的数据分类，根据级别，redis优先加载级别较高的热点数据</li>
<li>利用分布式多服务器同时进行数据读取，提速数据加载过程</li>
<li>热点数据主从同时预热</li>
</ol>
<ul>
<li>实施：</li>
</ul>
<ol>
<li>使用脚本程序固定触发数据预热过程</li>
<li>如果条件允许，使用了<code>CDN（内容分发网络）</code>，效果会更好</li>
</ol>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>缓存预热就是系统启动前，提前将相关的缓存数据直接加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题！用户直接查询事先被预热的缓存数据 </p>
<h2 id="缓存降级"><a href="#缓存降级" class="headerlink" title="缓存降级"></a>缓存降级</h2><p>降级的情况，就是<code>缓存失效或者缓存服务挂掉的情况下，我们也不去访问数据库。我们直接访问内存部分数据缓存或者直接返回默认数据。</code></p>
<p>举例来说：</p>
<blockquote>
<p>对于应用的首页，一般是访问量非常大的地方，首页里面往往包含了部分推荐商品的展示信息。这些推荐商品都会放到缓存中进行存储，同时我们为了避免缓存的异常情况，对热点商品数据也存储到了内存中。同时内存中还保留了一些默认的商品信息。如下图所示：</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2021/12/20/hJFg5SfiR8z4163.png"></p>
<p><code>注：降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。</code></p>
<h1 id="Jedis的基本使用"><a href="#Jedis的基本使用" class="headerlink" title="Jedis的基本使用"></a>Jedis的基本使用</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Redis不仅是使用命令来操作，现在基本上主流的语言都有客户端支持，比如java、C、C#、C++、php、Node.js、Go等。 在官方网站里列一些Java的客户端，有Jedis、Redisson、Jredis、JDBC-Redis、等其中官方推荐使用Jedis和Redisson。 在企业中用的最多的就是Jedis，Jedis同样也是托管在github上，地址：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/xetorthio/jedis">https://github.com/xetorthio/jedis</a></p>
</blockquote>
<p>Jedis基本上实现了所有的Redis命令，并且还支持连接池、集群等高级的用法，而且使用简单，使得在Java中使用Redis服务将变得非常的简单，Maven依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>redis.clients<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jedis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>compile<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/lxBiO4D3s5nV2KL.png"></p>
<h3 id="代码操作"><a href="#代码操作" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        目的：使用jedis操作redis，进行存取数据</span></span><br><span class="line"><span class="comment">        1.创建jedis对象，连接到redis服务器端</span></span><br><span class="line"><span class="comment">          public Jedis(String host, int port)</span></span><br><span class="line"><span class="comment">           host，指定redis服务器地址</span></span><br><span class="line"><span class="comment">           port,指定redis使用的端口号</span></span><br><span class="line"><span class="comment">        */</span>      </span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Jedis</span>(<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        2.往redis里面写入数据</span></span><br><span class="line"><span class="comment">        通过jedis操作redis，与使用redis客户端执行命令是一致的</span></span><br><span class="line"><span class="comment">        客户端所有的命令都是jedis的方法，所有key和value都是方法的参数</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="comment">//存入字符串数据,jedis.set(key,value);</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;javaee87&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入list数据，jedis.lpush(key,value可变参数);</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;myList2&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.从redis里面读取数据</span></span><br><span class="line">        <span class="comment">//取string数据，jedis.get(key)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取list数据,List&lt;String&gt; myList2 = jedis.lrange(key,start,end);</span></span><br><span class="line">        List&lt;String&gt; myList2 =  jedis.lrange(<span class="string">&quot;myList2&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;myList2=&quot;</span>+myList2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="连接池的使用"><a href="#连接池的使用" class="headerlink" title="连接池的使用"></a>连接池的使用</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>jedis连接资源的创建与销毁是很消耗程序性能，所以jedis为我们提供了jedis的池化技术，jedisPool在创建时初始化一些连接资源存储到连接池中，使用jedis连接资源时不需要创建，而是从连接池中获取一个资源进行redis的操作，使用完毕后，不需要销毁该jedis连接资源，而是将该资源归还给连接池，供其他请求使用。</p>
<h4 id="常用API-1"><a href="#常用API-1" class="headerlink" title="常用API"></a>常用API</h4><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2020/08/17/noXtdr7NS8ICg4p.png"></p>
<h3 id="代码操作-1"><a href="#代码操作-1" class="headerlink" title="代码操作"></a>代码操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目的：使用连接池优化jedis操作redis，进行存取数据</span></span><br><span class="line">        <span class="comment">//1.创建jedis连接池配置对象，并设置配置连接池的参数</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxTotal(<span class="number">100</span>);<span class="comment">//最大连接数</span></span><br><span class="line">        config.setMaxWaitMillis(<span class="number">3000</span>);<span class="comment">//用户等待连接超时事件，等待3秒</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//2.根据配置对象创建jedis连接池对象</span></span><br><span class="line">        <span class="comment">//public JedisPool(GenericObjectPoolConfig poolConfig, String host, int port)</span></span><br><span class="line">        <span class="type">JedisPool</span> <span class="variable">jedisPool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,<span class="string">&quot;localhost&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//3.根据连接池获取jedis连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> jedisPool.getResource();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//4.往redis里面写入数据</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;javaee87&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//存入list数据，jedis.lpush(key,value可变参数);</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;myList2&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//5.从redis里面读取数据</span></span><br><span class="line">        <span class="comment">//取string数据，jedis.get(key)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//取list数据,List&lt;String&gt; myList2 = jedis.lrange(key,start,end);</span></span><br><span class="line">        List&lt;String&gt; myList2 =  jedis.lrange(<span class="string">&quot;myList2&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;myList2=&quot;</span>+myList2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//6.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//7.关闭连接池</span></span><br><span class="line">        <span class="comment">//jedisPool.close();,连接池不要关闭，关闭了连接池就不能用了</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="连接池工具类"><a href="#连接池工具类" class="headerlink" title="连接池工具类"></a>连接池工具类</h2><h3 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h3><p>jedis.properties</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">maxTotal=100</span><br><span class="line">maxWaitMillis=3000</span><br><span class="line">host=localhost</span><br><span class="line">port=6379</span><br></pre></td></tr></table></figure>

<h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//jedis连接池对象</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过静态代码块初始化</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="comment">//解析jedis.properties配置文件</span></span><br><span class="line">        <span class="comment">//ResourceBundle专门用于解析properties文件，只需要提供文件名就可以解析</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">resourceBundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jedis&quot;</span>);</span><br><span class="line">        <span class="comment">//获取里面的数据</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;maxTotal&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxWaitMillis</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;maxWaitMillis&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> resourceBundle.getString(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">        <span class="comment">//创建连接池配置对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line">        config.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">        <span class="comment">//初始化连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,host,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//提供一个方便获取jedis连接的工具类方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.util.JedisUtils;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis的使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisTest3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//目的：使用连接池优化jedis操作redis，进行存取数据</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.使用工具类获取jedis连接对象</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtils.getJedis();</span><br><span class="line">        <span class="comment">//2.往redis里面写入数据</span></span><br><span class="line">        jedis.set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;javaee87黑马程序员&quot;</span>);</span><br><span class="line">        <span class="comment">//存入list数据，jedis.lpush(key,value可变参数);</span></span><br><span class="line">        jedis.lpush(<span class="string">&quot;myList2&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>);</span><br><span class="line">        <span class="comment">//3.从redis里面读取数据</span></span><br><span class="line">        <span class="comment">//取string数据，jedis.get(key)</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        <span class="comment">//取list数据,List&lt;String&gt; myList2 = jedis.lrange(key,start,end);</span></span><br><span class="line">        List&lt;String&gt; myList2 =  jedis.lrange(<span class="string">&quot;myList2&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;name=&quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;myList2=&quot;</span>+myList2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//4.关闭连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h1 id="Servelet整合Redis"><a href="#Servelet整合Redis" class="headerlink" title="Servelet整合Redis"></a>Servelet整合Redis</h1><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><ul>
<li>Redis实战之查询所有省份<br>访问index.jsp页面，使用ajax请求加载省份列表，用户第一次访问数据库获取，以后都从redis里面获取。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/1IR8z5jUTaJtmKu.png"></p>
<ul>
<li>province(数据库表)</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/VPd8wRBh23lg56e.png"></p>
<p>写入测试数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span>  <span class="keyword">into</span> `province`(`pid`,`pname`) <span class="keyword">values</span> (<span class="number">1</span>,<span class="string">&#x27;广东省&#x27;</span>),(<span class="number">2</span>,<span class="string">&#x27;湖南省&#x27;</span>),(<span class="number">3</span>,<span class="string">&#x27;吉林省&#x27;</span>),(<span class="number">4</span>,<span class="string">&#x27;广西省&#x27;</span>);</span><br></pre></td></tr></table></figure>

<ul>
<li>分析</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/NVv1wukgCJYa6bS.png"></p>
<h2 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h2><h3 id="druid-properties"><a href="#druid-properties" class="headerlink" title="druid.properties"></a>druid.properties</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://127.0.0.1:3306/javaee88</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line">initialSize=5</span><br><span class="line">maxActive=50</span><br><span class="line">maxWait=3000</span><br><span class="line">maxIdle=6</span><br><span class="line">minIdle=3</span><br></pre></td></tr></table></figure>

<h3 id="jedis-properties"><a href="#jedis-properties" class="headerlink" title="jedis.properties"></a>jedis.properties</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">maxTotal=100</span><br><span class="line">maxWaitMillis=3000</span><br><span class="line">host=localhost</span><br><span class="line">port=6379</span><br></pre></td></tr></table></figure>

<h2 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h2><h3 id="Province-java"><a href="#Province-java" class="headerlink" title="Province.java"></a>Province.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Province</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> pid;</span><br><span class="line">    <span class="keyword">private</span> String pname;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Province</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Province</span><span class="params">(<span class="type">int</span> pid, String pname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">        <span class="built_in">this</span>.pname = pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getPid</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPid</span><span class="params">(<span class="type">int</span> pid)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pid = pid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getPname</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> pname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setPname</span><span class="params">(String pname)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.pname = pname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="工具类-1"><a href="#工具类-1" class="headerlink" title="工具类"></a>工具类</h2><h3 id="JdbcUtils-java"><a href="#JdbcUtils-java" class="headerlink" title="JdbcUtils.java"></a>JdbcUtils.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1. 声明静态数据源成员变量</span></span><br><span class="line"><span class="comment">	2. 创建连接池对象</span></span><br><span class="line"><span class="comment">	3. 定义公有的得到数据源的方法</span></span><br><span class="line"><span class="comment">	4. 定义得到连接对象的方法</span></span><br><span class="line"><span class="comment">	5. 定义关闭资源的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JdbcUtils</span> &#123;</span><br><span class="line">	<span class="comment">// 1.	声明静态数据源成员变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 2. 创建连接池对象</span></span><br><span class="line">	<span class="keyword">static</span> &#123;</span><br><span class="line">		<span class="comment">// 加载配置文件中的数据</span></span><br><span class="line">		<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> JdbcUtils.class.getResourceAsStream(<span class="string">&quot;/druid.properties&quot;</span>);</span><br><span class="line">		<span class="type">Properties</span> <span class="variable">pp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			pp.load(is);</span><br><span class="line">			<span class="comment">// 创建连接池，使用配置文件中的参数</span></span><br><span class="line">			ds = DruidDataSourceFactory.createDataSource(pp);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 3. 定义公有的得到数据源的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title function_">getDataSource</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> ds;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 4. 定义得到连接对象的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title function_">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">		<span class="keyword">return</span> ds.getConnection();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 5.定义关闭资源的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt, ResultSet rs)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rs != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				rs.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (stmt != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				stmt.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (conn != <span class="literal">null</span>) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				conn.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (SQLException e) &#123;&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 6.重载关闭方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">close</span><span class="params">(Connection conn, Statement stmt)</span> &#123;</span><br><span class="line">		close(conn, stmt, <span class="literal">null</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JedisUtils-java"><a href="#JedisUtils-java" class="headerlink" title="JedisUtils.java"></a>JedisUtils.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPool;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.JedisPoolConfig;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ResourceBundle;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * jedis获取连接的工具类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JedisUtils</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义连接池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> JedisPool jedisPool;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//1.解析配置文件获取配置数据</span></span><br><span class="line">        <span class="comment">//ResourceBundle专门用于解析properites文件，解析的时候只需要文件名就可以解析</span></span><br><span class="line">        <span class="type">ResourceBundle</span> <span class="variable">resourceBundle</span> <span class="operator">=</span> ResourceBundle.getBundle(<span class="string">&quot;jedis&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxTotal</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;maxTotal&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxWaitMillis</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;maxWaitMillis&quot;</span>));</span><br><span class="line">        <span class="type">String</span> <span class="variable">host</span> <span class="operator">=</span> resourceBundle.getString(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">port</span> <span class="operator">=</span> Integer.parseInt(resourceBundle.getString(<span class="string">&quot;port&quot;</span>));</span><br><span class="line">        <span class="comment">//2.创建连接池配置对象</span></span><br><span class="line">        <span class="type">JedisPoolConfig</span> <span class="variable">config</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JedisPoolConfig</span>();</span><br><span class="line">        config.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">        config.setMaxTotal(maxTotal);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.初始化连接池对象</span></span><br><span class="line">        jedisPool = <span class="keyword">new</span> <span class="title class_">JedisPool</span>(config,host,port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从连接池获取连接对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Jedis</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title function_">getJedis</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jedisPool.getResource();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><h3 id="CharchaterFilter-java"><a href="#CharchaterFilter-java" class="headerlink" title="CharchaterFilter.java"></a>CharchaterFilter.java</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解决全站乱码问题，处理所有的请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter(&quot;/*&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CharchaterFilter</span> <span class="keyword">implements</span> <span class="title class_">Filter</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">doFilter</span><span class="params">(ServletRequest req, ServletResponse rep, FilterChain filterChain)</span> <span class="keyword">throws</span> IOException, ServletException &#123;</span><br><span class="line">        <span class="comment">//将父接口转为子接口</span></span><br><span class="line">        <span class="type">HttpServletRequest</span> <span class="variable">request</span> <span class="operator">=</span> (HttpServletRequest) req;</span><br><span class="line">        <span class="type">HttpServletResponse</span> <span class="variable">response</span> <span class="operator">=</span> (HttpServletResponse) rep;</span><br><span class="line">        <span class="comment">//获取请求方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">method</span> <span class="operator">=</span> request.getMethod();</span><br><span class="line">        <span class="comment">//解决post请求中文数据乱码问题</span></span><br><span class="line">        <span class="keyword">if</span>(method.equalsIgnoreCase(<span class="string">&quot;post&quot;</span>))&#123;</span><br><span class="line">            request.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理响应乱码</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        filterChain.doFilter(request,response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h2><h3 id="index-jsp"><a href="#index-jsp" class="headerlink" title="index.jsp"></a>index.jsp</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>显示省份列表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   省份列表：<span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;province&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">option</span>&gt;</span>请选择省份<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/jquery-3.3.1.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="comment">//页面加载完成发送异步ajax请求获取服务器端省份列表数据，并更新到页面上</span></span></span><br><span class="line"><span class="language-javascript">    $.<span class="title function_">ajax</span>(&#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">url</span>:<span class="string">&quot;SelectProvinceServlet&quot;</span>,<span class="comment">//servlet地址</span></span></span><br><span class="line"><span class="language-javascript">        <span class="attr">type</span>:<span class="string">&quot;post&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">dataType</span>:<span class="string">&quot;json&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">result</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">            <span class="comment">//result=[&#123;province&#125;,&#123;province&#125;,...]</span></span></span><br><span class="line"><span class="language-javascript">            <span class="keyword">if</span>(result.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span></span><br><span class="line"><span class="language-javascript">                <span class="comment">//获取有效的省份列表json数组对象数据</span></span></span><br><span class="line"><span class="language-javascript">                <span class="keyword">for</span>(<span class="keyword">var</span> province <span class="keyword">of</span> result)&#123;</span></span><br><span class="line"><span class="language-javascript">                    $(<span class="string">&quot;#province&quot;</span>).<span class="property">append</span></span></span><br><span class="line"><span class="language-javascript">(<span class="string">&quot;&lt;option value=&#x27;&quot;</span>+province.<span class="property">pid</span>+<span class="string">&quot;&#x27;&gt;&quot;</span>+province.<span class="property">pname</span>+<span class="string">&quot;&lt;/option&gt;&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">                &#125;</span></span><br><span class="line"><span class="language-javascript">            &#125;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">        &#125;,</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">error</span>:<span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           <span class="title function_">alert</span>(<span class="string">&quot;服务器忙。。。&quot;</span>);</span></span><br><span class="line"><span class="language-javascript">        &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;);</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="逻辑"><a href="#逻辑" class="headerlink" title="逻辑"></a>逻辑</h2><h3 id="SelectProvinceServelt"><a href="#SelectProvinceServelt" class="headerlink" title="SelectProvinceServelt"></a>SelectProvinceServelt</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.service.ProvinceService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(name = &quot;SelectProvinceServlet&quot;, urlPatterns = &quot;/SelectProvinceServlet&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SelectProvinceServlet</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">        doGet(request, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例业务类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ProvinceService</span> <span class="variable">provinceService</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProvinceService</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//调用业务逻辑层获取省份列表数据</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">jsonData</span> <span class="operator">=</span> provinceService.findProvinceList();</span><br><span class="line">            <span class="comment">//输出json数据给前端</span></span><br><span class="line">            response.getWriter().write(jsonData);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span>  <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);<span class="comment">//自动会去到错误回调函数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ProvinceService"><a href="#ProvinceService" class="headerlink" title="ProvinceService"></a>ProvinceService</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.fasterxml.jackson.databind.ObjectMapper;</span><br><span class="line"><span class="keyword">import</span> com.itheima.dao.ProvinceDao;</span><br><span class="line"><span class="keyword">import</span> com.itheima.model.Province;</span><br><span class="line"><span class="keyword">import</span> com.itheima.util.JedisUtil;</span><br><span class="line"><span class="keyword">import</span> redis.clients.jedis.Jedis;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 省份业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProvinceService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实例dao</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">ProvinceDao</span> <span class="variable">provinceDao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProvinceDao</span>();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取省份列表json数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> String</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">findProvinceList</span><span class="params">()</span><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">//1.先从redis里面获取省份列表数据json格式</span></span><br><span class="line">        <span class="type">Jedis</span> <span class="variable">jedis</span> <span class="operator">=</span> JedisUtil.getJedis();</span><br><span class="line">        <span class="type">String</span> <span class="variable">jsonData</span> <span class="operator">=</span> jedis.get(<span class="string">&quot;provinceList&quot;</span>);</span><br><span class="line">        <span class="comment">//2.判断json格式数据有效性</span></span><br><span class="line">        <span class="keyword">if</span>(jsonData==<span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1 json为空，说明redis里面没有数据，去数据库获取List集合数据</span></span><br><span class="line">            List&lt;Province&gt; provinceList = provinceDao.findProvinceList();</span><br><span class="line">            <span class="keyword">if</span>(provinceList!=<span class="literal">null</span> &amp;&amp; provinceList.size()&gt;<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//2.2 判断集合数据有效性，如果不为空，将集合数据转换为json数据</span></span><br><span class="line">                jsonData = <span class="keyword">new</span> <span class="title class_">ObjectMapper</span>().writeValueAsString(provinceList);</span><br><span class="line">                <span class="comment">//2.3 将最新的json写入redis，为了以后从redis中获取</span></span><br><span class="line">                jedis.set(<span class="string">&quot;provinceList&quot;</span>,jsonData);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//3.关闭jedis连接</span></span><br><span class="line">        jedis.close();</span><br><span class="line">        <span class="comment">//4.返回json</span></span><br><span class="line">        <span class="keyword">return</span> jsonData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="ProvinceDao"><a href="#ProvinceDao" class="headerlink" title="ProvinceDao"></a>ProvinceDao</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.model.Province;</span><br><span class="line"><span class="keyword">import</span> com.itheima.util.JdbcUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line"><span class="keyword">import</span> org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 省份数据访问类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProvinceDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">JdbcTemplate</span> <span class="variable">jdbcTemplate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JdbcTemplate</span>(JdbcUtils.getDataSource());</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取数据库省份列表</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> List&lt;Province&gt;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Province&gt; <span class="title function_">findProvinceList</span><span class="params">()</span><span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        String sql=<span class="string">&quot;SELECT * FROM province&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql,<span class="keyword">new</span> <span class="title class_">BeanPropertyRowMapper</span>&lt;Province&gt;(Province.class));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h1 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h1><h2 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>spring-boot-starter-redis<code>(springboot版本1.4版本前)</code><br>spring-boot-starter-data-redis<code>（1.4版本后）</code></p>
</blockquote>
<h2 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h2><p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/8cjxRZsXk7CEGIH.png"></p>
<h2 id="Redis事务"><a href="#Redis事务" class="headerlink" title="Redis事务"></a>Redis事务</h2><p><code>springboot 2.0之前</code>的版本，会发生在刚开始运行的时候<code>发送几次请求操作redis之后，后面被阻塞的情况</code>（<code>redis默认8个连接池</code>），原因是<code>针对打开事务支持的template，只是解绑了连接，根本没有做close的操作</code>。</p>
<blockquote>
<p>注：该问题只会出现在springboot 2.0之前的版本；<code>2.0之后</code>springboot连接Redis改成了<code>lettuce</code>，并重新实现，<code>问题已经不存在</code></p>
</blockquote>
<ul>
<li><code>@Transanctional注解支持Redis事务</code></li>
</ul>
<p><code>Spring中要使用@Transanctional首先要配transactionManager</code>，但是Spring没有专门针对Redis的事务管理器实现，而是所有调用RedisTemplate的方法最终都会调用到RedisConnctionUtils这个类的方法上面，在这个类里面会判断是不是进入到事务里面，也就是说<code>Redis的事务管理的功能是由RedisConnctionUtils内部实现的</code>。</p>
<blockquote>
<p>根据官方文档，要<code>想用Redis事务</code>，也<code>必须把JDBC捎上</code>。<code>POM文件</code>中<code>必须带上数据库的依赖</code></p>
</blockquote>
<h3 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h3><p>在Spring中要使用Redis注解式事务，首先要<code>设置RedisTemplate的enableTransactionSupport属性为true</code>，然后配置一个jdbc的<code>事务管理器</code>。这点非常重要，<code>一旦这样配置，所有使用这个template的Redis操作都必须走注解式事务，要不然会导致连接一直占用，不关闭。</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/vI8bH4sEzfQVXUn.png"></p>
<blockquote>
<p>注：此处代码使用<code>StringRedisTemplate</code>，可换为<code>RedisTemplate</code></p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/2z63QlvuaHGcmtg.png"></p>
<p>再次发送请求，无论点多少次，<code>Redis的连接数始终维持在1个不变</code>。在看程序的输出日志里面也发现了，<code>事务结束后连接被正常释放</code>。<code>因为使用了JDBC的事务管理器，所以还顺便做了一次数据库事务的开启和提交</code>。还有一点值得注意的是，跟数据库一样，使用注解来做事务管理，<code>Spring也会主动管理Redis事务的提交和回滚，也就是在之前发送一条MULTI命令，成功后发送EXEC，失败后发送DISCARD</code></p>
<h3 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h3><ul>
<li>升级到springboot 2.0以上版本，如果因为项目原因无法升级看下面的建议</li>
<li>如果使用Redis事务的场景不多，完全可以自己管理，不需要使用spring的注解式事务。如下面这样使用</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/30/Kh5ZHIfRjVQkXy9.png"></p>
<ul>
<li><p>如果一定要使用spring提供的注解式事务，建议初始化两个RedisTemplate Bean，分别设置enableTransactionSupport属性为true和false。针对需要事务和不需要事务的操作使用不同的template。</p>
</li>
<li><p>从个人角度，我不建议使用redis事务，因为redis对于事务的支持并不是关系型数据库那样满足ACID。<code>Redis事务只能保证ACID中的隔离性和一致性，无法保证原子性和持久性</code>。而我们使用事务最重要的一个理由就是原子性，这一点无法保证，事务的意义就去掉一大半了。所以事务的场景可以尝试通过业务代码来实现</p>
</li>
</ul>
<h2 id="StringRedisTemplate-和-RedisTemplate"><a href="#StringRedisTemplate-和-RedisTemplate" class="headerlink" title="StringRedisTemplate 和 RedisTemplate"></a>StringRedisTemplate 和 RedisTemplate</h2><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>主要是根据Redis存储的数据类型<code>需求决定</code>，<code>key一般都是String，但是value可能不一样，一般有两种，String和 Object</code>； </p>
<blockquote>
<ol>
<li>如果<code>k-v都是String类型</code>，我们可以直接用 <code>StringRedisTemplate</code>，这个是官方建议的，也是最方便的，<code>直接导入即用，无需多余配置</code>！ </li>
<li>如果<code>k-v是Object类型</code>，则需要自定义 <code>RedisTemplate</code></li>
</ol>
</blockquote>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><blockquote>
<p><code>注：RedisTemplate是线程安全的，开箱即用，可以在多个实例中重复使用</code></p>
</blockquote>
<ol>
<li>StringRedisTemplate继承了RedisTemplate。</li>
<li><code>RedisTemplate是一个泛型类</code>，而StringRedisTemplate则不是。</li>
<li>StringRedisTemplate只能对key&#x3D;String，value&#x3D;String的键值对进行操作，<code>RedisTemplate可以对任何类型的key-value键值对操作</code>。</li>
<li><code>各自序列化的方式不同，但最终都是得到了一个字节数组；</code> <code>StringRedisTemplate</code>使用的是<code>StringRedisSerializer类</code>；<code>RedisTemplate</code>使用的是<code>JdkSerializationRedisSerializer类</code>。<code>反序列化</code>，则是一个得到<code>String</code>，一个得到<code>Object</code></li>
</ol>
<h1 id="RedisTemplate用法"><a href="#RedisTemplate用法" class="headerlink" title="RedisTemplate用法"></a>RedisTemplate用法</h1><p>注：<code>TimeUnit</code>是<code>java.util.concurrent</code>包下面的一个类，表示<code>给定单元粒度的时间段</code></p>
<table>
<thead>
<tr>
<th align="center">常用的颗粒度常量</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">TimeUnit.DAYS</td>
<td align="center">天</td>
</tr>
<tr>
<td align="center">TimeUnit.HOURS</td>
<td align="center">小时</td>
</tr>
<tr>
<td align="center">TimeUnit.MINUTES</td>
<td align="center">分钟</td>
</tr>
<tr>
<td align="center">TimeUnit.SECONDS</td>
<td align="center">秒</td>
</tr>
</tbody></table>
<h2 id="String数据结构"><a href="#String数据结构" class="headerlink" title="String数据结构"></a>String数据结构</h2><p>操作String数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForValue()</span><br></pre></td></tr></table></figure>

<h3 id="Set设置"><a href="#Set设置" class="headerlink" title="Set设置"></a>Set设置</h3><blockquote>
<ul>
<li><code>set(K key, V value);</code></li>
</ul>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/GoCDezFpHJ48XWO.png"></p>
<blockquote>
<ul>
<li><code>set(K key, V value, long timeout, TimeUnit unit);</code></li>
</ul>
</blockquote>
<p>设置变量值的<code>过期时间</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/XbAxz1YmuGW4sRM.png"></p>
<blockquote>
<ul>
<li><code>set(K key, V value, long offset);</code></li>
</ul>
</blockquote>
<p>覆写(overwrite)给定 key 所储存的字符串值，<code>从指定位置开始的值</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Ut8qerGDANJlTVp.png"></p>
<blockquote>
<ul>
<li><code>setBit(K key, long offset, boolean value)</code></li>
</ul>
</blockquote>
<p>key键对应值的ascii码，将<code>offset(偏移)</code> (从左向右数)位置上的值变为value，<code>false为0，true为1</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template.opsForValue().set(<span class="string">&quot;bitTest&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27; 的ASCII码是 97。转换为二进制是：01100001</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27; 的ASCII码是 98  转换为二进制是：01100010</span></span><br><span class="line"><span class="comment">// &#x27;c&#x27; 的ASCII码是 99  转换为二进制是：01100011</span></span><br><span class="line"><span class="comment">//因为二进制只有0和1，因此我要变为&#x27;b&#x27;的话第六位设置为1，第七位设置为0</span></span><br><span class="line">template.opsForValue().setBit(<span class="string">&quot;bitTest&quot;</span>,<span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">template.opsForValue().setBit(<span class="string">&quot;bitTest&quot;</span>,<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(template.opsForValue().get(<span class="string">&quot;bitTest&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：b</span></span><br></pre></td></tr></table></figure>




<blockquote>
<ul>
<li><code>setIfAbsent(K key, V value)</code></li>
</ul>
</blockquote>
<p>先<code>判断Key是否存在</code>，不存在则新增并返回true；存在则返回false</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForValue().setIfAbsent(<span class="string">&quot;multi1&quot;</span>,<span class="string">&quot;multi1&quot;</span>));    </span><br><span class="line">System.out.println(template.opsForValue().setIfAbsent(<span class="string">&quot;multi111&quot;</span>,<span class="string">&quot;multi111&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// false  multi1之前已经存在</span></span><br><span class="line"><span class="comment">// true  multi111之前不存在</span></span><br></pre></td></tr></table></figure>




<blockquote>
<ul>
<li><code>multiSet(Map&lt;? extends K,? extends V&gt; map)</code></li>
</ul>
</blockquote>
<p><code>设置map集合到redis</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/doOcmXE6s52vKMJ.png"></p>
<blockquote>
<ul>
<li><code>multiSetIfAbsent(Map&lt;? extends K,? extends V&gt; map)</code></li>
</ul>
</blockquote>
<p>设置map集合到redis，如果map<code>存在则返回false</code>，<code>不存在则创建并返回true</code></p>
<h3 id="Get获取"><a href="#Get获取" class="headerlink" title="Get获取"></a>Get获取</h3><blockquote>
<ul>
<li><code>get(Object key);</code></li>
</ul>
</blockquote>
<p><code>获取</code>key键对应的值。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/NiWsF5e4r6MzOxK.png"></p>
<blockquote>
<ul>
<li><code>get(K key, long start, long end)</code></li>
</ul>
</blockquote>
<p><code>截取</code>key键对应值得字符串，从开始下标位置开始到结束下标的位置(包含结束下标)的字符串</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/G2LsPtYmTkiIvpK.png"></p>
<blockquote>
<ul>
<li><code>getBit(K key, long offset)</code></li>
</ul>
</blockquote>
<p><code>获取键对应值的ascii码</code>，在offset处的位值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template.opsForValue().set(<span class="string">&quot;bitTest&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line"><span class="comment">// &#x27;a&#x27; 的ASCII码是 97。转换为二进制是：01100001</span></span><br><span class="line"><span class="comment">// &#x27;b&#x27; 的ASCII码是 98  转换为二进制是：01100010</span></span><br><span class="line"><span class="comment">// &#x27;c&#x27; 的ASCII码是 99  转换为二进制是：01100011</span></span><br><span class="line"><span class="comment">//因为二进制只有0和1，因此我要变为&#x27;b&#x27;的话第六位设置为1，第七位设置为0</span></span><br><span class="line">template.opsForValue().setBit(<span class="string">&quot;bitTest&quot;</span>,<span class="number">6</span>, <span class="literal">true</span>);</span><br><span class="line">template.opsForValue().setBit(<span class="string">&quot;bitTest&quot;</span>,<span class="number">7</span>, <span class="literal">false</span>);</span><br><span class="line">System.out.println(template.opsForValue().getBit(<span class="string">&quot;bitTest&quot;</span>,<span class="number">7</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果：false</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>getAndSet(K key, V value);</code></li>
</ul>
</blockquote>
<p><code>设置</code>键的字符串值<code>并返回</code>其旧值</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/2b1mDWBYN6wkqXP.png"></p>
<blockquote>
<ul>
<li><code>multiGet(Collection&lt;K&gt; keys)</code></li>
</ul>
</blockquote>
<p>根据集合取出对应的value值。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/xOmGrwEVRld2hjF.png"></p>
<h3 id="Append-追加、Size长度"><a href="#Append-追加、Size长度" class="headerlink" title="Append 追加、Size长度"></a>Append 追加、Size长度</h3><blockquote>
<ul>
<li><code>append Integer append(K key, String value);</code></li>
</ul>
</blockquote>
<ol>
<li>如果key<code>已经存</code>在并且是一个字符串，则该命令将该值<code>追加到字符串的末尾</code>。</li>
<li>如果键<code>不存在</code>，则它被<code>创建并设置为空字符串</code>，因此APPEND在这种特殊情况下将<code>类似于SET</code>。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/jRvdKrq2NLix8nF.png"></p>
<blockquote>
<ul>
<li><code>size Long size(K key);</code></li>
</ul>
</blockquote>
<p><code>返回</code>key所对应的<code>value值得长度</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/ilZLvzAFxMYQcG5.png"></p>
<h3 id="increment-增量"><a href="#increment-增量" class="headerlink" title="increment 增量"></a>increment 增量</h3><blockquote>
<ul>
<li><code>increment(K key, double delta)</code></li>
</ul>
</blockquote>
<p>以<code>增量</code>的方式将<code>double值</code>存储在变量中</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/WERvJysCTImiMQu.png"></p>
<blockquote>
<ul>
<li><code>increment(K key, long delta)</code></li>
</ul>
</blockquote>
<p>以<code>增量</code>的方式将<code>long值</code>存储在变量中</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Q1nX5Kijdm98sgw.png"></p>
<h2 id="List数据结构"><a href="#List数据结构" class="headerlink" title="List数据结构"></a>List数据结构</h2><p>操作List数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForList()</span><br></pre></td></tr></table></figure>

<h3 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h3><blockquote>
<ul>
<li><code>Long leftPush(K key, V value);</code></li>
</ul>
</blockquote>
<p>将所有指定的值，<code>从左边插入存储在键列表的头部</code>。如果<code>键不存在</code>，则先将其<code>创建为空列表再插入</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/IQVdGaDJrwKMzpZ.png"></p>
<blockquote>
<ul>
<li><code>Long leftPushAll(K key, V... values);</code></li>
</ul>
</blockquote>
<p><code>批量</code>把一个<code>数组</code>各元素<code>从左边插入</code>到列表中</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/X8OcWjGYabAfPBn.png"></p>
<blockquote>
<ul>
<li><code>Long leftPushIfPresent(K key, V value);</code></li>
</ul>
</blockquote>
<p>只有当<code>key存在时</code>才将value插入到列表中，并<code>返回列表长度</code>；当key<code>不存在时</code>，<code>不会创建Key并返回0</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForList().leftPushIfPresent(<span class="string">&quot;leftPushIfPresent&quot;</span>,<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">System.out.println(template.opsForList().leftPushIfPresent(<span class="string">&quot;leftPushIfPresent&quot;</span>,<span class="string">&quot;bb&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForList().leftPush(<span class="string">&quot;leftPushIfPresent&quot;</span>,<span class="string">&quot;aa&quot;</span>));</span><br><span class="line">System.out.println(template.opsForList().leftPushIfPresent(<span class="string">&quot;leftPushIfPresent&quot;</span>,<span class="string">&quot;bb&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>Long rightPush(K key, V value);</code></li>
</ul>
</blockquote>
<p>将所有<code>指定的值</code>，<code>从右边插入</code>存储在键列表的头部。如果<code>键不存在</code>，则先将其<code>创建为空列表再插入</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/wfc4qptReFjsZah.png"></p>
<blockquote>
<ul>
<li><code>Long rightPushAll(K key, V... values);</code></li>
</ul>
</blockquote>
<p><code>批量</code>把一个<code>数组</code>各元素<code>从右边插入</code>到列表中</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/qmlMYhuJazScdX5.png"></p>
<blockquote>
<ul>
<li><code>void set(K key, long index, V value);</code></li>
</ul>
</blockquote>
<p>在列表中<code>index的位置设置value值</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/yj8xar5VYpTdeKO.png"></p>
<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><blockquote>
<ul>
<li><code>List&lt;V&gt; range(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>从指定偏移开始到偏移结束，<code>返回</code>存储在键中的列表的<code>指定元素</code>。索引从零开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"><span class="comment">// [c#, c++, python, java, c#, c#]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>V index(K key, long index);</code></li>
</ul>
</blockquote>
<p>根据下标获取列表中的值，下标从0开始</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/BK6JA1Ii2OZWSm7.png"></p>
<blockquote>
<ul>
<li><code>Long size(K key);</code></li>
</ul>
</blockquote>
<p><code>返回</code>存储在键中的列表的<code>长度</code>。如果键不存在，则将其解释为空列表，并返回0。<code>当key存储的值不是列表时返回错误</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/b2FRNtiZVUWHacC.png"></p>
<h3 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h3><blockquote>
<ul>
<li><code>void trim(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>从键中指定偏移开始至偏移结束来截取元素，索引从0开始</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">template.opsForList().trim(<span class="string">&quot;list&quot;</span>,<span class="number">1</span>,-<span class="number">1</span>);<span class="comment">//从偏移1开始截取到最后偏移位置</span></span><br><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [c#, c++, python, java, c#, c#]</span></span><br><span class="line"><span class="comment">// [c++, python, java, c#, c#]</span></span><br></pre></td></tr></table></figure>


<h3 id="移除"><a href="#移除" class="headerlink" title="移除"></a>移除</h3><blockquote>
<ul>
<li><code>Long remove(K key, long count, Object value);</code></li>
</ul>
</blockquote>
<ol>
<li><code>count &gt; 0</code>：从<code>头到尾</code>查找键列表，删除第一个等于value的元素。</li>
<li><code>count &lt; 0</code>：从<code>尾到头</code>查找键列表，删除第一个等于value的元素</li>
<li><code>count = 0</code>：删除等于value的<code>所有元素</code></li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/JSckfynuqweP16b.png"></p>
<blockquote>
<ul>
<li><code>V leftPop(K key);</code></li>
</ul>
</blockquote>
<p><code>移除最左边</code>的一个元素，返回此元素</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/esY8EAdXiKqnHNJ.png"></p>
<blockquote>
<ul>
<li><code>V leftPop(K key, long timeout, TimeUnit unit);</code></li>
</ul>
</blockquote>
<p><code>移除最左边</code>的一个元素，返回此元素；如果列表<code>没有元素会一直阻塞列表，直到等待超时或发现可弹出元素为止</code></p>
<blockquote>
<ul>
<li><code>V rightPop(K key);</code></li>
</ul>
</blockquote>
<p><code>移除最右边</code>的一个元素，返回此元素</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/mcYhZpf1XTLraot.png"></p>
<blockquote>
<ul>
<li><code>V rightPop(K key, long timeout, TimeUnit unit);</code></li>
</ul>
</blockquote>
<p><code>移除最右边</code>的一个元素，返回此元素，如果列表<code>没有元素会一直阻塞列表，直到等待超时或发现可弹出元素为止</code></p>
<blockquote>
<ul>
<li><code>V rightPopAndLeftPush(K sourceKey, K destinationKey);</code></li>
</ul>
</blockquote>
<p>用于<code>移除第一个列表的最后一个元素</code>，并<code>将该元素添加到第二个列表</code>，并<code>返回第一个列表数据</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">template.opsForList().rightPopAndLeftPush(<span class="string">&quot;list&quot;</span>,<span class="string">&quot;rightPopAndLeftPush&quot;</span>);</span><br><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;list&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">System.out.println(template.opsForList().range(<span class="string">&quot;rightPopAndLeftPush&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [oc, java,c#]</span></span><br><span class="line"><span class="comment">// [oc, java]</span></span><br><span class="line"><span class="comment">// [c#]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>V rightPopAndLeftPush(K sourceKey, K destinationKey, long timeout, TimeUnit unit);</code></li>
</ul>
</blockquote>
<p>用于<code>移除第一个列表的最后一个元素</code>，并<code>将该元素添加到第二个列表并返回第一个列表数据</code>，如果列表<code>没有元素会一直阻塞列表，直到等待超时或发现可弹出元素为止</code></p>
<h2 id="Hash数据机构"><a href="#Hash数据机构" class="headerlink" title="Hash数据机构"></a>Hash数据机构</h2><p>操作Hash数据，相当于无序键值对集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForHash()</span><br></pre></td></tr></table></figure>

<h3 id="设置-1"><a href="#设置-1" class="headerlink" title="设置"></a>设置</h3><blockquote>
<ul>
<li><code>void putAll(H key, Map&lt;? extends HK, ? extends HV&gt; m);</code></li>
</ul>
</blockquote>
<p>使用<code>map</code>中提供的<code>多个散列字段</code>设置到<code>key对应的散列表中</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/lPh5zQoJDnKfvXN.png"></p>
<blockquote>
<ul>
<li><code>void put(H key, HK hashKey, HV value);</code></li>
</ul>
</blockquote>
<p>给<code>指定key设置散列hashKey的值</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/pF62tKJkIo5dzmA.png"></p>
<h3 id="获取-1"><a href="#获取-1" class="headerlink" title="获取"></a>获取</h3><blockquote>
<ul>
<li><code>Map&lt;HK, HV&gt; entries(H key);</code></li>
</ul>
</blockquote>
<p>获取<code>整个哈希存储</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/7VWXYeMj8Po3h9A.png"></p>
<blockquote>
<ul>
<li><code>List&lt;HV&gt; values(H key);</code></li>
</ul>
</blockquote>
<p>获取<code>整个哈希存储的值</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/5GXbxn1v4WTPIei.png"></p>
<blockquote>
<ul>
<li><code>HV get(H key, Object hashKey);</code></li>
</ul>
</blockquote>
<p>从哈希中<code>获取指定Key的值</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/6OGI135cRQMLJeN.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;HK&gt; keys(H key);</code></li>
</ul>
</blockquote>
<p>获取哈希中<code>所有的key</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/FRn9yBmzbpX3loG.png"></p>
<blockquote>
<ul>
<li><code>Long size(H key);</code></li>
</ul>
</blockquote>
<p>获取哈希中所对应散列表<code>key的个数</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/bBOWv6pcXP5lAQq.png"></p>
<blockquote>
<ul>
<li><code>Cursor&lt;Map.Entry&lt;HK, HV&gt;&gt; scan(H key, ScanOptions options);</code></li>
</ul>
</blockquote>
<p>使用Cursor在key的hash中迭代，相当于<code>迭代器</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/NMSD6atR3HPZ8Fy.png"></p>
<h3 id="移除-1"><a href="#移除-1" class="headerlink" title="移除"></a>移除</h3><blockquote>
<ul>
<li><code>Long delete(H key, Object... hashKeys);</code></li>
</ul>
</blockquote>
<p><code>删除</code>哈希中<code>指定的Key</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Hw3ibvZuNBVMtLl.png"></p>
<h3 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h3><blockquote>
<ul>
<li><code>Boolean hasKey(H key, Object hashKey);</code></li>
</ul>
</blockquote>
<p><code>判断</code>指定的<code>Key</code>在哈希中<code>是否存在</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/qJHPLCl4bhsu7SF.png"></p>
<h2 id="Set数据结构"><a href="#Set数据结构" class="headerlink" title="Set数据结构"></a>Set数据结构</h2><p>操作<code>Set数据</code>，相当于<code>无序集合</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForSet()</span><br></pre></td></tr></table></figure>

<h3 id="设置-2"><a href="#设置-2" class="headerlink" title="设置"></a>设置</h3><blockquote>
<ul>
<li><code>Long add(K key, V... values);</code></li>
</ul>
</blockquote>
<p>无序集合中添加元素，<code>返回添加个数</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/MRq5gmBzesvTPJc.png"></p>
<p>也可以直接在add里面<code>添加多个值</code> 如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">template.opsForSet().add(<span class="string">&quot;setTest&quot;</span>,<span class="string">&quot;aaa&quot;</span>,<span class="string">&quot;bbb&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="获取-2"><a href="#获取-2" class="headerlink" title="获取"></a>获取</h3><blockquote>
<ul>
<li><code>Long size(K key);</code></li>
</ul>
</blockquote>
<p>获取无序集合的<code>长度</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/AstRD7zMK65fyiO.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; members(K key);</code></li>
</ul>
</blockquote>
<p><code>返回</code>集合中的<code>所有成员</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/HNvxm6EFUkTdXuh.png"></p>
<blockquote>
<ul>
<li><code>V randomMember(K key);</code></li>
</ul>
</blockquote>
<p><code>随机获取</code>key无序集合中的一个元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;setTestrandomMember:&quot;</span> + template.opsForSet().randomMember(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;setTestrandomMember:&quot;</span> + template.opsForSet().randomMember(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;setTestrandomMember:&quot;</span> + template.opsForSet().randomMember(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;setTestrandomMember:&quot;</span> + template.opsForSet().randomMember(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTestrandomMember:aaa</span></span><br><span class="line"><span class="comment">// setTestrandomMember:bbb</span></span><br><span class="line"><span class="comment">// setTestrandomMember:aaa</span></span><br><span class="line"><span class="comment">// setTestrandomMember:ddd</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>List&lt;V&gt; randomMembers(K key, long count);</code></li>
</ul>
</blockquote>
<p><code>获取多个key</code>无序集合中的元素（<code>不去重</code>），<code>count表示个数</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;randomMembers:&quot;</span> + template.opsForSet().randomMembers(<span class="string">&quot;setTest&quot;</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// randomMembers:[ccc, bbb, ddd, ddd, aaa]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Set&lt;V&gt; distinctRandomMembers(K key, long count);</code></li>
</ul>
</blockquote>
<p><code>获取key</code>无序集合中的元素（<code>去重</code>），<code>count表示个数</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;randomMembers:&quot;</span> + template.opsForSet().distinctRandomMembers(<span class="string">&quot;setTest&quot;</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// randomMembers:[aaa, bbb, ddd, ccc]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><code>Cursor&lt;V&gt; scan(K key, ScanOptions options);</code></li>
</ul>
</blockquote>
<p>遍历set</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/6XmiuqrLj9IbdWn.png"></p>
<h3 id="移除-2"><a href="#移除-2" class="headerlink" title="移除"></a>移除</h3><blockquote>
<ul>
<li><code>Long remove(K key, Object... values);</code></li>
</ul>
</blockquote>
<p><code>移除</code>集合中<code>一个或多个成员</code>，<code>返回移除个数</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/2diWQ58cbZylsH7.png"></p>
<blockquote>
<ul>
<li><code>V pop(K key);</code></li>
</ul>
</blockquote>
<p><code>随机移除一个元素</code>，并<code>返回此元素</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/WKzqvNbYUu3xdyp.png"></p>
<h3 id="移动"><a href="#移动" class="headerlink" title="移动"></a>移动</h3><blockquote>
<ul>
<li><code>Boolean move(K key, V value, K destKey);</code></li>
</ul>
</blockquote>
<p>将key中的元素value移动到 destKey中</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/JrgGUkpqm6t7c8I.png"></p>
<h3 id="判断-1"><a href="#判断-1" class="headerlink" title="判断"></a>判断</h3><blockquote>
<ul>
<li><code>Boolean isMember(K key, Object o);</code></li>
</ul>
</blockquote>
<p>判断<code>member</code>元素<code>是否是集合 key 的成员</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/VCjNGw4QLiumgKD.png"></p>
<h3 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h3><blockquote>
<ul>
<li><code>Set&lt;V&gt; intersect(K key, K otherKey);</code></li>
</ul>
</blockquote>
<p>求key无序集合与otherKey无序集合的交集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/1crqiSkJb3xoyef.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; intersect(K key, Collection&lt;K&gt; otherKeys);</code></li>
</ul>
</blockquote>
<p>求key无序集合与多个otherKey无序集合的交集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/8yVYuUg4aHrFA1d.png"></p>
<blockquote>
<ul>
<li><code>Long intersectAndStore(K key, K otherKey, K destKey);</code></li>
</ul>
</blockquote>
<p>求key无序集合与otherKey无序集合的交集，并<code>把值存储到destKey无序集合中</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line">System.out.println(template.opsForSet().intersectAndStore(<span class="string">&quot;setTest&quot;</span>,<span class="string">&quot;setTest2&quot;</span>,<span class="string">&quot;destKey1&quot;</span>));</span><br><span class="line">System.out.println(template.opsForSet().members(<span class="string">&quot;destKey1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [aaa, ccc]</span></span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);</code></li>
</ul>
</blockquote>
<p>求key无序集合与<code>多个otherKey</code>无序集合的交集，并把值存储到destKey无序集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest3:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest3&quot;</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">strlist.add(<span class="string">&quot;setTest2&quot;</span>);</span><br><span class="line">strlist.add(<span class="string">&quot;setTest3&quot;</span>);</span><br><span class="line">System.out.println(template.opsForSet().intersectAndStore(<span class="string">&quot;setTest&quot;</span>,strlist,<span class="string">&quot;destKey2&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForSet().members(<span class="string">&quot;destKey2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// setTest3:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// [aaa, ccc]</span></span><br></pre></td></tr></table></figure>

<h3 id="并集"><a href="#并集" class="headerlink" title="并集"></a>并集</h3><blockquote>
<ul>
<li><code>Set&lt;V&gt; union(K key, K otherKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与otherKey无序集合的并集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/lHpOQqLXi7ICv2o.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; union(K key, Collection&lt;K&gt; otherKeys);</code></li>
</ul>
</blockquote>
<p>key无序集合与<code>多个otherKey</code>无序集合的并集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/uS7p1tbAWiqnMTf.png"></p>
<blockquote>
<ul>
<li><code>Long unionAndStore(K key, K otherKey, K destKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与otherkey无序集合的并集，并<code>把值存储到destKey无序集合中</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForSet().unionAndStore(<span class="string">&quot;setTest&quot;</span>,<span class="string">&quot;setTest2&quot;</span>,<span class="string">&quot;unionAndStoreTest1&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;unionAndStoreTest1:&quot;</span> + template.opsForSet().members(<span class="string">&quot;unionAndStoreTest1&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// unionAndStoreTest1:[ccc, aaa, ddd, bbb]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与<code>多个otherkey</code>无序集合的并集，并把<code>值存储到destKey无序集合</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest3:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest3&quot;</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">strlist.add(<span class="string">&quot;setTest2&quot;</span>);</span><br><span class="line">strlist.add(<span class="string">&quot;setTest3&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForSet().unionAndStore(<span class="string">&quot;setTest&quot;</span>,strlist,<span class="string">&quot;unionAndStoreTest2&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;unionAndStoreTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;unionAndStoreTest2&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// setTest3:[xxx, ccc, aaa]</span></span><br><span class="line"><span class="comment">// 5</span></span><br><span class="line"><span class="comment">// unionAndStoreTest2:[ddd, xxx, bbb, aaa, ccc]</span></span><br></pre></td></tr></table></figure>


<h3 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h3><blockquote>
<ul>
<li><code>Set&lt;V&gt; difference(K key, K otherKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与otherKey无序集合的差集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/epkbGuE6PBYoASc.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; difference(K key, Collection&lt;K&gt; otherKeys);</code></li>
</ul>
</blockquote>
<p>key无序集合与<code>多个otherKey</code>无序集合的差集</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/poYrfbFq7adBUEQ.png"></p>
<blockquote>
<ul>
<li><code>Long differenceAndStore(K key, K otherKey, K destKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与otherkey无序集合的差集，并<code>把值存储到destKey无序集合</code>中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForSet().differenceAndStore(<span class="string">&quot;setTest&quot;</span>,<span class="string">&quot;setTest2&quot;</span>,<span class="string">&quot;differenceAndStore1&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;differenceAndStore1:&quot;</span> + template.opsForSet().members(<span class="string">&quot;differenceAndStore1&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// differenceAndStore1:[bbb, ddd]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Long differenceAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);</code></li>
</ul>
</blockquote>
<p>key无序集合与<code>多个otherkey</code>无序集合的差集，并把值存储到destKey无序集合中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">&quot;setTest:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest2&quot;</span>));</span><br><span class="line">System.out.println(<span class="string">&quot;setTest3:&quot;</span> + template.opsForSet().members(<span class="string">&quot;setTest3&quot;</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; strlist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">strlist.add(<span class="string">&quot;setTest2&quot;</span>);</span><br><span class="line">strlist.add(<span class="string">&quot;setTest3&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForSet().differenceAndStore(<span class="string">&quot;setTest&quot;</span>,strlist,<span class="string">&quot;differenceAndStore2&quot;</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;differenceAndStore2:&quot;</span> + template.opsForSet().members(<span class="string">&quot;differenceAndStore2&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// setTest:[ddd, bbb, aaa, ccc]</span></span><br><span class="line"><span class="comment">// setTest2:[ccc, aaa]</span></span><br><span class="line"><span class="comment">// setTest3:[xxx, ccc, aaa]</span></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// differenceAndStore2:[bbb, ddd]</span></span><br></pre></td></tr></table></figure>


<h2 id="ZSet数据结构"><a href="#ZSet数据结构" class="headerlink" title="ZSet数据结构"></a>ZSet数据结构</h2><p>操作ZSet数据，相当于<code>有序集合</code>，有序集成员<code>按分数值递增(从小到大)</code>顺序排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">redisTemplate.opsForZSet()</span><br></pre></td></tr></table></figure>

<h3 id="设置-3"><a href="#设置-3" class="headerlink" title="设置"></a>设置</h3><blockquote>
<ul>
<li><code>Boolean add(K key, V value, double score);</code></li>
</ul>
</blockquote>
<p>新增一个有序集合并设置分值score，<code>存在</code>的话为<code>false</code>，<code>不存在</code>的话为<code>true</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/9XYjOWzKyuB2QaE.png"></p>
<blockquote>
<ul>
<li><code>Long add(K key, Set&lt;TypedTuple&lt;V&gt;&gt; tuples);</code></li>
</ul>
</blockquote>
<p>新增一个有序集合</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/sEVjLHhoZzQSyq4.png"></p>
<blockquote>
<ul>
<li><code>Double incrementScore(K key, V value, double delta);</code></li>
</ul>
</blockquote>
<p>增加元素的score值，并返回增加后的值</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/5UXnq7uDRvs8jJd.png"></p>
<h3 id="获取-3"><a href="#获取-3" class="headerlink" title="获取"></a>获取</h3><blockquote>
<ul>
<li><code>Set&lt;V&gt; range(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>通过索引区间<code>返回</code>有序集合成<code>指定区间内的成员</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Db7jYWL8vKenZti.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; reverseRange(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>通过索引区间<code>返回</code>有序集合成<code>指定区间内的成员</code>，其中有序集成员按分数值递减<code>(从大到小)顺序排列</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Qs92UIMgOGj6qhw.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeWithScores(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>通过索引区间<code>返回</code>有序集合成<code>指定区间内的成员对象</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(<span class="string">&quot;zset1&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot; score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-2 score:1.2</span></span><br><span class="line"><span class="comment">// value:zset-1 score:2.2</span></span><br><span class="line"><span class="comment">// value:zset-3 score:2.3</span></span><br><span class="line"><span class="comment">// value:zset-4 score:6.6</span></span><br><span class="line"><span class="comment">// value:zset-5 score:9.6</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeWithScores(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p><code>与rangeWithScores调用方法一样</code>，其中有序集成员按分数值递减(从大到小)顺序排列</p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; rangeByScore(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p>通过<code>分数</code>返回有序集合<code>指定区间内的成员</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/VbDBYIEpyOGleju.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p>通过<code>分数</code>返回有序集合<code>指定区间内的成员对象</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;zset1&quot;</span>,<span class="number">0</span>,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot; score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-2 score:1.2</span></span><br><span class="line"><span class="comment">// value:zset-1 score:2.2</span></span><br><span class="line"><span class="comment">// value:zset-3 score:2.3</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p><code>与rangeByScoreWithScores调用方法一样</code>，其中有序集成员按分数值递减(从大到小)顺序排列</p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; rangeByScore(K key, double min, double max, long offset, long count);</code></li>
</ul>
</blockquote>
<p>通过<code>分数</code>返回有序集合<code>指定区间内的成员</code>，并在<code>索引范围内</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/zoKW9xSacnf1pkZ.png"></p>
<blockquote>
<ul>
<li><code>Set&lt;V&gt; reverseRangeByScore(K key, double min, double max, long offset, long count);</code></li>
</ul>
</blockquote>
<p><code>与rangeByScore调用方法一样</code>，其中有序集成员按分数值递减(从大到小)顺序排列</p>
<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; rangeByScoreWithScores(K key, double min, double max, long offset, long count);</code></li>
</ul>
</blockquote>
<p>通过<code>分数</code>返回有序集合<code>指定区间内的成员对象</code>，并在<code>索引范围内</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeByScoreWithScores(<span class="string">&quot;zset1&quot;</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot; score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-1 score:2.2</span></span><br><span class="line"><span class="comment">// value:zset-3 score:2.3</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Set&lt;TypedTuple&lt;V&gt;&gt; reverseRangeByScoreWithScores(K key, double min, double max, long offset, long count); </code></li>
</ul>
</blockquote>
<p><code>与rangeByScoreWithScores调用方法一样</code>，其中有序集成员按分数值递减(从大到小)顺序排列</p>
<blockquote>
<ul>
<li><code>Long rank(K key, Object o);</code></li>
</ul>
</blockquote>
<p>返回有序集中<code>指定成员的排名</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/wRsJB8nQ4aFXCK7.png"></p>
<blockquote>
<ul>
<li><code>Long reverseRank(K key, Object o);</code></li>
</ul>
</blockquote>
<p>返回有序集中<code>指定成员的排名</code>，其中有序集成员按分数值递减<code>(从大到小)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForZSet().range(<span class="string">&quot;zset1&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>));</span><br><span class="line">System.out.println(template.opsForZSet().reverseRank(<span class="string">&quot;zset1&quot;</span>,<span class="string">&quot;zset-2&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [zset-5, zset-4, zset-3, zset-1, zset-2]</span></span><br><span class="line"><span class="comment">// 4 //递减之后排到第五位去了</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Set&lt;V&gt; rangeByScore(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p>通过<code>分数</code>返回有序集合<code>指定区间内的成员</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForZSet().rangeByScore(<span class="string">&quot;zset1&quot;</span>,<span class="number">0</span>,<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// [zset-2, zset-1, zset-3]</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Long zCard(K key);</code></li>
</ul>
</blockquote>
<p>获取有序集合的成员数</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/PJFKHSEyOUusxrQ.png"></p>
<blockquote>
<ul>
<li><code>Long count(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p>通过<code>分数返回</code>有序集合指定区间内的<code>成员个数</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/jqocYwxaXKinCHe.png"></p>
<blockquote>
<ul>
<li><code>Long size(K key);</code></li>
</ul>
</blockquote>
<p><code>获取有序集合的成员数</code>，内部调用的就是zCard方法</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Y7nSpOshMXbjyBf.png"></p>
<blockquote>
<ul>
<li><code>Double score(K key, Object o);</code></li>
</ul>
</blockquote>
<p>获取指定成员的score值</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/2XdJAqWMVwc315m.png"></p>
<blockquote>
<ul>
<li><code>Cursor&lt;TypedTuple&lt;V&gt;&gt; scan(K key, ScanOptions options);</code></li>
</ul>
</blockquote>
<p>遍历zset</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Cursor&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; cursor = template.opsForZSet().scan(<span class="string">&quot;zzset1&quot;</span>, ScanOptions.NONE);</span><br></pre></td></tr></table></figure>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Wae5vY1QzOHBw4n.png"></p>
<h3 id="移除-3"><a href="#移除-3" class="headerlink" title="移除"></a>移除</h3><blockquote>
<ul>
<li><code>Long remove(K key, Object... values);</code></li>
</ul>
</blockquote>
<p>从有序集合中<code>移除一个或者多个元素</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/GNXcSbd3EJx1ZWn.png"></p>
<blockquote>
<ul>
<li><code>Long removeRange(K key, long start, long end);</code></li>
</ul>
</blockquote>
<p>移除指定索引位置的成员，其中有序集成员按分数值递增(从小到大)顺序排列</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/fJHjLQdCVrDAFmw.png"></p>
<blockquote>
<ul>
<li><code>Long removeRangeByScore(K key, double min, double max);</code></li>
</ul>
</blockquote>
<p>根据<code>指定的score值范围来移除成员</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/lLimOFnh5IKvHyq.png"></p>
<h3 id="并集-1"><a href="#并集-1" class="headerlink" title="并集"></a>并集</h3><blockquote>
<ul>
<li><code>Long unionAndStore(K key, K otherKey, K destKey);</code></li>
</ul>
</blockquote>
<p>求key有序集和otherKey有序集的并集，并把值存储在新的 destKey中，<code>key相同的话会把score值相加</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zset-2&quot;</span>,<span class="number">2.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zset-3&quot;</span>,<span class="number">3.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zset-4&quot;</span>,<span class="number">6.0</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;zset-2&quot;</span>,<span class="number">2.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;zset-3&quot;</span>,<span class="number">3.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;zset-4&quot;</span>,<span class="number">6.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;zset-5&quot;</span>,<span class="number">7.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().unionAndStore(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;destZset11&quot;</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(<span class="string">&quot;destZset11&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot;score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-1score:2.0</span></span><br><span class="line"><span class="comment">// value:zset-2score:4.0</span></span><br><span class="line"><span class="comment">// value:zset-3score:6.0</span></span><br><span class="line"><span class="comment">// value:zset-5score:7.0</span></span><br><span class="line"><span class="comment">// value:zset-4score:12.0</span></span><br></pre></td></tr></table></figure>



<blockquote>
<ul>
<li><code>Long unionAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);</code></li>
</ul>
</blockquote>
<p>求key有序集和<code>多个有序集</code>的并集，并把值存储在新的 destKey中，<code>key相同的话会把score值相加</code>，其中有序集成员按分数值递增<code>(从小到大)顺序排列</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset3&quot;</span>,<span class="string">&quot;zset-1&quot;</span>,<span class="number">1.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset3&quot;</span>,<span class="string">&quot;zset-2&quot;</span>,<span class="number">2.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset3&quot;</span>,<span class="string">&quot;zset-3&quot;</span>,<span class="number">3.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset3&quot;</span>,<span class="string">&quot;zset-4&quot;</span>,<span class="number">6.0</span>));</span><br><span class="line">System.out.println(template.opsForZSet().add(<span class="string">&quot;zzset3&quot;</span>,<span class="string">&quot;zset-5&quot;</span>,<span class="number">7.0</span>));</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;zzset2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;zzset3&quot;</span>);</span><br><span class="line">System.out.println(template.opsForZSet().unionAndStore(<span class="string">&quot;zzset1&quot;</span>,stringList,<span class="string">&quot;destZset22&quot;</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(<span class="string">&quot;destZset22&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot;score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-1score:3.0</span></span><br><span class="line"><span class="comment">// value:zset-2score:6.0</span></span><br><span class="line"><span class="comment">// value:zset-3score:9.0</span></span><br><span class="line"><span class="comment">// value:zset-5score:14.0</span></span><br><span class="line"><span class="comment">// value:zset-4score:18.0</span></span><br></pre></td></tr></table></figure>




<h3 id="交集-1"><a href="#交集-1" class="headerlink" title="交集"></a>交集</h3><blockquote>
<ul>
<li><code>Long intersectAndStore(K key, K otherKey, K destKey);</code></li>
</ul>
</blockquote>
<p>求key有序集合和otherKey有序集的交集，并将结果集存储在新的destKey有序集合中，key相同的话会把score值相加，其中有序集成员按分数值递增(从小到大)顺序排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(template.opsForZSet().intersectAndStore(<span class="string">&quot;zzset1&quot;</span>,<span class="string">&quot;zzset2&quot;</span>,<span class="string">&quot;destZset33&quot;</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(<span class="string">&quot;destZset33&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot;score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-1score:2.0</span></span><br><span class="line"><span class="comment">// value:zset-2score:4.0</span></span><br><span class="line"><span class="comment">// value:zset-3score:6.0</span></span><br><span class="line"><span class="comment">// value:zset-4score:12.0</span></span><br></pre></td></tr></table></figure>


<blockquote>
<ul>
<li><code>Long intersectAndStore(K key, Collection&lt;K&gt; otherKeys, K destKey);</code></li>
</ul>
</blockquote>
<p>求key有序集合和<code>多个otherKeys</code>有序集的交集，并将结果集存储在新的destKey有序集合中，key相同的话会把score值相加，其中有序集成员按分数值递增(从小到大)顺序排列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">stringList.add(<span class="string">&quot;zzset2&quot;</span>);</span><br><span class="line">stringList.add(<span class="string">&quot;zzset3&quot;</span>);</span><br><span class="line">System.out.println(template.opsForZSet().intersectAndStore(<span class="string">&quot;zzset1&quot;</span>,stringList,<span class="string">&quot;destZset44&quot;</span>));</span><br><span class="line"></span><br><span class="line">Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples = template.opsForZSet().rangeWithScores(<span class="string">&quot;destZset44&quot;</span>,<span class="number">0</span>,-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; iterator = tuples.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    ZSetOperations.TypedTuple&lt;Object&gt; typedTuple = iterator.next();</span><br><span class="line">    System.out.println(<span class="string">&quot;value:&quot;</span> + typedTuple.getValue() + <span class="string">&quot;score:&quot;</span> + typedTuple.getScore());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// value:zset-1score:3.0</span></span><br><span class="line"><span class="comment">// value:zset-2score:6.0</span></span><br><span class="line"><span class="comment">// value:zset-3score:9.0</span></span><br></pre></td></tr></table></figure>



<h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><p>redis替代业务数据存储，会想到模糊匹配的问题，redis是支持模糊匹配的，以下两张图的数据源举例</p>
<blockquote>
<p>通配符：<code> *，?，[]</code></p>
<ol>
<li><code>*</code>：通配任意多个字符</li>
<li><code>?</code>：通配单个字符</li>
<li><code>[]</code>：通配括号内的某一个字</li>
</ol>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/AZ4bfpFLOzmEDqc.png"></p>
<h3 id="查询Key"><a href="#查询Key" class="headerlink" title="查询Key"></a>查询Key</h3><blockquote>
<ul>
<li><code>Set&lt;K&gt; keys(@NotNull K pattern)</code></li>
</ul>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/Yvnx6ZLor9CXjyI.png"></p>
<p><code>注</code>：由于<code>Redis是单线程</code>，<code>keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 O(n）</code>，Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长</p>
<h3 id="查询Hash数据中的HK"><a href="#查询Hash数据中的HK" class="headerlink" title="查询Hash数据中的HK"></a>查询Hash数据中的HK</h3><p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/jJOa5hkldAT3CsR.png"></p>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><p>在相应的<code>key明明存在的情况下，模糊查询就是查找不出来</code>，那数据序列化肯定有问题，查询数据应如下图</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/WwYSzqax5FkonHG.png"></p>
<p>需要<code>配置RedisTemplate的序列化</code>，<code>解决如下</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/05/31/z7oH9i3vZtFRcAT.png"></p>
<h1 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h1><p>Redis在<code>2.0.0版本开始</code>支持<code>Redis发布订阅(pub/sub)</code>，就是一种简易的MQ<code>消息通信模式</code>：<code>发送者 (pub) 发送消息</code>，<code>订阅者 (sub) 接收消息</code>。可用于实现及时性，且可靠性低的功能。</p>
<p><code>Redis的发布订阅机制包括三部分，发布者、订阅者和Channel（主题或者队列）</code>。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/02/H86qTe9DakO7GQX.png"></p>
<p>当有新消息通过 <code>PUBLISH</code> 命令发送给频道 <code>channel1</code> 时， 这个消息就会被发送给订阅它的三个客户端：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/02/fMDL8FWAT6BCSsr.png"></p>
<h2 id="命令行实现"><a href="#命令行实现" class="headerlink" title="命令行实现"></a>命令行实现</h2><h3 id="订阅主题"><a href="#订阅主题" class="headerlink" title="订阅主题"></a>订阅主题</h3><p>Redis采用<code>SUBSCRIBE channel</code>命令<code>订阅某个主题</code>，<code>返回</code>的参数<code>subscribe</code>表示<code>已经成功订阅主题</code>，<code>第二个</code>参数表示<code>订阅的主题名称</code>，<code>第三个</code>表示<code>当前订阅数</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SUBSCRIBE ORDER-PAY-SUCCESS</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;subscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;ORDER-PAY-SUCCESS&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="模式匹配订阅"><a href="#模式匹配订阅" class="headerlink" title="模式匹配订阅"></a>模式匹配订阅</h3><p>模式匹配功能是允许客户端订阅匹配某种模式的频道，Redis采用<code>PSUBSCRIBE channel</code>命令订阅<code>匹配某种模式的所有频道</code>，通配符如下</p>
<blockquote>
<ol>
<li><code>?</code>：表示 <code>1个占位符</code></li>
<li><code>*</code> ：表示<code>任意个占位符（包括0）</code></li>
<li><code>?*</code> ：表示<code>1个以上的占位符</code>。</li>
</ol>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PSUBSCRIBE ORDER-PAY-*</span><br><span class="line">Reading messages... (press Ctrl-C to quit)</span><br><span class="line">1) <span class="string">&quot;psubscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;ORDER-PAY-*&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="发布消息"><a href="#发布消息" class="headerlink" title="发布消息"></a>发布消息</h3><p>Redis采用<code>PUBLISH channel message</code>命令在<code>某个主题上发布消息</code>，<code>返回</code>的参数是<code>接收到消息的订阅者个数</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; PUBLISH ORDER-PAY-SUCCESS DD202109071525</span><br><span class="line">(<span class="built_in">integer</span>) 1</span><br></pre></td></tr></table></figure>

<h3 id="取消订阅"><a href="#取消订阅" class="headerlink" title="取消订阅"></a>取消订阅</h3><p>Redis采用<code>UNSUBSCRIBE channel</code>或<code>PUNSUBSCRIBE channel</code>命令<code>取消某个主题的订阅</code>，由于<code>Redis的订阅操作是阻塞式</code>的，因此一旦<code>客户端订阅了某个频道或模式，就将会一直处于订阅状态直到退出</code>。在 SUBSCRIBE，PSUBSCRIBE，UNSUBSCRIBE 和 PUNSUBSCRIBE 命令中，其返回值都包含了该客户端当前订阅的频道和模式的数量，当这个数量变为0时，该客户端会自动退出订阅状态。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; UNSUBSCRIBE ORDER-PAY-SUCCESS</span><br><span class="line">1) <span class="string">&quot;unsubscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;ORDER-PAY-SUCCESS&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br><span class="line">127.0.0.1:6379&gt; PUNSUBSCRIBE ORDER-PAY-SUCCESS</span><br><span class="line">1) <span class="string">&quot;punsubscribe&quot;</span></span><br><span class="line">2) <span class="string">&quot;ORDER-PAY-SUCCESS&quot;</span></span><br><span class="line">3) (<span class="built_in">integer</span>) 0</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先三个订阅者订阅ORDER-PAY-SUCCESS主题，当发送者在这个主题内发送订单号时，所有的订阅者都会收到这个主题的消息。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/02/OL1Iy8HnNZFwxWf.png"></p>
<h2 id="SpringBoot实现"><a href="#SpringBoot实现" class="headerlink" title="SpringBoot实现"></a>SpringBoot实现</h2><p><code>依赖和配置</code>与<code>SpringBoot整合Redis</code>章节一致，在此不再累述</p>
<ul>
<li>配置消息监听</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.PatternTopic;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.RedisMessageListenerContainer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.listener.adapter.MessageListenerAdapter;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisMessageConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监听订单支付完成主题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_PAY_SUCCESS</span> <span class="operator">=</span> <span class="string">&quot;ORDER-PAY-SUCCESS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息监听器适配器，绑定消息处理器，利用反射技术调用消息处理器的业务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MessageListenerAdapter <span class="title function_">getMessageListenerAdapter</span><span class="params">(MessageListener messageListener)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MessageListenerAdapter</span>(messageListener, <span class="string">&quot;onMessage&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注入消息监听容器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> RedisMessageListenerContainer <span class="title function_">getRedisMessageListenerContainer</span><span class="params">(RedisConnectionFactory redisConnectionFactory, MessageListenerAdapter messageListenerAdapter)</span>&#123;</span><br><span class="line">        <span class="type">RedisMessageListenerContainer</span> <span class="variable">redisMessageListenerContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RedisMessageListenerContainer</span>();</span><br><span class="line">        redisMessageListenerContainer.setConnectionFactory(redisConnectionFactory);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以添加多个 messageListener，配置不同的交换机</span></span><br><span class="line">        <span class="comment">//模式匹配订阅</span></span><br><span class="line">        redisMessageListenerContainer.addMessageListener(messageListenerAdapter, <span class="keyword">new</span> <span class="title class_">PatternTopic</span>(ORDER_PAY_SUCCESS));</span><br><span class="line">        <span class="comment">//消息主题订阅</span></span><br><span class="line">        <span class="comment">//redisMessageListenerContainer.addMessageListener(messageListenerAdapter,new ChannelTopic(&quot;__keyevent@0__:expired&quot;));</span></span><br><span class="line">        <span class="keyword">return</span> redisMessageListenerContainer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    StringRedisTemplate <span class="title function_">template</span><span class="params">(RedisConnectionFactory connectionFactory)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">StringRedisTemplate</span>(connectionFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>发送消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.Resource;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(value = SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RedisPubTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 订单支付完成主题</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">ORDER_PAY_SUCCESS</span> <span class="operator">=</span> <span class="string">&quot;ORDER-PAY-SUCCESS&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate stringRedisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟发送5调订单支付完成的消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sendMessage</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            stringRedisTemplate.convertAndSend(ORDER_PAY_SUCCESS,<span class="string">&quot;DD&quot;</span> + System.currentTimeMillis());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>接收消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MessageListener</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onMessage</span><span class="params">(String message)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;接收消息：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">接收消息：DD1631005025949</span><br><span class="line">接收消息：DD1631005025964</span><br><span class="line">接收消息：DD1631005025965</span><br><span class="line">接收消息：DD1631005025967</span><br><span class="line">接收消息：DD1631005025968</span><br></pre></td></tr></table></figure>

<h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><p><code>Redis Stream</code>是 Redis <code>5.0 版本</code>新增加的<code>数据结构</code>。</p>
<p>Redis Stream 主要用于消息队列（MQ，Message Queue），Redis 本身是有一个 <code>Redis 发布订阅 (pub/sub)</code> 来实现消息队列的功能，但它有个<code>缺点</code>就是消息<code>无法持久化</code>，如果出现网络断开、Redis 宕机等，消息就会被丢弃。</p>
<p>而 <code>Redis Stream</code> 提供了消息的<code>持久化</code>和<code>主备复制</code>功能，可以让任何客户端访问任何时刻的数据，并且能记住每一个客户端的访问位置，还能保证消息不丢失。</p>
<blockquote>
<p>Redis Stream在此不展开叙述，有兴趣可查阅相关文章</p>
</blockquote>
<h1 id="使用规范"><a href="#使用规范" class="headerlink" title="使用规范"></a>使用规范</h1><h2 id="键值对使用规范"><a href="#键值对使用规范" class="headerlink" title="键值对使用规范"></a>键值对使用规范</h2><p>有两点需要注意：</p>
<blockquote>
<ol>
<li>好的 key 命名，才能提供可读性强、可维护性高的key，便于定位问题和寻找数据。</li>
<li>value要避免出现bigkey、选择高效的序列化和压缩、使用对象共享池、选择高效恰当的数据类型</li>
</ol>
</blockquote>
<h3 id="key-命名规范"><a href="#key-命名规范" class="headerlink" title="key 命名规范"></a>key 命名规范</h3><p><code>规范的 key命名，在遇到问题的时候能够方便定位</code>。Redis属于没有Scheme的 NoSQL数据库。</p>
<p>所以要靠规范来建立其Scheme语意，就好比根据不同的场景我们建立不同的数据库。</p>
<p><code>把「业务模块名」作为前缀（好比数据库 Scheme），通过「冒号」分隔，再加上「具体业务名</code>」。</p>
<p>这样我们就可以通过 key 前缀来区分不同的业务数据，清晰明了。</p>
<p>总结起来就是：<code>「业务名:表名:id」</code></p>
<blockquote>
<ul>
<li><code>key 太长的话有什么问题么？</code></li>
</ul>
</blockquote>
<p>key 是字符串，底层的数据结构是 SDS，<code>SDS 结构中会包含字符串长度、分配空间大小等元数据信息</code>。</p>
<p><code>字符串长度增加，SDS 的元数据也会占用更多的内存空间。</code></p>
<p>所以当字符串太长的时候，可以采用适当缩写的形式。</p>
<h3 id="不要使用-bigkey"><a href="#不要使用-bigkey" class="headerlink" title="不要使用 bigkey"></a>不要使用 bigkey</h3><p><code>因为 Redis 是单线程执行读写指令，如果出现bigkey 的读写操作就会阻塞线程，降低 Redis 的处理效率。</code></p>
<p>bigkey包含两种情况：</p>
<blockquote>
<ol>
<li>键值对的 value很大，比如 value保存了 2MB的 String数据；</li>
<li>键值对的 value是集合类型，元素很多，比如保存了 5 万个元素的 List 集合。</li>
</ol>
</blockquote>
<p>虽然 Redis 官方说明了 <code>key和string类型 value限制均为512MB</code>。</p>
<p>防止网卡流量、慢查询，<code>string类型控制在10KB以内</code>，<code>hash、list、set、zset元素个数不要超过 5000。</code></p>
<blockquote>
<ul>
<li><code>如果业务数据就是这么大咋办？</code></li>
</ul>
</blockquote>
<p>可以通过 gzip 数据压缩来减小数据大小</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用gzip压缩字符串</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">compress</span><span class="params">(String str)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (str == <span class="literal">null</span> || str.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">GZIPOutputStream</span> <span class="variable">gzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPOutputStream</span>(out)) &#123;</span><br><span class="line">        gzip.write(str.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Encoder().encode(out.toByteArray());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用gzip解压缩</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">uncompress</span><span class="params">(String compressedStr)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (compressedStr == <span class="literal">null</span> || compressedStr.length() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> compressedStr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">byte</span>[] compressed = <span class="keyword">new</span> <span class="title class_">sun</span>.misc.BASE64Decoder().decodeBuffer(compressedStr);;</span><br><span class="line">    <span class="type">String</span> <span class="variable">decompressed</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ByteArrayOutputStream</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">ByteArrayInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(compressed);</span><br><span class="line">    <span class="type">GZIPInputStream</span> <span class="variable">ginzip</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(in);) &#123;</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> ((offset = ginzip.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            out.write(buffer, <span class="number">0</span>, offset);</span><br><span class="line">        &#125;</span><br><span class="line">        decompressed = out.toString();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decompressed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>如果集合类型的元素的确很多，可以将一个大集合拆分成多个小集合来保存。</code></p>
<h3 id="使用高效序列化和压缩方法"><a href="#使用高效序列化和压缩方法" class="headerlink" title="使用高效序列化和压缩方法"></a>使用高效序列化和压缩方法</h3><p>为了节省内存，可以使用高效的序列化方法和压缩方法去减少 value的大小。</p>
<p>protostuff和 kryo这两种序列化方法，就要比 Java内置的序列化方法效率更高。</p>
<p>上述的两种序列化方式虽然省内存，但是序列化后都是二进制数据，可读性太差。</p>
<p><code>通常会序列化成 JSON或者 XML</code>，为了避免数据占用空间大，<code>可以使用压缩工具（snappy、 gzip）将数据压缩再存到 Redis 中。</code></p>
<h3 id="使用整数对象共享池"><a href="#使用整数对象共享池" class="headerlink" title="使用整数对象共享池"></a>使用整数对象共享池</h3><p>Redis 内部维护了 0 到 9999 这 1 万个整数对象，并把这些整数作为一个共享池使用。</p>
<p>即使大量键值对保存了 0 到 9999 范围内的整数，在 Redis 实例中，其实只保存了一份整数对象，可以节省内存空间。</p>
<p>需要注意的是，有两种情况是不生效的：</p>
<ul>
<li><code>Redis 中设置了 maxmemory，而且启用了 LRU策略</code>（allkeys-lru 或 volatile-lru策略），那么，整数对象共享池就无法使用了。</li>
</ul>
<blockquote>
<p>因为 LRU 需要统计每个键值对的使用时间，如果不同的键值对都复用一个整数对象就无法统计了。</p>
</blockquote>
<ul>
<li>如果<code>集合类型数据采用ziplist编码，而集合元素是整数</code>，这个时候，也不能使用共享池。</li>
</ul>
<blockquote>
<p>因为 ziplist 使用了紧凑型内存结构，判断整数对象的共享情况效率低。</p>
</blockquote>
<h2 id="命令使用规范"><a href="#命令使用规范" class="headerlink" title="命令使用规范"></a>命令使用规范</h2><h3 id="生产禁用的指令"><a href="#生产禁用的指令" class="headerlink" title="生产禁用的指令"></a>生产禁用的指令</h3><p>Redis 是单线程处理请求操作，如果<code>执行一些涉及大量操作、耗时长的命令，就会严重阻塞主线程</code>，导致其它请求无法得到正常处理。</p>
<ul>
<li><code>KEYS</code>：该命令需要对 Redis 的全局哈希表进行全表扫描，严重阻塞 Redis 主线程；</li>
</ul>
<blockquote>
<p>应该使用 SCAN 来代替，分批返回符合条件的键值对，避免主线程阻塞。</p>
</blockquote>
<ul>
<li><p><code>FLUSHALL</code>：删除 Redis 实例上的所有数据，如果数据量很大，会严重阻塞 Redis 主线程；</p>
</li>
<li><p><code>FLUSHDB</code>：删除当前数据库中的数据，如果数据量很大，同样会阻塞 Redis 主线程。</p>
</li>
</ul>
<blockquote>
<p>加上 ASYNC 选项，让 FLUSHALL，FLUSHDB 异步执行。</p>
</blockquote>
<p>也可以直接禁用，<code>用rename-command命令在配置文件中对这些命令进行重命名</code>，让客户端无法使用这些命令。</p>
<h3 id="慎用-MONITOR-命令"><a href="#慎用-MONITOR-命令" class="headerlink" title="慎用 MONITOR 命令"></a>慎用 MONITOR 命令</h3><p><code>MONITOR 命令会把监控到的内容持续写入输出缓冲区。</code></p>
<p>如果线上命令的操作很多，输出缓冲区很快就会溢出了，这就会对 Redis 性能造成影响，甚至引起服务崩溃。</p>
<p>所以，除非十分需要监测某些命令的执行（例如，Redis 性能突然变慢，想查看下客户端执行了哪些命令）才使用。</p>
<h3 id="慎用全量操作命令"><a href="#慎用全量操作命令" class="headerlink" title="慎用全量操作命令"></a>慎用全量操作命令</h3><p>比如<code>获取集合中的所有元素</code>（<code>HASH 类型的 hgetall</code>、<code>List 类型的 lrange</code>、<code>Set 类型的 smembers</code>、<code>zrange</code> 等命令）。</p>
<p>这些操作<code>会对整个底层数据结构进行全量扫描 ，导致阻塞 Redis 主线程</code>。</p>
<blockquote>
<ul>
<li><code>如果业务场景就是需要获取全量数据咋办？</code></li>
</ul>
</blockquote>
<p>有两个方式可以解决：</p>
<blockquote>
<ol>
<li>使用 SSCAN、HSCAN等命令分批返回集合数据；</li>
<li>把大集合拆成小集合，比如按照时间、区域等划分。</li>
</ol>
</blockquote>
<h2 id="数据保存规范"><a href="#数据保存规范" class="headerlink" title="数据保存规范"></a>数据保存规范</h2><h3 id="冷热数据分离"><a href="#冷热数据分离" class="headerlink" title="冷热数据分离"></a>冷热数据分离</h3><p>虽然 Redis 支持使用 RDB 快照和 AOF 日志持久化保存数据，但是，这两个机制都是用来提供数据可靠性保证的，并不是用来扩充数据容量的。</p>
<p><code>不要什么数据都存在 Redis，应该作为缓存保存热数据</code>，这样既可以充分利用 Redis 的高性能特性，还可以把宝贵的内存资源用在服务热数据上。</p>
<h3 id="业务数据隔离"><a href="#业务数据隔离" class="headerlink" title="业务数据隔离"></a>业务数据隔离</h3><p><code>不要将不相关的数据业务都放到一个 Redis 中</code>。一方面<code>避免业务相互影响</code>，另一方面<code>避免单实例膨胀，并能在故障时降低影响面，快速恢复</code>。</p>
<h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>在数据保存时，建议根据业务使用数据的时长，<code>设置数据的过期时间</code>。</p>
<p>写入 Redis 的数据会一直占用内存，如果数据持续增多，就可能达到机器的内存上限，造成内存溢出，导致服务崩溃。</p>
<h3 id="控制单实例的内存容量"><a href="#控制单实例的内存容量" class="headerlink" title="控制单实例的内存容量"></a>控制单实例的内存容量</h3><p>建议<code>设置在 2~6 GB</code> 。这样一来，无论是 RDB 快照，还是主从集群进行数据同步，都能很快完成，不会阻塞正常请求的处理。</p>
<h3 id="防止缓存雪崩"><a href="#防止缓存雪崩" class="headerlink" title="防止缓存雪崩"></a>防止缓存雪崩</h3><p>避免集中过期 key 导致缓存雪崩。</p>
<h2 id="运维规范"><a href="#运维规范" class="headerlink" title="运维规范"></a>运维规范</h2><ol>
<li>使用 <code>Cluster 集群或者哨兵集群</code>，做到高可用；</li>
<li>实例<code>设置最大连接数</code>，防止过多客户端连接导致实例负载过高，影响性能。</li>
<li><code>不开启 AOF 或开启 AOF 配置为每秒刷盘</code>，避免磁盘 IO 拖慢 Redis 性能。</li>
<li>设置<code>合理的 repl-backlog</code>，降低主从全量同步的概率</li>
<li>设置<code>合理的 slave client-output-buffer-limit</code>，避免主从复制中断情况发生。</li>
<li>根据实际场景设置<code>合适的内存淘汰策略</code>。</li>
<li>使用<code>连接池操作 Redis</code>。</li>
</ol>
<h1 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h1><p>监控指标包括<code>性能指标 Performance</code>、<code>内存指标 Memory</code>、<code>基本活动指标 Basic activity</code>、<code>持久性指标 Persistence</code>、<code>错误指标 Error</code>五类</p>
<h2 id="性能指标-Performance"><a href="#性能指标-Performance" class="headerlink" title="性能指标 Performance"></a>性能指标 Performance</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>latency</td>
<td>Redis响应一个请求的时间</td>
</tr>
<tr>
<td>instantaneous_ops_per_sec</td>
<td>平均每秒处理请求总数</td>
</tr>
<tr>
<td>hi rate(calculated)</td>
<td>缓存命中率（计算出来的</td>
</tr>
</tbody></table>
<h2 id="内存指标-Memory"><a href="#内存指标-Memory" class="headerlink" title="内存指标 Memory"></a>内存指标 Memory</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>used_memory</td>
<td>已使用内存</td>
</tr>
<tr>
<td>mem_fragmentation_ratio</td>
<td>内存碎片率</td>
</tr>
<tr>
<td>evicted_keys</td>
<td>由于最大内存限制被移除的key的数量</td>
</tr>
<tr>
<td>blocked_clients</td>
<td>由于BLPOP,BRPOP,or BRPOPLPUSH而备阻塞的客户端</td>
</tr>
</tbody></table>
<h2 id="基本活动指标-Basic-activity"><a href="#基本活动指标-Basic-activity" class="headerlink" title="基本活动指标 Basic activity"></a>基本活动指标 Basic activity</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>connected_clients</td>
<td>客户端连接数</td>
</tr>
<tr>
<td>conected_laves</td>
<td>slave数量</td>
</tr>
<tr>
<td>master_last_io_seconds_ago</td>
<td>最近一次主从交互之后的秒数</td>
</tr>
<tr>
<td>keyspace</td>
<td>数据库中的key值总数</td>
</tr>
</tbody></table>
<h2 id="持久性指标-Persistence"><a href="#持久性指标-Persistence" class="headerlink" title="持久性指标 Persistence"></a>持久性指标 Persistence</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>rdb_last_save_time</td>
<td>最后一次持久化保存磁盘的时间戳</td>
</tr>
<tr>
<td>rdb_changes_sice_last_save</td>
<td>自最后一次持久化以来数据库的更改数</td>
</tr>
</tbody></table>
<h2 id="错误指标-Error"><a href="#错误指标-Error" class="headerlink" title="错误指标 Error"></a>错误指标 Error</h2><table>
<thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>ejected_connections</td>
<td>由于达到maxclient限制而被拒绝的连接数</td>
</tr>
<tr>
<td>keyspace_misses</td>
<td>key值查找失败(没有命中)次数</td>
</tr>
<tr>
<td>master_link_down_since_seconds</td>
<td>主从断开的持续时间（以秒为单位)</td>
</tr>
</tbody></table>
<h2 id="监控方式"><a href="#监控方式" class="headerlink" title="监控方式"></a>监控方式</h2><h3 id="redis-benchmark"><a href="#redis-benchmark" class="headerlink" title="redis-benchmark"></a>redis-benchmark</h3><p><code>Redis自带性能测试工具redis-benchmark</code>，基本命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-benchmark [option] [option value]</span><br></pre></td></tr></table></figure>
<p><code>注：该命令是在 redis 的目录下执行的，而不是 redis 客户端的内部指令。</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/01/05/vyHsQAdVfcxERgi.png"></p>
<p>可选参数如下所示：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>-h</td>
<td>指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>-p</td>
<td>指定服务器端口</td>
<td>6379</td>
</tr>
<tr>
<td>-s</td>
<td>指定服务器socket</td>
<td></td>
</tr>
<tr>
<td>-c</td>
<td>指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td>-n</td>
<td>指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td>-d</td>
<td>以字节的形式指定 SET&#x2F;GET 值的数据大小</td>
<td>2</td>
</tr>
<tr>
<td>-k</td>
<td>1&#x3D;keep alive 0&#x3D;reconnect</td>
<td>1</td>
</tr>
<tr>
<td>-r</td>
<td>SET&#x2F;GET&#x2F;INCR 使用随机 key, SADD 使用随机值</td>
<td></td>
</tr>
<tr>
<td>-P</td>
<td>代表每个请求pipeline的数据量</td>
<td>1</td>
</tr>
<tr>
<td>-q</td>
<td>仅仅显示每秒执行的请求信息。</td>
<td></td>
</tr>
<tr>
<td>–csv</td>
<td>以 CSV 格式输出，便于后续处理， 如导出到Excel</td>
<td></td>
</tr>
<tr>
<td>-l（L 的小写字母）</td>
<td>生成循环，永久执行测试</td>
<td></td>
</tr>
<tr>
<td>-t</td>
<td>仅运行以逗号分隔的测试命令列表。</td>
<td></td>
</tr>
<tr>
<td>-I（i的大写字母）</td>
<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td></td>
</tr>
</tbody></table>
<p>同时执行 10000 个请求来检测性能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ redis-benchmark -n 10000  -q</span><br><span class="line"></span><br><span class="line">PING_INLINE: 141043.72 requests per second</span><br><span class="line">PING_BULK: 142857.14 requests per second</span><br><span class="line">SET: 141442.72 requests per second</span><br><span class="line">GET: 145348.83 requests per second</span><br><span class="line">INCR: 137362.64 requests per second</span><br><span class="line">LPUSH: 145348.83 requests per second</span><br><span class="line">LPOP: 146198.83 requests per second</span><br><span class="line">SADD: 146198.83 requests per second</span><br><span class="line">SPOP: 149253.73 requests per second</span><br><span class="line">LPUSH (needed to benchmark LRANGE): 148588.42 requests per second</span><br><span class="line">LRANGE_100 (first 100 elements): 58411.21 requests per second</span><br><span class="line">LRANGE_300 (first 300 elements): 21195.42 requests per second</span><br><span class="line">LRANGE_500 (first 450 elements): 14539.11 requests per second</span><br><span class="line">LRANGE_600 (first 600 elements): 10504.20 requests per second</span><br><span class="line">MSET (10 keys): 93283.58 requests per second</span><br></pre></td></tr></table></figure>

<p>测试命令详解：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>SET</td>
<td>将字符串值value关联到key；</td>
</tr>
<tr>
<td>GET</td>
<td>返回key所关联的字符串值，如果key存储的值不是字符串类型，返回一个错误；</td>
</tr>
<tr>
<td>INCR</td>
<td>将key中存储的数字值增一。不能转换为数字则报错；</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将一个或多个值value插入到列表key的表头；</td>
</tr>
<tr>
<td>RPUSH</td>
<td>将一个或多个值value插入到列表key的表尾；</td>
</tr>
<tr>
<td>LPOP</td>
<td>移除并返回列表key的头元素；</td>
</tr>
<tr>
<td>RPOP</td>
<td>移除并返回列表key的尾元素；</td>
</tr>
<tr>
<td>SADD</td>
<td>将一个或多个member元素加入到集合set当中，已经存在于集合的member元素将被忽略；</td>
</tr>
<tr>
<td>SPOP</td>
<td>移除并返回集合中的一个随机元素；</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将一个或多个value插入到列表key的表头；</td>
</tr>
<tr>
<td>LRANGE_100</td>
<td>返回列表key中指定区间内的元素，前100条元素；</td>
</tr>
<tr>
<td>LRANGE_300</td>
<td>返回列表key中指定区间内的元素，前300条元素；</td>
</tr>
<tr>
<td>LRANGE_500</td>
<td>返回列表key中指定区间内的元素，前500条元素；</td>
</tr>
<tr>
<td>LRANGE_600</td>
<td>返回列表key中指定区间内的元素，前600条元素；</td>
</tr>
<tr>
<td>MSET</td>
<td>同时设置一个或多个key-value对，value为字符串。</td>
</tr>
</tbody></table>
<blockquote>
<p><code>PING_INLINE 和 PING_BULK</code><br>在统一请求协议之前，Redis使用一个不同的协议来发送命令，这个协议仍然被支持因为通过telnet它很容易手写。在这个协议中存在两种命令：</p>
<ul>
<li>inline 命令：命令很简单，就是用空格把参数分隔开来的字符串。二进制安全是不可能的。</li>
<li>bulk 命令：bulk命令和inline命令几乎是一样的，但是最后一个参数为了能够接受二进制安全的内容，所以需要以特殊的方式进行处理。</li>
</ul>
</blockquote>
<ul>
<li>实例分析</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/01/05/A451lGjp8okmIS3.png"></p>
<table>
<thead>
<tr>
<th align="center">场景</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1</td>
<td><code>单一</code>key，模拟50客户端，每秒的请求数</td>
</tr>
<tr>
<td align="center">2</td>
<td>随机key，模拟50客户端，每秒的请求数</td>
</tr>
<tr>
<td align="center">3</td>
<td>随机key，模拟100客户端，每秒的请求数</td>
</tr>
<tr>
<td align="center">4</td>
<td>随机key，模拟10客户端，每秒的请求数</td>
</tr>
<tr>
<td align="center">5</td>
<td>随机key，模拟50客户端，<code>并发执行</code>，每秒的请求数</td>
</tr>
</tbody></table>
<p>从表格可看出： </p>
<blockquote>
<ol>
<li>对于相同客户端的情况下，随机key的每秒请求数，SET和LPOP减少，GET、INCR、LPUSH、SADD、SPOP和LRANGE增加了；</li>
<li>在随机生成key值的情况下，SET、SADD操作随着客户端数增加，每秒请求数减少；考虑到cache命中的情况，其他命令变化趋势没有规律；</li>
<li>其他条件一致，并发执行情况下，各种命令都是有大幅度增加。</li>
</ol>
</blockquote>
<p><code>结论：在真实环境下，应对大数据，大并发，可以通过增加缓存大小，并发执行来提高吞吐量。</code></p>
<h3 id="redis-stat"><a href="#redis-stat" class="headerlink" title="redis-stat"></a>redis-stat</h3><p>可视化监控工具redis-stat，优缺点如下：</p>
<blockquote>
<p>优点：基于redis的INFO命令，较使用MONITOR的监控工具对redis服务器性能影响较小；<br>缺点：如果同时监控多个redis实例，不能单独显示每一个实例的数据信息，貌似是总和。</p>
</blockquote>
<p>官网提供了两种安装方式，一种是<code>通过Ruby gem安装</code>，第二种方式是<code>通过下载Jar包直接运行</code>，需要本地有Java环境。</p>
<ul>
<li>Ruby安装</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 安装ruby</span></span><br><span class="line">sudo yum install ruby</span><br><span class="line">sudo yum install ruby-devel</span><br><span class="line">gem update --system</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更换国内镜像地址</span></span><br><span class="line">gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/</span><br><span class="line">gem sources -l</span><br><span class="line">*** CURRENT SOURCES ***</span><br><span class="line"></span><br><span class="line">https://gems.ruby-china.org/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">gem install redis-stat</span><br></pre></td></tr></table></figure>

<p>不出意外的话，就安装成功了。运行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-stat --server --daemon --auth=redis密码（如果有的话）</span><br></pre></td></tr></table></figure>
<p>就可以在后台启动redis-stat，浏览器输入如下地址访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://Redis IP:63790</span><br></pre></td></tr></table></figure>

<ul>
<li>Jar包安装</li>
</ul>
<p>下载Jar包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://github.com/junegunn/redis-stat/releases/download/0.4.14/redis-stat-0.4.14.jar</span><br></pre></td></tr></table></figure>
<p>上传Jar包到需要监控的服务器后，运行如下命令(<code>注：服务器防火墙需要开放端口63790</code>)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">java -jar redis-stat-0.4.14.jar --server --auth=redis密码</span><br></pre></td></tr></table></figure>

<p>最后浏览器输入访问地址即可</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://Redis IP:63790</span><br></pre></td></tr></table></figure>

<ul>
<li>用法与参数描述</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># redis-stat [HOST[:PORT][/PASS] ...] [INTERVAL [COUNT]]</span><br><span class="line">./redis-stat localhost:6380  --server=url:端口号 --verbose  1</span><br></pre></td></tr></table></figure>
<p>选项参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a, --auth=PASSWORD             设置密码</span><br><span class="line">-v, --verbose                   显示更多信息</span><br><span class="line">    --style=STYLE               输出编码类型: unicode|ascii</span><br><span class="line">    --no-color                  取消ANSI颜色编码</span><br><span class="line">    --csv=OUTPUT_CSV_FILE_PATH  以CSV格式存储结果</span><br><span class="line">    --es=ELASTICSEARCH_URL      把结果发送到 ElasticSearch: [http://]HOST[:PORT][/INDEX]</span><br><span class="line">    --server[=PORT]             运行redis-stat的web server (默认端口号: 63790)</span><br><span class="line">    --daemon                    使得redis-stat成为进程。必须使用 --server 选项      </span><br><span class="line">    --version                   显示版本号</span><br><span class="line">    --help                      显示帮助信息</span><br></pre></td></tr></table></figure>


<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/01/05/ByW5q1Cj46hoR2H.png"></p>
<p>|参数	|描述	|<br>|	—–	|	—–	|<br>|time | 更新参数时间|<br>|us（used_cpu_user） | Redis 服务器使用的用户 CPU|<br>|sy（used_cpu_sys） | Redis 服务器使用的系统 CPU|<br>|cl（connected_clients） | 客户端连接数（不包括从站的连接数）|<br>|bcl（blocked_clients） | 阻塞呼叫中挂起的客户端数量（BLPOP，BRPOP，BRPOPLPUSH）|<br>|mem（used_memory） | Redis 使用其分配程序分配的字节总数（标准 libc，jemalloc 或替代分配程序，如 tcmalloc|<br>|rss（used_memory_rss） | 从操作系统的角度，返回Redis已分配的内存总量（俗称常驻集大小）。这个值和top、ps等命令的输出一致，包含了used_memory和内存碎片,从系统角度,显示Redis进程占用的物理内存总量.|<br>|keys| 保存的键大小|<br>|cmd&#x2F;s（total_commands_processed_per_ses） |  服务器已每秒执行的命令数量|<br>|exp&#x2F;s（expired_keys_per_second） |  因为过期而每秒被自动删除的数据库键数量|<br>|evt&#x2F;s（evicted_keys_per_second） |  因为最大内存容量限制而每秒被驱逐（evict）的键数量|<br>|hit%&#x2F;s（keyspace_hits_ratio_per_second） |  查找数据库键成功的次数比例|<br>|hit&#x2F;s（keyspace_hits_per_second） |   查找数据库键成功的次数|<br>|mis&#x2F;s（keyspace_misses_per_second） |  查找数据库键每秒失败的次数|<br>|aofcs（aof_current_size） |   AOF 文件目前的大小|</p>
<h3 id="redis-faina"><a href="#redis-faina" class="headerlink" title="redis-faina"></a>redis-faina</h3><p><code>使用redis自带命令monitor的输出结果做分析的python脚本</code>，在命令行下使用，可以做实时分析使用。</p>
<ul>
<li>安装</li>
</ul>
<p>该工具是用python写的，不需要安装什么依赖包，只需要将redis-faina.py下载即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/facebookarchive/redis-faina.git</span><br></pre></td></tr></table></figure>

<p>用法与选项参数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cd redis-faina/</span><br><span class="line"># ./redis-faina.py -h</span><br><span class="line">usage: redis-faina.py [-h] [--prefix-delimiter PREFIX_DELIMITER] [--redis-version REDIS_VERSION] [input]</span><br><span class="line"></span><br><span class="line">位置参数:</span><br><span class="line">  input                 文件解析</span><br><span class="line">可选参数:</span><br><span class="line">  -h, --help            显示帮助信息并退出</span><br><span class="line">  --prefix-delimiter PREFIX_DELIMITER</span><br><span class="line">                        统计前缀的key的数据</span><br><span class="line">  --redis-version REDIS_VERSION</span><br><span class="line">                        被监控的redis服务器的版本号</span><br></pre></td></tr></table></figure>

<p>redis-faina的两种用法：</p>
<ul>
<li>通过redis MONITOR命令以及管道进行分析</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis-cli -p port MONITOR | head -n &lt;NUMBER OF LINES TO ANALYZE&gt; | ./redis-faina.py [options]</span></span><br><span class="line">redis-cli -p 6379 MONITOR | <span class="built_in">head</span> -n &lt;10000&gt; | ./redis-faina.py --prefix-delimiter 前缀字符串</span><br></pre></td></tr></table></figure>

<ul>
<li>读取文件中MONITOR日志进行分析</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">redis-cli -p port MONITOR | <span class="built_in">head</span> -n &lt;10000&gt; &gt; 导出的文件路径</span><br><span class="line">./redis-faina.py 导出的文件路径</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Overall Stats</span><br><span class="line">========================================</span><br><span class="line">Lines Processed  10000      -- 总命令数</span><br><span class="line">Commands/Sec     274.73     -- qps</span><br><span class="line">Top Prefixes   #按照key的前缀统计</span><br><span class="line">========================================</span><br><span class="line">testcache-rendsord-lang        1684(16.84%)</span><br><span class="line">testcache-inuanGoods-id        1090(10.90%)</span><br><span class="line">testcache-riceroup-cat_id      307 (3.07%)</span><br><span class="line">testcache-ategorynfo-id        190 (1.90%)</span><br><span class="line">testcache-ategoryey-lang       189 (1.89%)</span><br><span class="line">testcache-earchtrremplate-id  61  (0.61%)</span><br><span class="line">testcache-riceroup-id          15  (0.15%)</span><br><span class="line">testcache-otordata-lang       9   (0.09%)</span><br><span class="line">Top Keys     #请求最频繁的key</span><br><span class="line">========================================</span><br><span class="line">testcache-acebookhareandsave  2373(23.73%)</span><br><span class="line">testcache-hippingFee           2198(21.98%)</span><br><span class="line">testcache-rendsord-lang:en    1464(14.64%)</span><br><span class="line">testcache-ountryurrency       1181(11.81%)</span><br><span class="line">testcache-inuanoods          442 (4.42%)</span><br><span class="line">testcache-ategoryey-lang:     183 (1.83%)</span><br><span class="line">testcache-rendsord-lang:es    124 (1.24%)</span><br><span class="line">testcache-inuanoods-id:68    114 (1.14%)</span><br><span class="line">Top Commands     # 执行最频繁的命令</span><br><span class="line">========================================</span><br><span class="line">GET      9957(99.57%)</span><br><span class="line">AUTH     13  (0.13%)</span><br><span class="line">COMMAND  13  (0.13%)</span><br><span class="line">SADD     10  (0.10%)</span><br><span class="line">info     5   (0.05%)</span><br><span class="line">SET      1   (0.01%)</span><br><span class="line">Command Time (microsecs)    # 命令执行时长</span><br><span class="line">========================================</span><br><span class="line">Median  2309.0</span><br><span class="line">75%     4959.75</span><br><span class="line">90%     8447.0</span><br><span class="line">99%     18482.0</span><br><span class="line">Heaviest Commands (microsecs)    #耗时最多的命令</span><br><span class="line">========================================</span><br><span class="line">GET      36281717.75</span><br><span class="line">COMMAND  85269.25</span><br><span class="line">SADD     17985.75</span><br><span class="line">info     10698.5</span><br><span class="line">SET      3228.0</span><br><span class="line">AUTH     625.5</span><br><span class="line">Slowest Calls     #执行最慢的命令</span><br><span class="line">========================================</span><br><span class="line">179962.0  &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">62659.0   &quot;GET&quot; &quot;testcache-romotionullateeduce&quot;</span><br><span class="line">44902.0   &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">40305.25  &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">39559.0   &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">36831.25  &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">33852.0   &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br><span class="line">33501.0   &quot;GET&quot; &quot;testcache-hippingee&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：由于redis MONITOR输出的只有请求开始的时间，所以在一个非常繁忙的redis实例中，根据该请求的开始时间以及下一个请求的开始时间，可以大概估算出一个请求的执行时间。由此可以看出，<code>redis-faina统计的时间并不是十分精确的</code>，尤其在分析一个非常闲的redis实例时，分析的结果可能差的很多</p>
</blockquote>
<h3 id="redislive"><a href="#redislive" class="headerlink" title="redislive"></a>redislive</h3><p>RedisLive是由python编写的开源<code>图形化监控工具</code>，非常轻量级，核心服务部分只包含一个web服务和一个基于redis自带的info命令以及monitor命令的监控服务。</p>
<p>工作原理基于 Redis 的 INFO 和 MONITOR 命令，通过向 Redis 实例发送 INFO 和 MONITOR 命令来获取Redis实例当前的运行数据。</p>
<p>还支持多实例监控，切换方便，而且配置起来也非常容易。<code>监控信息支持redis存储和持久化存储(sqlite)两种方式</code>。</p>
<ul>
<li>安装pip工具</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install epel-release -y</span><br><span class="line">yum install python-pip -y</span><br></pre></td></tr></table></figure>

<ul>
<li>下载源码</li>
</ul>
<p>通过 Git 下载最新的 RedisLive 源代码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/kumarnitin/RedisLive.git</span><br></pre></td></tr></table></figure>

<ul>
<li>安装python依赖包</li>
</ul>
<p>进入RedisLive 目录，查看requirements.txt 文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">argparse==1.2.1</span><br><span class="line">python-dateutil==1.5</span><br><span class="line">redis</span><br><span class="line">tornado==2.1.1</span><br></pre></td></tr></table></figure>
<p>RedisLive 依赖的 Python 扩展包都已经写在 requirements.txt 文件中了。<code>指定豆瓣源来安装python依赖包</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pip install -r requirements.txt -i http://pypi.douban.com/simple/ --trusted-host pypi.douban.com</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置文件</li>
</ul>
<p>进入 RedisLive&#x2F;src 目录，可以看到 redis-live.conf.example文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;RedisServers&quot;</span>:</span><br><span class="line">    [ </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;server&quot;</span>: <span class="string">&quot;154.17.59.99&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span> : 6379</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">&quot;server&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">            <span class="string">&quot;port&quot;</span> : 6380,</span><br><span class="line">            <span class="string">&quot;password&quot;</span> : <span class="string">&quot;some-password&quot;</span></span><br><span class="line">        &#125;       </span><br><span class="line">    ],</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;DataStoreType&quot;</span> : <span class="string">&quot;redis&quot;</span>,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;RedisStatsServer&quot;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;server&quot;</span> : <span class="string">&quot;ec2-184-72-166-144.compute-1.amazonaws.com&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span> : 6385</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;SqliteStatsStore&quot;</span> :</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;to your sql lite file&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>RedisServers</td>
<td>监控的 Redis 实例列表，RedisLive 支持同时监控多个 Redis 实例</td>
</tr>
<tr>
<td>RedisStatsServer</td>
<td>用来存储监控数据的 Redis 实例，此配置不同于 RedisServers，RedisLive 并不监控 RedisStatsServer，RedisStatsServer 只是用作存储监控数据使用</td>
</tr>
<tr>
<td>DataStoreType</td>
<td>监控数据的存储方案，可以配置为redis或者sqlite</td>
</tr>
<tr>
<td>SqliteStatsStore</td>
<td>存储监控数据的 sqlite 配置</td>
</tr>
</tbody></table>
<p>复制redis-live.conf.example文件，并命名为redis-live.conf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cp</span> redis-live.conf.example redis-live.conf</span><br></pre></td></tr></table></figure>

<p>编辑redis-live.conf文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;RedisServers&quot;</span>:        </span><br><span class="line">    [ 	<span class="comment"># 这里可以配置多个server</span></span><br><span class="line">        &#123;</span><br><span class="line">              <span class="string">&quot;server&quot;</span>: <span class="string">&quot;127.0.0.1&quot;</span>,                <span class="comment">#redis监听地址，此处为本机</span></span><br><span class="line">              <span class="string">&quot;port&quot;</span> : 6379,                        <span class="comment">#redis端口号</span></span><br><span class="line">              <span class="string">&quot;password&quot;</span> : <span class="string">&quot;redispassword&quot;</span>          <span class="comment">#redis认证密码</span></span><br><span class="line">        &#125;        </span><br><span class="line">    ],</span><br><span class="line">    <span class="comment"># 如果没有redis，可以换成sqlite</span></span><br><span class="line">    <span class="string">&quot;DataStoreType&quot;</span> : <span class="string">&quot;redis&quot;</span>,        </span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;RedisStatsServer&quot;</span>:    </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;server&quot;</span> : <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">        <span class="string">&quot;port&quot;</span> : 6379,</span><br><span class="line">        <span class="string">&quot;password&quot;</span> : <span class="string">&quot;redispassword&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    </span><br><span class="line">    <span class="string">&quot;SqliteStatsStore&quot;</span> :</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>:  <span class="string">&quot;db/redislive.sqlite&quot;</span>    <span class="comment">#redis数据文件</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>启动服务</li>
</ul>
<p>RedisLive 的运行包括两个部分（在 RedisLive&#x2F;src 目录），<code>redis-monitor.py</code>用于向 Redis 实例发送 INFO 和 MONITOR 命令并获取其返回，<code>redis-live.py</code>用于运行 Web 服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 启动监控，duration是心跳时间 &amp;放置在后台执行</span></span><br><span class="line">./redis-monitor.py --duration=30 &amp;    </span><br><span class="line"><span class="comment"># 启动web服务，默认监听8888端口，可以进行修改</span></span><br><span class="line">./redis-live.py </span><br></pre></td></tr></table></figure>

<p>duration参数指定了监控脚本的运行持续时间，例如设置为 30 秒，即经过 30 秒后，监控脚本会自动退出，并在终端打印 shutting down… 的提示。可以采用 crontab 来定时执行脚本任务：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 每5分钟进入/RedisLive/src/目录，执行启动监控脚本，并设置心跳时间为 30 秒</span></span><br><span class="line">*/5 * * * * <span class="built_in">cd</span> /RedisLive/src/; ./redis-monitor.py --duration 30 &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&gt;/dev/null 2&gt;&amp;1</code>的含义？</p>
<ul>
<li><code>&gt;</code>符号为重定向；</li>
<li><code>/dev/null</code>代表空设备文件；</li>
<li><code>1</code> 表示标准输出，默认为1，所以 <code>&quot;&gt;/dev/null&quot;</code> 等同于 <code>&quot;1&gt;/dev/null&quot;</code>；</li>
<li><code>2</code> 表示标准错误；</li>
<li><code>&amp; </code>表示等同于的意思，<code>2&gt;&amp;1</code>表示2的输出重定向等同于1;</li>
</ul>
<p><code>&gt;/dev/null 2&gt;&amp;1</code>的意思就是：标准输出重定向到空设备文件，也就是<code>不输出任何信息到终端</code>；标准错误输出重定向等同于标准输出,因为之前标准输出已经重定向到了空设备文件，所以标准错误输出也重定向到空设备文件。</p>
</blockquote>
<p>打开浏览器，在地址栏输入 <code>http://localhost:8888/index.html</code>，便可以看到 Redis 实例的监控数据。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/01/05/4Ok5BsH7jqSUbtW.png"></p>
<h3 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h3><h4 id="slowlog"><a href="#slowlog" class="headerlink" title="slowlog"></a>slowlog</h4><p>slowlog是redis用于记录记录慢查询执行时间的日志系统。由于slowlog只保存在内存中，因此slowlog的效率很高，完全不用担心会影响到redis的性能。Slowlog是Redis从2.2.12版本引入的一条命令。</p>
<p>在redis.conf中有关于slowlog的设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 只有query执行时间大于slowlog-log-slower-than的才会定义成慢查询，才被slowlog进行记录，单位：微秒，默认是10000微妙，也就是10ms </span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"># 表示慢查询最大的条数，当slowlog超过设定的最大值后，会将最早的slowlog删除，是个FIFO队列</span><br><span class="line">slowlog-max-len 100</span><br></pre></td></tr></table></figure>

<p>用法：</p>
<ul>
<li>get：获取慢查询日志，也可以使用SLOWLOG GET N命令获取指定的条数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG GET 1</span><br><span class="line">1) 1) (integer) 26            // slowlog唯一编号id</span><br><span class="line">   2) (integer) 1440057815    // 查询的时间戳</span><br><span class="line">   3) (integer) 47            // 查询的耗时（微妙），如表示本条命令查询耗时47微秒</span><br><span class="line">   4) 1) &quot;SLOWLOG&quot;            // 查询命令，完整命令为 SLOWLOG GET，slowlog最多保存前面的31个key和128字符</span><br><span class="line">      2) &quot;GET&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li>len：获取慢查询日志条目数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; SLOWLOG LEN</span><br><span class="line">(integer) 4</span><br></pre></td></tr></table></figure>

<ul>
<li>reset：重置慢查询日志</li>
</ul>
<h4 id="info-1"><a href="#info-1" class="headerlink" title="info"></a>info</h4><p>可以一次性获取所有的信息，也可以按块获取信息</p>
<table>
<thead>
<tr>
<th>块信息</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>server</td>
<td>服务器运行的环境参数</td>
</tr>
<tr>
<td>clients</td>
<td>已连接客户端信息</td>
</tr>
<tr>
<td>memory</td>
<td>服务器运行内存统计数据</td>
</tr>
<tr>
<td>persistence</td>
<td>RDB 和 AOF 持久化的相关信息</td>
</tr>
<tr>
<td>stats</td>
<td>一般统计数据</td>
</tr>
<tr>
<td>Replication</td>
<td>主从复制相关信息</td>
</tr>
<tr>
<td>CPU</td>
<td>CPU使用情况</td>
</tr>
<tr>
<td>cluster</td>
<td>集群信息</td>
</tr>
<tr>
<td>keyspace</td>
<td>数据库相关的统计信息息</td>
</tr>
</tbody></table>
<p>终端info命令使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-cli info 按块获取信息 | grep 需要过滤的参数</span><br></pre></td></tr></table></figure>

<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/01/06/AsGgvfFMzdLEHjV.png"></p>
<blockquote>
<p>在理想情况下， <code>used_memory_rss 的值应该只比 used_memory稍微高一点儿</code>。</p>
<ul>
<li>当 <code>rss &gt; used</code> ，且两者的值相差较大时，表示存在（内部或外部的）内存碎片。内存碎片的比率可以通过 <code>mem_fragmentation_ratio</code> 的值看出。</li>
<li>当 <code>used &gt; rss</code> 时，表示Redis的部分内存被操作系统换出到交换空间了，在这种情况下，<code>操作可能会产生明显的延迟</code>。</li>
<li>当 Redis 释放内存时，分配器可能会，也可能不会，将内存返还给操作系统。如果 Redis 释放了内存，却没有将内存返还给操作系统，那么<code>used_memory</code>的值可能和操作系统显示的 Redis 内存占用并不一致。查看 <code>used_memory_peak</code> 的值可以验证这种情况是否发生。</li>
</ul>
</blockquote>
<!-- flag of hidden posts --></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/SpringBoot/">SpringBoot</a><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E7%BC%93%E5%AD%98/">缓存</a><a class="post-meta__tags" href="/tags/NoSQL/">NoSQL</a><a class="post-meta__tags" href="/tags/%E9%AB%98%E5%8F%AF%E7%94%A8/">高可用</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a><a class="post-meta__tags" href="/tags/%E5%93%A8%E5%85%B5%E6%9C%BA%E5%88%B6/">哨兵机制</a><a class="post-meta__tags" href="/tags/%E9%9B%86%E7%BE%A4/">集群</a><a class="post-meta__tags" href="/tags/RDB%E3%80%81AOF%E6%8C%81%E4%B9%85%E5%8C%96/">RDB、AOF持久化</a><a class="post-meta__tags" href="/tags/%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/">淘汰策略</a><a class="post-meta__tags" href="/tags/LRU%E3%80%81LFU%E7%AE%97%E6%B3%95/">LRU、LFU算法</a><a class="post-meta__tags" href="/tags/%E7%A9%BF%E9%80%8F%E3%80%81%E5%87%BB%E7%A9%BF%E3%80%81%E9%9B%AA%E5%B4%A9/">穿透、击穿、雪崩</a><a class="post-meta__tags" href="/tags/%E9%A2%84%E7%83%AD%E3%80%81%E9%99%8D%E7%BA%A7/">预热、降级</a><a class="post-meta__tags" href="/tags/%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7/">指标监控</a><a class="post-meta__tags" href="/tags/Jedis/">Jedis</a><a class="post-meta__tags" href="/tags/Servelet/">Servelet</a><a class="post-meta__tags" href="/tags/RedisTemplate/">RedisTemplate</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/06/01/f2n9FbBvNVCiAxp.png" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button" type="button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/file/wechat.jpg" alt="微信" onclick="window.open('/file/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2022/05/25/Redis高效点赞与取消功能/" title="Redis高效点赞与取消功能"><img class="relatedPosts_cover" data-src="https://s2.loli.net/2022/05/25/re4jlqbU9tEQPak.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-05-30</div><div class="relatedPosts_title">Redis高效点赞与取消功能</div></div></a></div><div class="relatedPosts_item"><a href="/2022/02/28/Druid监控统计数据源/" title="Druid监控统计数据源"><img class="relatedPosts_cover" data-src="https://s2.loli.net/2022/02/28/tKqbMuLTH21mkXN.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-02-28</div><div class="relatedPosts_title">Druid监控统计数据源</div></div></a></div><div class="relatedPosts_item"><a href="/2021/07/13/Rabbitmq 消息延迟推送--插件模式/" title="Rabbitmq 消息延迟推送--插件模式"><img class="relatedPosts_cover" data-src="https://i.loli.net/2021/07/13/6aACnGzELbBDu9r.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-06-01</div><div class="relatedPosts_title">Rabbitmq 消息延迟推送--插件模式</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/22/用好SpringBoot内置工具类/" title="用好SpringBoot内置工具类"><img class="relatedPosts_cover" data-src="https://s2.loli.net/2022/03/22/aWmpkPE8tzr74cw.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-03-22</div><div class="relatedPosts_title">用好SpringBoot内置工具类</div></div></a></div><div class="relatedPosts_item"><a href="/2021/04/13/非对称加密RSA与对称加密AES项目应用/" title="非对称加密RSA与对称加密AES项目应用"><img class="relatedPosts_cover" data-src="https://i.loli.net/2020/11/22/OfJAQYFuVa9whLZ.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-02-23</div><div class="relatedPosts_title">非对称加密RSA与对称加密AES项目应用</div></div></a></div><div class="relatedPosts_item"><a href="/2022/06/01/延迟任务的10种实现方式/" title="延迟任务的10种实现方式"><img class="relatedPosts_cover" data-src="https://s2.loli.net/2022/06/01/f2n9FbBvNVCiAxp.png"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-06-01</div><div class="relatedPosts_title">延迟任务的10种实现方式</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'eKp2wzPKybiFid4KXcVFcyMX-gzGzoHsz',
      appKey: 'RSA7FDJfrFwpawTfG1vE6R71',
      placeholder: 'minkeyto@qq.com',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div></div></div></article></main><footer id="footer" style="background-image: url(https://s2.loli.net/2021/12/08/Xx7Fw6ApNDICcsz.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By 灵熙云</div><div class="framework-info"><span>Copyright Ⓒ 灵熙云工作室. All rights reserved.</span></div><div class="footer_custom_text">Hi, welcome to my blog !</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://fastly.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://fastly.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>