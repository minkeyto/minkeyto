<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Redis分布式锁的8大坑 | 灵熙云工作室</title><meta name="description" content="在分布式系统中，由于Redis分布式锁相对于更简单和高效，成为了分布式锁的首先，被用到了很多实际业务场景当中。 但不是说用了Redis分布式锁，就可以高枕无忧了，如果没有用好或者用对，也会引来一些意想不到的问题。 今天一起聊聊Redis分布式锁的一些坑，给有需要的朋友一个参考。  非原子操作使用Redis的分布式锁，首先想到的可能是setNx命令。 if (jedis.setnx(lockKey,"><meta name="keywords" content="可重入锁,主从复制,Redis分布式锁,原子性,读写锁,lua脚本,RedissonRedLock,Redisson"><meta name="author" content="灵熙云,minkeyto@qq.com"><meta name="copyright" content="灵熙云"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/file/favicon.png"><link rel="canonical" href="http://www.goitman.cn/2022/06/29/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%848%E5%A4%A7%E5%9D%91/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta name="msvalidate.01" content="8izvf3GqbX"/><meta property="og:type" content="article"><meta property="og:title" content="Redis分布式锁的8大坑"><meta property="og:url" content="http://www.goitman.cn/2022/06/29/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%848%E5%A4%A7%E5%9D%91/"><meta property="og:site_name" content="灵熙云工作室"><meta property="og:description" content="在分布式系统中，由于Redis分布式锁相对于更简单和高效，成为了分布式锁的首先，被用到了很多实际业务场景当中。 但不是说用了Redis分布式锁，就可以高枕无忧了，如果没有用好或者用对，也会引来一些意想不到的问题。 今天一起聊聊Redis分布式锁的一些坑，给有需要的朋友一个参考。  非原子操作使用Redis的分布式锁，首先想到的可能是setNx命令。 if (jedis.setnx(lockKey,"><meta property="og:image" content="https://s2.loli.net/2022/06/29/wOHE6nSBAbjF9Dd.jpg"><meta property="article:published_time" content="2022-06-29T08:27:46.652Z"><meta property="article:modified_time" content="2022-06-29T08:37:09.518Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="一键部署Redis任意版本" href="http://www.goitman.cn/2022/07/06/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2Redis%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC/"><link rel="next" title="SpringBoot打包 + shell脚本部署" href="http://www.goitman.cn/2022/06/21/SpringBoot%E6%89%93%E5%8C%85%20+%20shell%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5c009f46ba6df7bc385f101477536214";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://fastly.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2022-06-29 16:37:09'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/effect.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/file/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">47</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">182</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">16</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%9E%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">非原子操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BF%98%E4%BA%86%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">2.</span> <span class="toc-text">忘了释放锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E4%BA%86%E5%88%AB%E4%BA%BA%E7%9A%84%E9%94%81"><span class="toc-number">3.</span> <span class="toc-text">释放了别人的锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E9%87%8F%E5%A4%B1%E8%B4%A5%E8%AF%B7%E6%B1%82"><span class="toc-number">4.</span> <span class="toc-text">大量失败请求</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E9%87%8D%E5%85%A5%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">锁重入问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E7%AB%9E%E4%BA%89%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">锁竞争问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">6.1.</span> <span class="toc-text">读写锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%88%86%E6%AE%B5"><span class="toc-number">6.2.</span> <span class="toc-text">锁分段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">锁超时问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">主从复制的问题</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://s2.loli.net/2022/06/29/wOHE6nSBAbjF9Dd.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">灵熙云工作室</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/notes/"><i class="fa-fw fa fa-book"></i><span> 笔记</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Redis分布式锁的8大坑</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2022-06-29 16:27:46"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2022-06-29</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2022-06-29 16:37:09"><i class="fas fa-history fa-fw"></i> 更新于 2022-06-29</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/">技术专题</a><i class="fas fa-angle-right post-meta__separator"></i><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/%E6%8A%80%E6%9C%AF%E4%B8%93%E9%A2%98/%E7%BC%93%E5%AD%98/">缓存</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">6.1k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 20 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2022/06/29/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%848%E5%A4%A7%E5%9D%91/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2022/06/29/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%848%E5%A4%A7%E5%9D%91/" itemprop="commentCount"></span></a></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>在分布式系统中，由于<code>Redis分布式锁</code>相对于更简单和高效，成为了分布式锁的首先，被用到了很多实际业务场景当中。</p>
<p>但不是说用了Redis分布式锁，就可以高枕无忧了，如果没有用好或者用对，也会引来一些意想不到的问题。</p>
<p>今天一起聊聊Redis分布式锁的一些坑，给有需要的朋友一个参考。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/27/oElAm2ZWiQgkObT.png"></p>
<h1 id="非原子操作"><a href="#非原子操作" class="headerlink" title="非原子操作"></a>非原子操作</h1><p>使用Redis的分布式锁，首先想到的可能是<code>setNx命令</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (jedis.setnx(lockKey, val) == <span class="number">1</span>) &#123;</span><br><span class="line">   jedis.expire(lockKey, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>容易，三下五除二就可以把代码写好。</p>
<blockquote>
<p>这段代码确实可以加锁成功，但<code>有没有发现什么问题？</code></p>
<p>加锁操作和后面的设置超时时间是分开的，并非原子操作。</p>
<p>假如加锁成功，但是设置<code>超时时间失败了，该lockKey就变成永不失效</code>。假如<code>在高并发场景中，有大量的lockKey加锁成功了，但不会失效，有可能直接导致redis内存空间不</code>足。</p>
</blockquote>
<p>那么，有没有保证原子性的加锁命令呢？</p>
<p>答案是：有，请看下面。</p>
<h1 id="忘了释放锁"><a href="#忘了释放锁" class="headerlink" title="忘了释放锁"></a>忘了释放锁</h1><p>上面说到使用<code>setNx命令加锁</code>操作和设置超时时间是分开的，并非原子操作。</p>
<p>而在Redis中还有<code>set命令</code>，该命令可以指定多个参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line"><span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>lockKey：锁的标识</li>
<li>requestId：请求id</li>
<li>NX：只在键不存在时，才对键进行设置操作。</li>
<li>PX：设置键的过期时间为 millisecond 毫秒。</li>
<li>expireTime：过期时间</li>
</ul>
</blockquote>
<p><code>set命令是原子操作</code>，加锁和设置超时时间，一个命令就能轻松搞定。</p>
<p>使用<code>set命令加锁</code>，表面上看起来没有问题。但如果仔细想想，<code>加锁之后，每次都要达到了超时时间才释放锁，会不会有点不合理？</code>加锁后，如果不及时释放锁，会有很多问题。</p>
<p>分布式锁更合理的用法是：</p>
<blockquote>
<ol>
<li>手动加锁</li>
<li>业务操作</li>
<li>手动释放锁</li>
<li>如果手动释放锁失败了，则达到超时时间，redis会自动释放锁。</li>
</ol>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/y8EmnMdsCFDKkIr.png"></p>
<p>那么问题来了，如何释放锁呢？</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    unlock(lockKey);</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<p>需要捕获业务代码的异常，然后在finally中释放锁。换句话说就是：<code>无论代码执行成功或失败了，都需要释放锁。</code></p>
<p>此时，有些朋友可能会问：<code>假如刚好在释放锁的时候，系统被重启了，或者网络断线了，或者机房断点了，不也会导致释放锁失败？</code></p>
<p>这是一个好问题，因为这种小概率问题确实存在。</p>
<p>但还记得前面给锁设置过超时时间吗？即使出现异常情况造成释放锁失败，但到了设定的超时时间，锁还是会被Redis自动释放。</p>
<p>但<code>只在finally中释放锁，就够了吗？</code></p>
<h1 id="释放了别人的锁"><a href="#释放了别人的锁" class="headerlink" title="释放了别人的锁"></a>释放了别人的锁</h1><p>做人要厚道，先回答上面的问题：<code>只在finally中释放锁，当然是不够的，因为释放锁的姿势，还是不对。</code></p>
<p>哪里不对？</p>
<blockquote>
<p>答：<code>在多线程场景中，可能会出现释放了别人的锁的情况。</code></p>
</blockquote>
<p>有些朋友可能会反驳：假设在多线程场景中，线程A获取到了锁，但如果线程A没有释放锁，此时，线程B是获取不到锁的，何来释放了别人锁之说？</p>
<blockquote>
<p>答：<code>假如线程A和线程B，都使用lockKey加锁。线程A加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间。这时候，Redis会自动释放lockKey锁。此时，线程B就能给lockKey加锁成功了，接下来执行它的业务操作。恰好这个时候，线程A执行完了业务功能，接下来，在finally方法中释放了锁lockKey。这不就出问题了，线程B的锁，被线程A释放了。</code></p>
</blockquote>
<p>这个时候，线程B肯定哭晕在厕所里，并且嘴里还振振有词。</p>
<p>那么，如何解决这个问题呢？</p>
<p>不知道注意到没？<code>在使用set命令加锁时，除了使用lockKey锁标识，还多设置了一个参数：requestId，为什么要需要记录requestId呢？</code></p>
<blockquote>
<p>答：requestId是在释放锁的时候用的。</p>
</blockquote>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (jedis.get(lockKey).equals(requestId)) &#123;</span><br><span class="line">    jedis.del(lockKey);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>在释放锁的时候，先获取到该锁的值（之前设置值就是requestId），然后<code>判断跟之前设置的值是否相同，如果相同才允许删除锁，返回成功。如果不同，则直接返回失败。</code></p>
<blockquote>
<p>换句话说就是：自己只能释放自己加的锁，不允许释放别人加的锁。</p>
</blockquote>
<p>这里为什么要用requestId，用userId不行吗？</p>
<blockquote>
<p>答：如果用userId的话，对于请求来说并不唯一，多个不同的请求，可能使用同一个userId。而requestId是全局唯一的，不存在加锁和释放锁乱掉的情况。</p>
</blockquote>
<p>此外，使用lua脚本，也能解决释放了别人的锁的问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then </span><br><span class="line"> return redis.call(&#x27;del&#x27;, KEYS[1]) </span><br><span class="line">else </span><br><span class="line">  return 0 </span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>lua脚本能保证查询锁是否存在和删除锁是原子操作，用它来释放锁效果更好一些。</p>
<p>说到lua脚本，其实加锁操作也建议使用lua脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then</span><br><span class="line">    redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1); </span><br><span class="line">    redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span><br><span class="line"> return nil; </span><br><span class="line">end</span><br><span class="line">if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1)</span><br><span class="line">   redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); </span><br><span class="line">   redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span><br><span class="line">  return nil; </span><br><span class="line">end; </span><br><span class="line">return redis.call(&#x27;pttl&#x27;, KEYS[1]);</span><br></pre></td></tr></table></figure>

<p>这是Redisson框架的加锁代码，写的不错，大家可以借鉴一下。</p>
<p>有趣，下面还有哪些好玩的东西？</p>
<h1 id="大量失败请求"><a href="#大量失败请求" class="headerlink" title="大量失败请求"></a>大量失败请求</h1><p>上面的加锁方法看起来好像没有问题，但如果仔细想想，<code>如果有1万的请求同时去竞争那把锁，可能只有一个请求是成功的，其余的9999个请求都会失败。</code></p>
<p>在秒杀场景下，会有什么问题？</p>
<blockquote>
<p>答：每1万个请求，有1个成功。再1万个请求，有1个成功。如此下去，直到库存不足。这就变成均匀分布的秒杀了，跟想象中的不一样。</p>
</blockquote>
<p>如何解决这个问题呢？</p>
<p>此外，还有一种场景：</p>
<blockquote>
<p>比如，有两个线程同时上传文件到sftp，上传文件前先要创建目录。假设两个线程需要创建的目录名都是当天的日期，比如：20210920，如果不做任何控制，直接并发的创建目录，第二个线程必然会失败。</p>
</blockquote>
<p>这时候有些朋友可能会说：这还不容易，加一个Redis分布式锁就能解决问题了，此外再判断一下，如果目录已经存在就不创建，只有目录不存在才需要创建。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">  <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">       mkdir(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock(lockKey,requestId);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p>一切看似美好，但经不起仔细推敲。</p>
<p>来自灵魂的一问：<code>第二个请求如果加锁失败了，接下来，是返回失败，还是返回成功呢？</code></p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/yAdoqeiSknwQlCX.png"></p>
<p><code>显然第二个请求，肯定是不能返回失败的，如果返回失败了，这个问题还是没有被解决。</code>如果文件还没有上传成功，直接返回成功会有更大的问题。头疼，到底该如何解决呢？</p>
<blockquote>
<p>答：使用<code>自旋锁</code>。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="type">Long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!exists(path)) &#123;</span><br><span class="line">           mkdir(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     </span><br><span class="line">     <span class="type">long</span> <span class="variable">time</span> <span class="operator">=</span> System.currentTimeMillis() - start;</span><br><span class="line">      <span class="keyword">if</span> (time&gt;=timeout) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          Thread.sleep(<span class="number">50</span>);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">    unlock(lockKey,requestId);</span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>

<p><code>在规定的时间，比如500毫秒内，自旋不断尝试加锁（说白了，就是在死循环中，不断尝试加锁），如果成功则直接返回。如果失败，则休眠50毫秒，再发起新一轮的尝试。如果到了超时时间，还未加锁成功，则直接返回失败。</code></p>
<p>好吧，学到一招了，还有吗？</p>
<h1 id="锁重入问题"><a href="#锁重入问题" class="headerlink" title="锁重入问题"></a>锁重入问题</h1><p>都知道<code>Redis分布式锁是互斥的</code>。假如对某个key加锁了，如果该key对应的锁还没失效，再用相同key去加锁，大概率会失败。</p>
<p>没错，大部分场景是没问题的。</p>
<p>为什么说是大部分场景呢？</p>
<p>因为还有这样的场景：</p>
<blockquote>
<p>假设在某个请求中，需要获取一颗满足条件的菜单树或者分类树。以<code>菜单</code>为例，这就需要在接口中从根节点开始，递归遍历出所有满足条件的子节点，然后组装成一颗菜单树。</p>
<p>需要注意的是菜单不是一成不变的，在后台系统中运营同学可以动态添加、修改和删除菜单。为了保证在并发的情况下，每次都可能获取最新的数据，这里可以加<code>Redis分布式锁</code>。</p>
<p>加<code>Redis分布式锁</code>的思路是对的。但接下来问题来了，<code>在递归方法中递归遍历多次，每次都是加的同一把锁。递归第一层当然是可以加锁成功的，但递归第二层、第三层...第N层，不就会加锁失败了？</code></p>
</blockquote>
<p>递归方法中加锁的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> level,String lockKey,String requestId)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">     <span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> jedis.set(lockKey, requestId, <span class="string">&quot;NX&quot;</span>, <span class="string">&quot;PX&quot;</span>, expireTime);</span><br><span class="line">     <span class="keyword">if</span> (<span class="string">&quot;OK&quot;</span>.equals(result)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(level&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">           <span class="built_in">this</span>.fun(++level,lockKey,requestId);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     unlock(lockKey,requestId);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你直接这么用，看起来好像没有问题。但最终执行程序之后发现，等待你的结果只有一个：<code>出现异常</code>。</p>
<p>因为<code>从根节点开始，第一层递归加锁成功，还没释放锁，就直接进入第二层递归。因为锁名为lockKey，并且值为requestId的锁已经存在，所以第二层递归大概率会加锁失败，然后返回到第一层。第一层接下来正常释放锁，然后整个递归方法直接返回了。</code></p>
<p>这下子，大家知道出现什么问题了吧？</p>
<p>没错，递归方法其实只执行了第一层递归就返回了，其他层递归由于加锁失败，根本没法执行。</p>
<p>那么这个问题该如何解决呢？</p>
<blockquote>
<p>答：使用<code>可重入锁</code>。</p>
</blockquote>
<p>以<code>Redisson框架为例，它的内部实现了可重入锁的功能</code>。</p>
<p>由此可见，Redisson在Redis分布式锁中的江湖地位很高。</p>
<p>伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">expireTime</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(String lockKey)</span> &#123;</span><br><span class="line">  <span class="type">RLock</span> <span class="variable">lock</span> <span class="operator">=</span> redisson.getLock(lockKey);</span><br><span class="line">  <span class="built_in">this</span>.fun(lock,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">fun</span><span class="params">(RLock lock,<span class="type">int</span> level)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span>&#123;</span><br><span class="line">      lock.lock(<span class="number">5</span>, TimeUnit.SECONDS);</span><br><span class="line">      <span class="keyword">if</span>(level&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">         <span class="built_in">this</span>.fun(lock,++level);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">     lock.unlock();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码也许并不完美，这里只是给了一个大致的思路，如果大家有这方面需求的话，以上代码仅供参考。</p>
<p>接下来，聊聊Redisson可重入锁的实现原理。</p>
<p>加锁主要是通过以下脚本实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) </span><br><span class="line">then  </span><br><span class="line">   redis.call(&#x27;hset&#x27;, KEYS[1], ARGV[2], 1);        redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span><br><span class="line">   return nil; </span><br><span class="line">end;</span><br><span class="line">if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) </span><br><span class="line">then  </span><br><span class="line">  redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); </span><br><span class="line">  redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); </span><br><span class="line">  return nil; </span><br><span class="line">end;</span><br><span class="line">return redis.call(&#x27;pttl&#x27;, KEYS[1]);</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>KEYS[1]：锁名</li>
<li>ARGV[1]：过期时间</li>
<li>ARGV[2]：uuid + “:” + threadId，可认为是requestId</li>
</ul>
</blockquote>
<ol>
<li>先判断如果锁名不存在，则加锁。</li>
<li>接下来，判断如果锁名和requestId值都存在，则使用hincrby命令给该锁名和requestId值计数，每次都加1。注意一下，这里就是重入锁的关键，锁重入一次值就加1。</li>
<li>如果锁名存在，但值不是requestId，则返回过期时间。</li>
</ol>
<p>释放锁主要是通过以下脚本实现的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[3]) == 0) </span><br><span class="line">then </span><br><span class="line">  return nil</span><br><span class="line">end</span><br><span class="line">local counter = redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[3], -1);</span><br><span class="line">if (counter &gt; 0) </span><br><span class="line">then </span><br><span class="line">    redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[2]); </span><br><span class="line">    return 0; </span><br><span class="line"> else </span><br><span class="line">   redis.call(&#x27;del&#x27;, KEYS[1]); </span><br><span class="line">   redis.call(&#x27;publish&#x27;, KEYS[2], ARGV[1]); </span><br><span class="line">   return 1; </span><br><span class="line">end; </span><br><span class="line">return nil</span><br></pre></td></tr></table></figure>

<ol>
<li>先判断如果锁名和requestId值不存在，则直接返回。</li>
<li>如果锁名和requestId值存在，则重入锁减1。</li>
<li>如果减1后，重入锁的value值还大于0，说明还有引用，则重试设置过期时间。</li>
<li>如果减1后，重入锁的value值还等于0，则可以删除锁，然后发消息通知等待线程抢锁。</li>
</ol>
<blockquote>
<p>再次强调一下，如果系统可以容忍数据暂时不一致，有些场景不加锁也行，这里只是举个例子，本节内容并不适用于所有场景。</p>
</blockquote>
<h1 id="锁竞争问题"><a href="#锁竞争问题" class="headerlink" title="锁竞争问题"></a>锁竞争问题</h1><p>如果有大量需要写入数据的业务场景，使用普通的redis分布式锁是没有问题的。</p>
<p>但如果<code>有些业务场景，写入的操作比较少，反而有大量读取的操作。这样直接使用普通的Redis分布式锁，会不会有点浪费性能？</code></p>
<p>都知道，锁的粒度越粗，多个线程抢锁时竞争就越激烈，造成多个线程锁等待的时间也就越长，性能也就越差。</p>
<p>所以，<code>提升Redis分布式锁性能的第一步，就是要把锁的粒度变细</code>。</p>
<h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>众所周知，加锁的目的是为了保证，在并发环境中读写数据的安全性，即不会出现数据错误或者不一致的情况。</p>
<p>但在绝大多数实际业务场景中，一般是读数据的频率远远大于写数据。而线程间的并发读操作是并不涉及并发安全问题，我们没有必要给读操作加互斥锁，只要保证读写、写写并发操作上锁是互斥的就行，这样可以提升系统的性能。</p>
<p>以Redisson框架为例，它内部已经实现了读写锁的功能。</p>
<p><code>读锁</code>的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;readWriteLock&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> readWriteLock.readLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    rLock.lock();</span><br><span class="line">    <span class="comment">//业务操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>写锁</code>的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">RReadWriteLock</span> <span class="variable">readWriteLock</span> <span class="operator">=</span> redisson.getReadWriteLock(<span class="string">&quot;readWriteLock&quot;</span>);</span><br><span class="line"><span class="type">RLock</span> <span class="variable">rLock</span> <span class="operator">=</span> readWriteLock.writeLock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    rLock.lock();</span><br><span class="line">    <span class="comment">//业务操作</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">   log.error(e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>将读锁和写锁分开，最大的好处是提升读操作的性能，因为读和读之间是共享的，不存在互斥性</code>。而实际业务场景中，绝大多数数据操作都是读操作。所以，如果提升了读操作的性能，也就会提升整个锁的性能。</p>
<p>下面总结一个读写锁的特点：</p>
<blockquote>
<ul>
<li>读与读是共享的，不互斥</li>
<li>读与写互斥</li>
<li>写与写互斥</li>
</ul>
</blockquote>
<h2 id="锁分段"><a href="#锁分段" class="headerlink" title="锁分段"></a>锁分段</h2><p>此外，为了减小锁的粒度，比较常见的做法是将大锁：<code>分段</code>。</p>
<p>在java中<code>ConcurrentHashMap</code>，就是将数据分为<code>16段</code>，每一段都有单独的锁，并且处于不同锁段的数据互不干扰，以此来提升锁的性能。</p>
<p>放在实际业务场景中，可以这样做：</p>
<blockquote>
<p>比如在秒杀扣库存的场景中，现在的库存中有2000个商品，用户可以秒杀。为了防止出现超卖的情况，通常情况下，可以对库存加锁。如果有1W的用户竞争同一把锁，显然系统吞吐量会非常低。</p>
<p>为了提升系统性能，可以<code>将库存分段</code>，比如：<code>分为100段，这样每段就有20个商品可以参与秒杀</code>。</p>
<p>在秒杀的过程中，<code>先把用户id获取hash值，然后除以100取模。模为1的用户访问第1段库存，模为2的用户访问第2段库存，模为3的用户访问第3段库存，后面以此类推，到最后模为100的用户访问第100段库存</code>。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/8ULJ6WZi1INvAtu.png"></p>
<p>如此一来，在多线程环境中，可以大大的减少锁的冲突。以前多个线程只能同时竞争1把锁，尤其在秒杀的场景中，竞争太激烈了，简直可以用惨绝人寰来形容，其后果是导致绝大数线程在锁等待。现在多个线程同时竞争100把锁，等待的线程变少了，从而系统吞吐量也就提升了。</p>
<blockquote>
<p>注：将锁分段虽说可以提升系统的性能，但它也会让系统的复杂度提升不少。因为它需要引入额外的<code>路由算法，跨段统计</code>等功能。在实际业务场景中，需要综合考虑，不是说一定要将锁分段。</p>
</blockquote>
<h1 id="锁超时问题"><a href="#锁超时问题" class="headerlink" title="锁超时问题"></a>锁超时问题</h1><p>在前面提到过，如果线程A加锁成功了，但是由于业务功能耗时时间很长，超过了设置的超时时间，这时候Redis会自动释放线程A加的锁。</p>
<blockquote>
<p>有些朋友可能会说：到了超时时间，锁被释放了就释放了呗，对功能又没啥影响。</p>
<p>答：错，错，错。对功能其实有影响。</p>
</blockquote>
<p>通常加锁的目的是：<code>为了防止访问临界资源时，出现数据异常的情况</code>。比如：<code>线程A在修改数据C的值，线程B也在修改数据C的值，如果不做控制，在并发情况下，数据C的值会出问题</code>。</p>
<p>为了保证某个方法，或者段代码的互斥性，即如果线程A执行了某段代码，是不允许其他线程在某一时刻同时执行的，可以用<code>synchronized</code>关键字加锁。</p>
<p>但这种锁有很大的局限性，只能保证单个节点的互斥性。如果需要在多个节点中保持互斥性，就需要用<code>Redis分布式锁</code>。</p>
<p>做了这么多铺垫，现在回到正题。</p>
<p>假设线程A加<code>Redis分布式锁</code>的代码，包含代码1和代码2两段代码。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/2NspyucJ1tgmUkv.png"></p>
<p>由于该线程要执行的业务操作非常耗时，程序在执行完代码1的时，已经到了设置的超时时间，Redis自动释放了锁。而代码2还没来得及执行。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/yHrvqENxfX5upid.png"></p>
<p>此时，代码2相当于裸奔的状态，无法保证互斥性。假如它里面访问了临界资源，并且其他线程也访问了该资源，可能就会出现数据异常的情况。（<code>访问临界资源，不单单指读取，还包含写入</code>）</p>
<p>那么，如何解决这个问题呢？</p>
<blockquote>
<p>答：如果达到了超时时间，但业务代码还没执行完，需要给锁自动续期。</p>
</blockquote>
<p>可以使用<code>TimerTask</code>类，来实现自动续期的功能：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>(); </span><br><span class="line">timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">(Timeout timeout)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">      <span class="comment">//自动续期逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">10000</span>, TimeUnit.MILLISECONDS);</span><br></pre></td></tr></table></figure>

<p>获取锁之后，自动开启一个定时任务，每隔10秒钟，自动刷新一次过期时间。这种机制在<code>Redisson框架</code>中，有个比较霸气的名字：<code>watch dog</code>，即传说中的看门狗。</p>
<p>当然自动续期功能，还是优先推荐使用<code>lua脚本</code>实现，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then </span><br><span class="line">   redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]);</span><br><span class="line">  return 1; </span><br><span class="line">end;</span><br><span class="line">return 0;</span><br></pre></td></tr></table></figure>

<p>需要注意的地方是：在实现自动续期功能时，还需要设置一个总的过期时间，可以跟Redisson保持一致，设置成30秒。如果业务代码到了这个总的过期时间，还没有执行完，就不再自动续期了。</p>
<blockquote>
<p>自动续期的功能是获取锁之后开启一个定时任务，每隔10秒判断一下锁是否存在，如果存在，则刷新过期时间。如果续期3次，也就是30秒之后，业务方法还是没有执行完，就不再续期了。</p>
</blockquote>
<h1 id="主从复制的问题"><a href="#主从复制的问题" class="headerlink" title="主从复制的问题"></a>主从复制的问题</h1><p>上面花了这么多篇幅介绍的内容，对单个Redis实例是没有问题的。</p>
<p>but，如果Redis存在多个实例。比如：<code>做了主从，或者使用了哨兵模式，基于Redis的分布式锁的功能，就会出现问题</code>。</p>
<p>具体是什么问题？</p>
<p>假设redis现在用的主从模式，1个master节点，3个slave节点。master节点负责写数据，slave节点负责读数据。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/mBDYckgoUyA3nVS.png"></p>
<p>本来是和谐共处，相安无事的。Redis加锁操作，都在master上进行，加锁成功后，再异步同步给所有的slave。</p>
<p>突然有一天，<code>master节点由于某些不可逆的原因，挂掉了</code>。</p>
<p>这样<code>需要找一个slave升级为新的master节点</code>，假如slave1被选举出来了。</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/dgTkwVNeoXODEys.png"></p>
<p>如果<code>有个锁A比较悲催，刚加锁成功master就挂了，还没来得及同步到slave1</code>。</p>
<p>这样会导致新master节点中的锁A丢失了。后面，如果有新的线程，使用锁A加锁，依然可以成功，分布式锁失效了。</p>
<p>那么，如何解决这个问题呢？</p>
<blockquote>
<p>答：Redisson框架为了解决这个问题，提供了一个专门的类：RedissonRedLock，使用了Redlock算法。</p>
</blockquote>
<p>RedissonRedLock解决问题的思路如下：</p>
<blockquote>
<ol>
<li>需要搭建几套相互独立的Redis环境，假如我们在这里搭建了5套。</li>
<li>每套环境都有一个<code>Redisson node</code>节点。</li>
<li>多个<code>Redisson node</code>节点组成了<code>RedissonRedLock</code>。</li>
<li>环境包含：单机、主从、哨兵和集群模式，可以是一种或者多种混合。</li>
</ol>
</blockquote>
<p>在这里以主从为例，架构图如下：</p>
<p><img src= "/img/loading.gif" data-src="https://s2.loli.net/2022/06/29/sCuwecjak7UYpF8.png"></p>
<p><code>RedissonRedLock</code>加锁过程如下：</p>
<blockquote>
<ol>
<li>获取所有的<code>Redisson node</code>节点信息，循环向所有的<code>Redisson node</code>节点加锁，假设<code>节点数为N</code>，例子中<code>N等于5</code>。</li>
<li>如果在N个节点当中，有<code>N/2 + 1</code>个节点加锁成功了，那么整个<code>RedissonRedLock加锁</code>是<code>成功</code>的。</li>
<li>如果在N个节点当中，<code>小于N/2 + 1</code>个节点加锁成功，那么整个<code>RedissonRedLock加锁</code>是<code>失败</code>的。</li>
<li>如果中途发现各个节点加锁的总耗时，大于等于设置的最大等待时间，则直接返回失败。</li>
</ol>
</blockquote>
<p>从上面可以看出，使用<code>Redlock算法</code>，确实能解决多实例场景中，假如master节点挂了，导致分布式锁失效的问题。</p>
<p>但也引出了一些新问题，比如：</p>
<blockquote>
<ol>
<li>需要额外搭建多套环境，申请更多的资源，需要评估一下成本和性价比。</li>
<li>如果有N个redisson node节点，需要加锁N次，最少也需要加锁N&#x2F;2+1次，才知道redlock加锁是否成功。显然，增加了额外的时间成本，有点得不偿失。</li>
</ol>
</blockquote>
<p>由此可见，在实际业务场景，尤其是高并发业务中，<code>RedissonRedLock</code>其实使用的并不多。</p>
<p>在分布式环境中，CAP是绕不过去的。</p>
<blockquote>
<p>CAP指的是在一个分布式系统中：</p>
<ul>
<li>一致性（Consistency）</li>
<li>可用性（Availability）</li>
<li>分区容错性（Partition tolerance）</li>
</ul>
</blockquote>
<p>这三个要素最多只能同时实现两点，不可能三者兼顾。</p>
<p>如果实际业务场景，更需要的是保证数据<code>一致性</code>。那么请<code>使用CP类型的分布式锁</code>，比如：<code>zookeeper</code>，它是基于磁盘的，性能可能没那么好，但数据一般不会丢。</p>
<p>如果你的实际业务场景，更需要的是保证数据高<code>可用性</code>。那么请<code>使用AP类型的分布式锁</code>，比如：<code>Redis</code>，它是基于内存的，性能比较好，但有丢失数据的风险。</p>
<blockquote>
<p>其实，在我们绝大多数分布式业务场景中，使用Redis分布式锁就够了，真的别太较真。因为数据不一致问题，可以通过最终一致性方案解决。但如果系统不可用了，对用户来说是暴击一万点伤害。</p>
</blockquote>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81/">可重入锁</a><a class="post-meta__tags" href="/tags/%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/">主从复制</a><a class="post-meta__tags" href="/tags/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/">Redis分布式锁</a><a class="post-meta__tags" href="/tags/%E5%8E%9F%E5%AD%90%E6%80%A7/">原子性</a><a class="post-meta__tags" href="/tags/%E8%AF%BB%E5%86%99%E9%94%81/">读写锁</a><a class="post-meta__tags" href="/tags/lua%E8%84%9A%E6%9C%AC/">lua脚本</a><a class="post-meta__tags" href="/tags/RedissonRedLock/">RedissonRedLock</a><a class="post-meta__tags" href="/tags/Redisson/">Redisson</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/07/29/klA3qRFYvzTdMjV.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://fastly.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://fastly.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button" type="button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/file/wechat.jpg" alt="微信" onclick="window.open('/file/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/07/06/%E4%B8%80%E9%94%AE%E9%83%A8%E7%BD%B2Redis%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC/"><img class="prev-cover" data-src="https://s2.loli.net/2022/07/06/VOcJRdtLrA7oP18.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">一键部署Redis任意版本</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/21/SpringBoot%E6%89%93%E5%8C%85%20+%20shell%E8%84%9A%E6%9C%AC%E9%83%A8%E7%BD%B2/"><img class="next-cover" data-src="https://s2.loli.net/2022/06/21/RJUQtBcfWdCZIMF.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot打包 + shell脚本部署</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/09/16/Java中那18把金刚锁/" title="Java中那18把"金刚"锁"><img class="relatedPosts_cover" data-src="https://i.loli.net/2021/09/16/sZXckh2A83uMfVe.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2021-09-16</div><div class="relatedPosts_title">Java中那18把"金刚"锁</div></div></a></div><div class="relatedPosts_item"><a href="/2022/03/21/限流组件设计实战/" title="限流组件设计实战"><img class="relatedPosts_cover" data-src="https://s2.loli.net/2022/03/21/6xYg7RHKFiOWlAf.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fas fa-history fa-fw"></i> 2022-06-02</div><div class="relatedPosts_title">限流组件设计实战</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'eKp2wzPKybiFid4KXcVFcyMX-gzGzoHsz',
      appKey: 'RSA7FDJfrFwpawTfG1vE6R71',
      placeholder: 'minkeyto@qq.com',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://fastly.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div></div></div></article></main><footer id="footer" style="background-image: url(https://s2.loli.net/2022/06/29/wOHE6nSBAbjF9Dd.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By 灵熙云</div><div class="framework-info"><span>Copyright Ⓒ 灵熙云工作室. All rights reserved.</span></div><div class="footer_custom_text">Hi, welcome to my blog !</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a target="_blank" rel="noopener" href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://fastly.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://fastly.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://fastly.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://fastly.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://fastly.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="https://fastly.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js"></script><script>document.addEventListener('DOMContentLoaded', function() {
  pangu.autoSpacingPage()
})</script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://fastly.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script></body></html>