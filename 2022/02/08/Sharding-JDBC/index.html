<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Sharding-JDBC 分库分表 | 灵熙云工作室</title><meta name="robots" content="noindex"><meta name="keywords" content="Sharding-JDBC,分库分表,分片策略,分片算法"><meta name="author" content="灵熙云,minkeyto@qq.com"><meta name="copyright" content="灵熙云"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="概述分库分表是什么随着公司业务快速发展，数据库中的数据量猛增，访问性能也变慢了，优化迫在眉睫。分析一下问题出现在哪儿呢？ 关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。  方案1： 通过提升服务器硬件能力来提高数据处理能力，比如增加存储容量 、CPU等，这">
<meta property="og:type" content="article">
<meta property="og:title" content="Sharding-JDBC 分库分表">
<meta property="og:url" content="http://www.goitman.cn/2022/02/08/Sharding-JDBC/index.html">
<meta property="og:site_name" content="灵熙云工作室">
<meta property="og:description" content="概述分库分表是什么随着公司业务快速发展，数据库中的数据量猛增，访问性能也变慢了，优化迫在眉睫。分析一下问题出现在哪儿呢？ 关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。  方案1： 通过提升服务器硬件能力来提高数据处理能力，比如增加存储容量 、CPU等，这">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2022/02/09/XoaQR4cJu3bPyZD.jpg">
<meta property="article:published_time" content="2022-02-08T09:36:10.403Z">
<meta property="article:modified_time" content="2022-02-09T02:43:21.719Z">
<meta property="article:author" content="灵熙云">
<meta property="article:tag" content="Sharding-JDBC">
<meta property="article:tag" content="分库分表">
<meta property="article:tag" content="分片策略">
<meta property="article:tag" content="分片算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s2.loli.net/2022/02/09/XoaQR4cJu3bPyZD.jpg"><link rel="shortcut icon" href="/file/favicon.png"><link rel="canonical" href="http://www.goitman.cn/2022/02/08/Sharding-JDBC/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Sharding-JDBC 分库分表',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2022-02-09 10:43:21'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/effect.css"><meta name="generator" content="Hexo 6.2.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/file/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">123</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 专题笔记</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Redis"><i class="fa-fw /2020/08/17/Redis/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Log4j2"><i class="fa-fw /2021/12/06/Log4j2/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Sharding-JDBC"><i class="fa-fw /2022/02/08/Sharding-JDBC/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2022/02/09/XoaQR4cJu3bPyZD.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">灵熙云工作室</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fa fa-list"></i><span> 专题笔记</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/Redis"><i class="fa-fw /2020/08/17/Redis/"></i><span> 0</span></a></li><li><a class="site-page child" href="/Log4j2"><i class="fa-fw /2021/12/06/Log4j2/"></i><span> 1</span></a></li><li><a class="site-page child" href="/Sharding-JDBC"><i class="fa-fw /2022/02/08/Sharding-JDBC/"></i><span> 2</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Sharding-JDBC 分库分表</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-08T09:36:10.403Z" title="发表于 2022-02-08 17:36:10">2022-02-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-09T02:43:21.719Z" title="更新于 2022-02-09 10:43:21">2022-02-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>63分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="分库分表是什么"><a href="#分库分表是什么" class="headerlink" title="分库分表是什么"></a>分库分表是什么</h2><p>随着公司业务快速发展，数据库中的数据量猛增，访问性能也变慢了，优化迫在眉睫。分析一下问题出现在哪儿呢？ 关系型数据库本身比较容易成为系统瓶颈，单机存储容量、连接数、处理能力都有限。当单表的数据量达到1000W或100G以后，由于查询维度较多，即使添加从库、优化索引，做很多操作时性能仍下降严重。</p>
<blockquote>
<p><code>方案1</code>：</p>
<p>通过提升服务器硬件能力来提高数据处理能力，比如增加存储容量 、CPU等，这种方案成本很高，并且如果瓶颈在MySQL本身那么提高硬件也是有限的。</p>
</blockquote>
<blockquote>
<p><code>方案2</code>：</p>
<p><code>把数据分散在不同的数据库中，使得单一数据库的数据量变小来缓解单一数据库的性能问题，从而达到提升数据库性能的目的</code>。</p>
</blockquote>
<p>如下图：将电商数据库拆分为<code>若干独立的数据库</code>，并且对于<code>大表也拆分为若干小表</code>，通过这种数据库拆分的方法来解决数据库的性能问题。</p>
<p><img src="https://s2.loli.net/2022/01/18/qtoNh1mXRPg5KTr.png"></p>
<blockquote>
<p><code>分库分表</code>就是为了解决由于数据量过大而导致<code>数据库性能降低</code>的问题，将原来<code>独立的数据库</code>拆分成<code>若干数据库</code>组成，将数据<code>大表</code>拆分成<code>若干数据表</code>组成，使得单一数据库、单一数据表的数据量变小，从而达到提升数据库性能的目的。</p>
</blockquote>
<h2 id="分库分表的方式"><a href="#分库分表的方式" class="headerlink" title="分库分表的方式"></a>分库分表的方式</h2><p>分库分表包括分库和分表两个部分，在生产中通常包括：<code>垂直分库</code>、<code>垂直分表</code>、<code>水平分库</code>、<code>水平分表</code>四种方式。</p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>通常在商品列表中是不显示商品详情信息的，如下图：</p>
<p><img src="https://s2.loli.net/2022/01/18/CYSu1O6JMdElXxv.png"></p>
<p>用户在浏览商品列表时，只有对某商品感兴趣时才会查看该商品的详细描述。因此，商品信息中<code>商品描述字段访问频次较低，且该字段存储占用空间较大，访问单个数据IO时间较长</code>；商品信息中<code>商品名称、商品图片、商品价格等其他字段数据访问频次较高</code>。</p>
<p>由于可将访问频次低的商品描述信息单独存放在一张表中，访问频次较高的商品基本信息单独放在一张表中。</p>
<p><img src="https://s2.loli.net/2022/01/18/ZV6THiuSja9bv2E.png"></p>
<p>商品列表可采用以下sql：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span>,r.[地理区域名称],s.[店铺名称],s.[信誉]</span><br><span class="line"><span class="keyword">FROM</span>  [商品信息]  p</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  [地理区域]  r  <span class="keyword">ON</span>  p.[产地]  <span class="operator">=</span>  r.[地理区域编码]</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  [店铺信息]  s  <span class="keyword">ON</span>  p.id  <span class="operator">=</span>  s.[所属店铺]</span><br><span class="line">WHERE...ORDER  BY...LIMIT...</span><br></pre></td></tr></table></figure>
<p>需要获取商品描述时，再通过以下sql获取：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span>  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span>  [商品描述]</span><br><span class="line"><span class="keyword">WHERE</span>  [商品ID]  <span class="operator">=</span>  ?</span><br></pre></td></tr></table></figure>
<p>这一步优化，就叫<code>垂直分表</code>。</p>
<blockquote>
<p>垂直分表是指<code>将一个表按照字段分成多表，每个表存储其中一部分字段。</code></p>
</blockquote>
<p>带来的<code>提升</code>是：</p>
<blockquote>
<ol>
<li>为了避免IO争抢并减少锁表的几率，查看详情的用户与商品信息浏览互不影响</li>
<li>充分发挥热门数据的操作效率，商品信息的操作的高效率不会被商品描述的低效率所拖累。</li>
</ol>
</blockquote>
<p>一般来说，某业务实体中的各个数据项的访问频次是不一样的，部分数据项可能是占用存储空间比较大的BLOB或是TEXT。例如上例中的商品描述。所以，当表数据量很大时，可以将表按字段切开，将热门字段、冷门字段分开放置在不同库中，这些库可以放在不同的存储设备上，避免IO争抢。<code>垂直切分带来的性能提升主要集中在热门数据的操作效率上，而且磁盘争用情况减少。</code></p>
<p>通常按以下<code>原则进行垂直拆分</code>:</p>
<blockquote>
<ol>
<li>把不常用的字段单独放在一张表;</li>
<li>把text，blob等大字段拆分出来放在附表中;</li>
<li>经常组合查询的列放在一张表中;</li>
</ol>
</blockquote>
<h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>通过垂直分表性能得到了一定程度的提升，但是还没有达到要求，并且磁盘空间也快不够了，因为数据还是始终限制在一台服务器，<code>库内垂直分表只解决了单一表数据量过大的问题，但没有将表分布到不同的服务器上，因此每个表还是竞争同一个物理机的CPU、内存、网络IO、磁盘。</code></p>
<p>经过思考，把原有的<code>SELLER_DB(卖家库)</code>，分为了<code>PRODUCT_DB(商品库)</code>和<code>STORE_DB(店铺库)</code>，并把这两个库分散到不同服务器，如下图：</p>
<p><img src="https://s2.loli.net/2022/01/18/onGPVzsuiFjH4N9.png"></p>
<p>由于<code>商品信息与商品描述业务耦合度较高</code>，因此一起被存放在<code>PRODUCT_DB(商品库)</code>；而<code>店铺信息相对独立</code>，因此单独被存放在<code>STORE_DB(店铺库)</code>。</p>
<p>这一步优化，就叫<code>垂直分库</code>。</p>
<blockquote>
<p>垂直分库是指按照<code>业务</code>将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是<code>专库专用</code>。</p>
</blockquote>
<p>它带来的<code>提升</code>是：</p>
<blockquote>
<ol>
<li>解决业务层面的耦合，业务清晰</li>
<li>能对不同业务的数据进行分级管理、维护、监控、扩展等</li>
<li>高并发场景下，垂直分库一定程度的提升IO、数据库连接数、降低单机硬件资源的瓶颈</li>
</ol>
</blockquote>
<p>垂直分库通过<code>将表按业务分类</code>，然后分布在不同数据库，并且可以将这些数据库部署在不同服务器上，从而达到多个服务器共同分摊压力的效果，但是依然没有解决单表数据量过大的问题。</p>
<h3 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h3><p>经过垂直分库后，数据库性能问题得到一定程度的解决，但是随着业务量的增长，<code>PRODUCT_DB(商品库)单库</code>存储数据已经超出预估。假设目前有8w店铺，每个店铺平均150个不同规格的商品，再算上增长，那商品数量得往1500w+上预估，并且PRODUCT_DB(商品库)属于访问非常频繁的资源，单台服务器已经无法支撑。此时该如何优化？</p>
<p>再次分库？但是从业务角度分析，目前情况已经无法再次垂直分库。</p>
<p>尝试水平分库，将<code>店铺ID为单数的和店铺ID为双数</code>的商品信息分别放在两个库中。</p>
<p><img src="https://s2.loli.net/2022/01/18/2w5lPp68K4td9bg.png"></p>
<p>也就是说，要操作某条数据，先分析这条数据所属的店铺ID。如果<code>店铺ID为双数，将此操作映射至RRODUCT_DB1(商品库1)</code>；如果<code>店铺ID为单数，将操作映射至RRODUCT_DB2(商品库2)</code>。此操作要访问数据库名称的表达式为<code>RRODUCT_DB[店铺ID%2 + 1] </code>。</p>
<p>这一步优化，就叫<code>水平分库</code>。</p>
<blockquote>
<p>水平分库是<code>把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上</code>。</p>
</blockquote>
<p>它带来的<code>提升</code>是：</p>
<blockquote>
<ol>
<li>解决了单库大数据，高并发的性能瓶颈。</li>
<li>提高了系统的稳定性及可用性。</li>
</ol>
</blockquote>
<p>当一个应用<code>难以再细粒度的垂直切分</code>，或<code>切分后数据量行数巨大，存在单库读写、存储性能瓶颈</code>，这时候就需要进行水平分库了，经过水平切分的优化，往往能解决单库存储量及性能瓶颈。但<code>由于同一个表被分配在不同的数据 库，需要额外进行数据操作的路由工作，因此大大提升了系统复杂度</code>。</p>
<h3 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a>水平分表</h3><p>按照水平分库的思路把<code>PRODUCT_DB_X(商品库)</code>内的表也可以进行水平拆分，其目的也是为解决单表数据量大的问题，如下图：</p>
<p><img src="https://s2.loli.net/2022/01/18/kt5YQoplGEXzgBd.png"></p>
<p>与水平分库的思路类似，不过这次操作的目标是表，商品信息及商品描述被分成了两套表。如果<code>商品ID为双数，将此操作映射至商品信息1表</code>；如果<code>商品ID为单数，将操作映射至商品信息2表</code>。此操作要访问表名称的表达式为<code>商品信息[商品ID%2 + 1] </code>。</p>
<p>这一步优化，就叫<code>水平分表</code>。</p>
<blockquote>
<p>水平分表是在<code>同一个数据库内，把同一个表的数据按一定规则拆到多个表中</code>。</p>
</blockquote>
<p>它带来的<code>提升</code>是：</p>
<blockquote>
<ol>
<li>优化单一表数据量过大而产生的性能问题</li>
<li>避免IO争抢并减少锁表的几率</li>
</ol>
</blockquote>
<p>库内的水平分表，解决了单一表数据量过大的问题，分出来的小表中只包含一部分数据，从而使得单个表的数据量变小，提高检索性能。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p><code>垂直分表</code>：可以把一个宽表的字段按访问频次、是否是大字段的原则拆分为多个表，这样既能使业务清晰，还能提升部分性能。拆分后，<code>尽量从业务角度避免联查，否则性能方面将得不偿失</code>。</p>
</li>
<li><p><code>垂直分库</code>：可以把多个表按业务耦合松紧归类，分别存放在不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案。但是它<code>需要解决跨库带来的所有复杂问题</code>。</p>
</li>
<li><p><code>水平分库</code>：可以把一个表的数据(按数据行)分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。它不仅<code>需要解决跨库带来的所有复杂问题</code>，还<code>要解决数据路由的问题</code>。</p>
</li>
<li><p><code>水平分表</code>：可以把一个表的数据(按数据行)分到多个同一个数据库的多张表中，每个表只有这个表的部分数据，这样做能小幅提升性能，它仅仅<code>作为水平分库的一个补充优化</code>。</p>
</li>
</ul>
<p>一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑<code>缓存</code>、<code>读写分离</code>、<code>索引技术</code>等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案。</p>
<h2 id="分库分表带来的问题"><a href="#分库分表带来的问题" class="headerlink" title="分库分表带来的问题"></a>分库分表带来的问题</h2><p>分库分表能有效的缓解了单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题。</p>
<h3 id="事务一致性问题"><a href="#事务一致性问题" class="headerlink" title="事务一致性问题"></a>事务一致性问题</h3><p>由于分库分表把数据分布在不同库甚至不同服务器，不可避免会带来<code>分布式事务</code>问题。</p>
<h3 id="跨节点关联查询"><a href="#跨节点关联查询" class="headerlink" title="跨节点关联查询"></a>跨节点关联查询</h3><p>在没有分库前，检索商品时可以通过以下SQL对店铺信息进行关联查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> p.<span class="operator">*</span>,r.[地理区域名称],s.[店铺名称],s.[信誉]</span><br><span class="line"><span class="keyword">FROM</span>  [商品信息]  p</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  [地理区域]  r  <span class="keyword">ON</span>  p.[产地]  <span class="operator">=</span>  r.[地理区域编码]</span><br><span class="line"><span class="keyword">LEFT</span>  <span class="keyword">JOIN</span>  [店铺信息]  s  <span class="keyword">ON</span>  p.id  <span class="operator">=</span>  s.[所属店铺]</span><br><span class="line">WHERE...ORDER  BY...LIMIT...</span><br></pre></td></tr></table></figure>

<p>但垂直分库后<code>[商品信息]</code>和<code>[店铺信息]</code>不在一个数据库，甚至不在一台服务器，无法进行关联查询。</p>
<p>可将原关联查询<code>分为两次查询</code>，第一次查询的结果集中找出关联数据id，然后根据id发起第二次请求得到关联数据，最后将获得到的数据进行拼装。</p>
<h3 id="跨节点分页、排序函数"><a href="#跨节点分页、排序函数" class="headerlink" title="跨节点分页、排序函数"></a>跨节点分页、排序函数</h3><p>跨节点多库进行查询时，limit分页、order by排序等问题，就变得比较复杂了。需要<code>先在不同的分片节点中将数据进行排序并返回，然后将不同分片返回的结果集进行汇总和再次排序</code>。</p>
<p>如，进行水平分库后的商品库，按ID倒序排序分页，取第一页：</p>
<p><img src="https://s2.loli.net/2022/01/18/LbVgsjGCHPeZ5R8.png"></p>
<p>以上流程是取第一页的数据，性能影响不大，但由于商品信息的分布在各数据库的数据可能是随机的，如果是取第N页，需要将所有节点前N页数据都取出来合并，再进行整体的排序，操作效率可想而知。所以请求页数越大，系统的性能也会越差。</p>
<p>在使用Max、Min、Sum、Count之类的函数进行计算的时候，与排序分页同理，也需要先在每个分片上执行相应的函数，然后将各个分片的结果集进行汇总和再次计算，最终将结果返回。</p>
<h3 id="主键避重"><a href="#主键避重" class="headerlink" title="主键避重"></a>主键避重</h3><p>在分库分表环境中，由于表中数据同时存在不同数据库中，主键值平时使用的自增长将无用武之地，某个分区数据库生成的<code>ID无法保证全局唯一</code>。因此需要<code>单独设计全局主键</code>，以避免跨库主键重复问题。</p>
<p><img src="https://s2.loli.net/2022/01/18/FnBCMSWz8lAXvsH.png"></p>
<h3 id="公共表"><a href="#公共表" class="headerlink" title="公共表"></a>公共表</h3><p>实际的应用场景中，参数表、数据字典表等都是数据量较小，变动少，而且属于高频联合查询的依赖表。例子中地理区域表也属于此类型。<br>可以将这类表在每个数据库都保存一份，所有对公共表的更新操作都同时发送到所有分库执行。</p>
<p>由于分库分表之后，数据被分散在不同的数据库、服务器。因此，对数据的操作也就无法通过常规方式完成，并且它还带来了一系列的问题。</p>
<h1 id="Sharding-JDBC"><a href="#Sharding-JDBC" class="headerlink" title="Sharding-JDBC"></a>Sharding-JDBC</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Sharding-JDBC是当当网研发的开源分布式数据库中间件，<code>从 3.0 开始Sharding-JDBC被包含在 Sharding-Sphere 中</code>，之后该项目进入进入Apache孵化器，4.0版本之后的版本为Apache版本。</p>
<blockquote>
<p><code>ShardingSphere</code>是一套开源的<code>分布式数据库中间件</code>解决方案组成的生态圈，它由<code>Sharding-JDBC</code>、<code>Sharding- Proxy</code>和<code>Sharding-Sidecar</code>这3款相互独立的产品组成。 他们均提供标准化的<code>数据分片</code>、<code>分布式事务</code>和<code>数据库治理</code>功能，可适用于如Java同构、异构语言、容器、云原生等各种多样化的应用场景。</p>
</blockquote>
<p>Sharding-JDBC定位为<code>轻量级Java框架</code>，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p>
<p>Sharding-JDBC的<code>核心</code>功能为<code>数据分片</code>和<code>读写分离</code>，通过Sharding-JDBC，应用可以透明的使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关心数据源的数量以及数据如何分布。</p>
<blockquote>
<ul>
<li>适用于任何基于Java的<code>ORM框架</code>，如： <code>Hibernate</code>、<code>Mybatis</code>、<code>Spring JDBC Template</code>或直接使用<code>JDBC</code>。</li>
<li>基于任何第三方的数据库<code>连接池</code>，如：<code>DBCP</code>、<code>C3P0</code>、<code>BoneCP</code>、 <code>Druid</code>、<code>HikariCP</code>等。</li>
<li>支持任意实现JDBC规范的<code>数据库</code>。目前支持<code>MySQL</code>、<code>Oracle</code>、<code>SQLServer</code>和<code>PostgreSQL</code>。</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/18/qFlahyIpLMDUZxm.png"></p>
<p>上图展示了Sharding-Jdbc的工作方式，使用Sharding-Jdbc前需要<code>人工对数据库进行分库分表</code>，在应用程序中加入Sharding-Jdbc的Jar包，应用程序通过Sharding-Jdbc操作分库分表后的数据库和数据表，由于Sharding-Jdbc是对Jdbc驱动的增强，使用Sharding-Jdbc就像使用Jdbc驱动一样，在应用程序中是无需指定具体要操作的分库和分表。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><ul>
<li>性能损耗测试：服务器资源充足、并发数相同，比较JDBC和Sharding-JDBC性能损耗，Sharding-JDBC相对JDBC损耗不超过7%。</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/18/jNJqL54GzgQwRxa.png"><br><img src="https://s2.loli.net/2022/01/18/R8yjK5rMfQezOHs.png"></p>
<ul>
<li>性能对比测试：服务器资源使用到极限，相同的场景JDBC与Sharding-JDBC的吞吐量相当。</li>
<li>性能对比测试：服务器资源使用到极限，Sharding-JDBC采用分库分表后，Sharding-JDBC吞吐量较JDBC不分表有接近2倍的提升。</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/18/q2hi4kzX3EgUv1s.png"></p>
<h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="需求说明"><a href="#需求说明" class="headerlink" title="需求说明"></a>需求说明</h3><p>使用Sharding-JDBC完成对订单表的水平分表，快速体验Sharding-JDBC的使用方法。</p>
<p>人工创建两张表，<code>t_order_1</code>和<code>t_order_2</code>，这两张表是订单表拆分后的表。</p>
<blockquote>
<ul>
<li>通过Sharding-Jdbc向订单表<code>插入数据</code>，按照一定的分片规则，主键为<code>偶数的进入t_order_1</code>，<code>另一部分数据进入t_order_2</code>；</li>
<li>通过Sharding-Jdbc <code>查询数据</code>，根据 SQL语句的内容从<code>t_order_1</code>或<code>t_order_2</code>查询数据；</li>
</ul>
</blockquote>
<h3 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h3><p>创建<code>订单库</code>order_db</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE `order_db` <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="string">&#x27;utf8&#x27;</span> <span class="keyword">COLLATE</span> <span class="string">&#x27;utf8_general_ci&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>在order_db中创建<code>t_order_1</code>、<code>t_order_2</code>表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_order_1`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order_1`   (</span><br><span class="line">`order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>, </span><br><span class="line">`price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单价格&#x27;</span>, </span><br><span class="line">`user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单用户id&#x27;</span>,</span><br><span class="line">`status` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci  ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> `t_order_2`; </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_order_2`   (</span><br><span class="line">`order_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单id&#x27;</span>, </span><br><span class="line">`price` <span class="type">decimal</span>(<span class="number">10</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单价格&#x27;</span>, </span><br><span class="line">`user_id` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;下单用户id&#x27;</span>,</span><br><span class="line">`status` <span class="type">varchar</span>(<span class="number">50</span>) <span class="type">CHARACTER</span> <span class="keyword">SET</span> utf8 <span class="keyword">COLLATE</span> utf8_general_ci <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;订单状态&#x27;</span>,</span><br><span class="line"><span class="keyword">PRIMARY</span> KEY (`order_id`) <span class="keyword">USING</span> BTREE</span><br><span class="line">) ENGINE <span class="operator">=</span> InnoDB <span class="type">CHARACTER</span> <span class="keyword">SET</span> <span class="operator">=</span> utf8 <span class="keyword">COLLATE</span> <span class="operator">=</span> utf8_general_ci  ROW_FORMAT <span class="operator">=</span> <span class="keyword">Dynamic</span>;</span><br></pre></td></tr></table></figure>

<h3 id="引入maven依赖"><a href="#引入maven依赖" class="headerlink" title="引入maven依赖"></a>引入maven依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.shardingsphere<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>sharding‐jdbc‐spring‐boot‐starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0‐RC1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="编写程序"><a href="#编写程序" class="headerlink" title="编写程序"></a>编写程序</h3><h4 id="分片规则配置"><a href="#分片规则配置" class="headerlink" title="分片规则配置"></a>分片规则配置</h4><p><code>分片规则</code>配置是sharding-jdbc进行对分库分表操作的重要依据，配置内容包括：<code>数据源</code>、<code>主键生成策略</code>、<code>分片策略</code>等。在<code>application.properties中</code>配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 此配置为水平分表</span><br><span class="line">server.port=56081</span><br><span class="line"></span><br><span class="line">spring.application.name = sharding‐jdbc‐simple‐demo</span><br><span class="line">server.servlet.context‐path = /sharding‐jdbc‐simple‐demo</span><br><span class="line">spring.http.encoding.enabled = true </span><br><span class="line">spring.http.encoding.charset = UTF‐8 </span><br><span class="line">spring.http.encoding.force = true</span><br><span class="line"></span><br><span class="line">spring.main.allow‐bean‐definition‐overriding = true</span><br><span class="line"></span><br><span class="line">mybatis.configuration.map‐underscore‐to‐camel‐case = true </span><br><span class="line"></span><br><span class="line"># 以下是分片规则配置</span><br><span class="line"># 定义数据源(数据源 m1，并对m1进行实际的参数配置)</span><br><span class="line">spring.shardingsphere.datasource.names = m1</span><br><span class="line"></span><br><span class="line">spring.shardingsphere.datasource.m1.type = com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">spring.shardingsphere.datasource.m1.driver‐class‐name = com.mysql.jdbc.Driver</span><br><span class="line">spring.shardingsphere.datasource.m1.url = jdbc:mysql://localhost:3306/order_db?useUnicode=true</span><br><span class="line">spring.shardingsphere.datasource.m1.username = root</span><br><span class="line">spring.shardingsphere.datasource.m1.password = root</span><br><span class="line"></span><br><span class="line"># 指定t_order表的数据分布情况，配置数据节点(指定t_order表的数据分布在m1.t_order_1、m1.t_order_2)</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.actual‐data‐nodes = m1.t_order_$‐&gt;&#123;1..2&#125;</span><br><span class="line"></span><br><span class="line"># 指定t_order表的主键生成策略为SNOWFLAKE(SNOWFLAKE是一种分布式自增算法，保证id全局唯一)</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.key‐generator.column=order_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.key‐generator.type=SNOWFLAKE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 指定t_order表的分片策略，分片策略包括分片键和分片算法(order_id为偶数的数据落在t_order_1，为奇数的落在t_order_2，分表策略的表达式为t_order_$-&gt;&#123;order_id % 2 + 1&#125;)</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.sharding‐column = order_id</span><br><span class="line">spring.shardingsphere.sharding.tables.t_order.table‐strategy.inline.algorithm‐expression = t_order_$‐&gt;&#123;order_id % 2 + 1&#125;</span><br><span class="line"></span><br><span class="line"># 打开sql输出日志</span><br><span class="line">spring.shardingsphere.props.sql.show = true</span><br><span class="line"></span><br><span class="line">swagger.enable = true</span><br><span class="line"></span><br><span class="line">logging.level.root = info</span><br><span class="line">logging.level.org.springframework.web = info</span><br><span class="line">logging.level.cn.goitman.dbsharding = debug</span><br><span class="line">logging.level.druid.sql = debug</span><br></pre></td></tr></table></figure>


<h4 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">OrderDao</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  新增订单</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@param</span>  price  订单价格</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@param</span> userId 用户id</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@param</span>  status  订单状态</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Insert(&quot;insert into t_order(price,user_id,status) value(#&#123;price&#125;,#&#123;userId&#125;,#&#123;status&#125;)&quot;)</span></span><br><span class="line">	<span class="type">int</span> <span class="title function_">insertOrder</span><span class="params">(<span class="meta">@Param(&quot;price&quot;)</span> BigDecimal price, <span class="meta">@Param(&quot;userId&quot;)</span>Long userId, <span class="meta">@Param(&quot;status&quot;)</span>String status)</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	*  根据id列表查询多个订单</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@param</span> orderIds 订单id列表</span></span><br><span class="line"><span class="comment">	*  <span class="doctag">@return</span> </span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="meta">@Select(&#123;&quot;&lt;script&gt;&quot; +</span></span><br><span class="line"><span class="meta">			&quot;select &quot; + </span></span><br><span class="line"><span class="meta">			&quot; * &quot; +</span></span><br><span class="line"><span class="meta">			&quot; from t_order t&quot; +</span></span><br><span class="line"><span class="meta">			&quot; where t.order_id in &quot; +</span></span><br><span class="line"><span class="meta">			&quot;&lt;foreach collection=&#x27;orderIds&#x27; item=&#x27;id&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&gt;&quot; + </span></span><br><span class="line"><span class="meta">			&quot; #&#123;id&#125; &quot; +</span></span><br><span class="line"><span class="meta">			&quot;&lt;/foreach&gt;&quot;+ </span></span><br><span class="line"><span class="meta">			&quot;&lt;/script&gt;&quot;&#125;)</span></span><br><span class="line">	List&lt;Map&gt; <span class="title function_">selectOrderbyIds</span><span class="params">(<span class="meta">@Param(&quot;orderIds&quot;)</span>List&lt;Long&gt; orderIds)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = &#123;ShardingJdbcSimpleDemoBootstrap.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OrderDaoTest</span> &#123;</span><br><span class="line">	<span class="meta">@Autowired</span></span><br><span class="line">	<span class="keyword">private</span> OrderDao orderDao;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testInsertOrder</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span> ; i&lt;<span class="number">10</span>; i++)&#123;</span><br><span class="line">			orderDao.insertOrder(<span class="keyword">new</span> <span class="title class_">BigDecimal</span>((i+<span class="number">1</span>)*<span class="number">5</span>),<span class="number">1L</span>,<span class="string">&quot;WAIT_PAY&quot;</span>); </span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSelectOrderbyIds</span><span class="params">()</span>&#123;</span><br><span class="line">		List&lt;Long&gt; ids = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); </span><br><span class="line">		ids.add(<span class="number">370969501279191040L</span>);</span><br><span class="line">		ids.add(<span class="number">370969500767485953L</span>);</span><br><span class="line">		List&lt;Map&gt; maps = orderDao.selectOrderbyIds(ids);</span><br><span class="line">		System.out.println(maps);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行testInsertOrder：<br><img src="https://s2.loli.net/2022/01/18/Zn84UgI2uYPoGbc.png"></p>
<p>通过日志可以发现order_id为奇数的被插入到t_order_2表，为偶数的被插入到t_order_1表，达到预期目标。</p>
<p>执行testSelectOrderbyIds：<br><img src="https://s2.loli.net/2022/01/18/f7F8YSqTrlEIjVH.png"></p>
<p>通过日志可以发现，根据传入order_id的奇偶不同，sharding-jdbc分别去不同的表检索数据，达到预期目标。</p>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>通过日志分析，Sharding-JDBC在拿到用户要执行的sql之后做了一下操作：</p>
<blockquote>
<ol>
<li>解析sql，获取片键值，在本例中是order_id</li>
<li>Sharding-JDBC通过规则配置 <code>t_order_$-&gt;&#123;order_id % 2 + 1&#125;</code>，当order_id为偶数时，应该往t_order_1表插数据，为奇数时，往t_order_2插数据。</li>
<li>于是Sharding-JDBC根据order_id的值改写sql语句，改写后的SQL语句是真实所要执行的SQL语句。</li>
<li>执行改写后的真实sql语句</li>
<li>将所有真正执行sql的结果进行汇总合并，返回。</li>
</ol>
</blockquote>
<h3 id="其他集成方式"><a href="#其他集成方式" class="headerlink" title="其他集成方式"></a>其他集成方式</h3><p>Sharding-JDBC除了支持上述application.properties配置外，还支持以下三种集成方式(<code>共支持四种集成方式</code>)</p>
<h4 id="Yaml-配置"><a href="#Yaml-配置" class="headerlink" title="Yaml 配置"></a>Yaml 配置</h4><p>Spring Boot定义application.yml，内容如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">56081</span></span><br><span class="line">  <span class="attr">servlet:</span></span><br><span class="line">    <span class="string">context‐path:</span> <span class="string">/sharding‐jdbc‐simple‐demo</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">sharding‐jdbc‐simple‐demo</span></span><br><span class="line">  <span class="attr">http:</span></span><br><span class="line">    <span class="attr">encoding:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">charset:</span> <span class="string">utf‐8</span></span><br><span class="line">    <span class="attr">force:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">main:</span></span><br><span class="line">    <span class="string">allow‐bean‐definition‐overriding:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">shardingsphere:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">      <span class="attr">names:</span>  <span class="string">m1</span></span><br><span class="line">      <span class="attr">m1:</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">com.alibaba.druid.pool.DruidDataSource</span></span><br><span class="line">        <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">        <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/order_db?useUnicode=true</span></span><br><span class="line">        <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">        <span class="attr">password:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">sharding:</span></span><br><span class="line">      <span class="attr">tables:</span></span><br><span class="line">        <span class="attr">t_order:</span></span><br><span class="line">          <span class="attr">actualDataNodes:</span> <span class="string">m1.t_order_$‐&gt;&#123;1..2&#125;</span></span><br><span class="line">          <span class="attr">tableStrategy:</span></span><br><span class="line">            <span class="attr">inline:</span></span><br><span class="line">              <span class="attr">shardingColumn:</span> <span class="string">order_id</span></span><br><span class="line">              <span class="attr">algorithmExpression:</span> <span class="string">t_order_$‐&gt;&#123;order_id</span> <span class="string">%</span> <span class="number">2</span> <span class="string">+</span> <span class="number">1</span><span class="string">&#125;</span></span><br><span class="line">          <span class="attr">keyGenerator:</span></span><br><span class="line">            <span class="attr">type:</span>  <span class="string">SNOWFLAKE</span></span><br><span class="line">            <span class="attr">column:</span> <span class="string">order_id</span></span><br><span class="line">    <span class="attr">props:</span></span><br><span class="line">      <span class="attr">sql:</span></span><br><span class="line">        <span class="attr">show:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="string">map‐underscore‐to‐camel‐case:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">swagger:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line">  <span class="attr">level:</span></span><br><span class="line">    <span class="attr">root:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">org.springframework.web:</span> <span class="string">info</span></span><br><span class="line">    <span class="attr">com.itheima.dbsharding:</span> <span class="string">debug</span></span><br><span class="line">    <span class="attr">druid.sql:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure>

<p>如果<code>使用application.yml则需要屏蔽原来的application.properties文件</code></p>
<h4 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShardingJdbcConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义数据源</span></span><br><span class="line">    Map&lt;String, DataSource&gt; <span class="title function_">createDataSourceMap</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">dataSource1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        dataSource1.setDriverClassName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        dataSource1.setUrl(<span class="string">&quot;jdbc:mysql://localhost:3306/order_db?useUnicode=true&quot;</span>);</span><br><span class="line">        dataSource1.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        dataSource1.setPassword(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        Map&lt;String, DataSource&gt; result = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        result.put(<span class="string">&quot;m1&quot;</span>, dataSource1);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义主键生成策略</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> KeyGeneratorConfiguration <span class="title function_">getKeyGeneratorConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">KeyGeneratorConfiguration</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">KeyGeneratorConfiguration</span>(<span class="string">&quot;SNOWFLAKE&quot;</span>, <span class="string">&quot;order_id&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义t_order表的分片策略</span></span><br><span class="line">    TableRuleConfiguration <span class="title function_">getOrderTableRuleConfiguration</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">TableRuleConfiguration</span> <span class="variable">result</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TableRuleConfiguration</span>(<span class="string">&quot;t_order&quot;</span>, <span class="string">&quot;m1.t_order_$‐&gt; &#123;1..2&#125;&quot;</span>);</span><br><span class="line">        result.setTableShardingStrategyConfig(<span class="keyword">new</span> <span class="title class_">InlineShardingStrategyConfiguration</span>(<span class="string">&quot;order_id&quot;</span>, <span class="string">&quot;t_order_$‐&gt;&#123;order_id % 2 + 1&#125;&quot;</span>));</span><br><span class="line">        result.setKeyGeneratorConfig(getKeyGeneratorConfiguration());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义sharding‐Jdbc数据源</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    DataSource <span class="title function_">getShardingDataSource</span><span class="params">()</span> <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="type">ShardingRuleConfiguration</span> <span class="variable">shardingRuleConfig</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShardingRuleConfiguration</span>();</span><br><span class="line">        shardingRuleConfig.getTableRuleConfigs().add(getOrderTableRuleConfiguration());</span><br><span class="line">        <span class="comment">//spring.shardingsphere.props.sql.show = true</span></span><br><span class="line">        <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">        properties.put(<span class="string">&quot;sql.show&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ShardingDataSourceFactory.createDataSource(createDataSourceMap(), shardingRuleConfig, properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于采用了<code>配置类</code>所以需<code>要屏蔽原来application.properties文件中spring.shardingsphere开头的配置信息</code>。还需要在<code>SpringBoot启动类中屏蔽使用spring.shardingsphere配置项的类</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication(exclude = &#123;SpringBootConfiguration.class&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShardingJdbcSimpleDemoBootstrap</span> &#123;....&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Spring命名空间配置-不推荐"><a href="#Spring命名空间配置-不推荐" class="headerlink" title="Spring命名空间配置(不推荐)"></a>Spring命名空间配置(不推荐)</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF‐8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema‐instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:p</span>=<span class="string">&quot;http://www.springframework.org/schema/p&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:sharding</span>=<span class="string">&quot;http://shardingsphere.apache.org/schema/shardingsphere/sharding&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/beans/spring‐beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://shardingsphere.apache.org/schema/shardingsphere/sharding</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://shardingsphere.apache.org/schema/shardingsphere/sharding/sharding.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/context/spring‐context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="string"><span class="tag">       http://www.springframework.org/schema/tx/spring‐tx.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;context:annotation‐config /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!‐‐定义多个数据源‐‐&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;m1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy</span>‐<span class="attr">method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/order_db_1?useUnicode=true&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    &lt;!‐‐定义分库策略‐‐&gt;</span><br><span class="line">    &lt;sharding:inline‐strategy id=&quot;tableShardingStrategy&quot; sharding‐column=&quot;order_id&quot; algorithm‐ expression=&quot;t_order_$‐&gt;&#123;order_id % 2 + 1&#125;&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!‐‐定义主键生成策略‐‐&gt;</span><br><span class="line">    &lt;sharding:key‐generator id=&quot;orderKeyGenerator&quot; type=&quot;SNOWFLAKE&quot; column=&quot;order_id&quot; /&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!‐‐定义sharding‐Jdbc数据源‐‐&gt;</span><br><span class="line">    &lt;sharding:data‐source id=&quot;shardingDataSource&quot;&gt;</span><br><span class="line">        &lt;sharding:sharding‐rule data‐source‐names=&quot;m1&quot;&gt;</span><br><span class="line">            &lt;sharding:table‐rules&gt;</span><br><span class="line">                &lt;sharding:table‐rule logic‐table=&quot;t_order&quot; table‐strategy‐ref=&quot;tableShardingStrategy&quot; key‐generator‐ref=&quot;orderKeyGenerator&quot; /&gt;</span><br><span class="line">            &lt;/sharding:table‐rules&gt;</span><br><span class="line">        &lt;/sharding:sharding‐rule&gt;</span><br><span class="line">    &lt;/sharding:data‐source&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="如何分库分表"><a href="#如何分库分表" class="headerlink" title="如何分库分表"></a>如何分库分表</h3><h4 id="逻辑表"><a href="#逻辑表" class="headerlink" title="逻辑表"></a>逻辑表</h4><p><code>水平拆分的数据表的总称</code>。例：订单数据表根据主键%2拆分为2张表，分别是<code>t_order_0</code>、<code>t_order_1</code>，他们的逻辑表名为<code>t_order</code> 。</p>
<p><img src="https://s2.loli.net/2022/01/24/HneIDuJshw5Opg3.png"></p>
<h4 id="真实表"><a href="#真实表" class="headerlink" title="真实表"></a>真实表</h4><p><code>在分片的数据库中真实存在的物理表</code>。即上个示例中的<code>t_order_0</code>到<code>t_order_1</code>。</p>
<h4 id="数据节点"><a href="#数据节点" class="headerlink" title="数据节点"></a>数据节点</h4><p><code>数据分片的最小物理单元</code>。由数据源名称和数据表组成，例：<code>ds_0.t_order_0</code>。</p>
<p><img src="https://s2.loli.net/2022/01/21/RnZlAKgYHSTGMyF.jpg" alt="数据源分片"></p>
<h4 id="绑定表"><a href="#绑定表" class="headerlink" title="绑定表"></a>绑定表</h4><p><code>指分片规则一致的主表和子表</code>。例如：<code>t_order</code>表和<code>t_order_item</code> 表，均按照<code>order_id</code>分片，<code>绑定表之间的分区键要完全相同，则此两张表互为绑定表关系</code>。<code>绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升</code>。</p>
<p><img src="https://s2.loli.net/2022/01/21/GTzjFSnPv4MfqEJ.png"></p>
<p>举例说明，如果SQL为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order o <span class="keyword">JOIN</span> t_order_item i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>不配置绑定表关系</code>时，假设分片键<code>order_id</code> 将数值10路由至第0片，将数值11路由至第1片，那么路由后的SQL应该为4条，它们呈现为笛卡尔积：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>

<p>在<code>配置绑定表关系</code>后，路由的SQL应该为2条：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_0 o <span class="keyword">JOIN</span> t_order_item_0 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> i.<span class="operator">*</span> <span class="keyword">FROM</span> t_order_1 o <span class="keyword">JOIN</span> t_order_item_1 i <span class="keyword">ON</span> o.order_id<span class="operator">=</span>i.order_id <span class="keyword">WHERE</span> o.order_id <span class="keyword">in</span> (<span class="number">10</span>, <span class="number">11</span>);</span><br></pre></td></tr></table></figure>



<h4 id="广播表"><a href="#广播表" class="headerlink" title="广播表"></a>广播表</h4><p>指所有的分片数据源中都存在的表，<code>表结构和表中的数据在每个数据库中均完全一致</code>。适用于<code>数据量不大</code>且<code>需要与海量数据的表进行关联查询的场景</code>，例如：<code>字典表</code>。</p>
<p><img src="https://s2.loli.net/2022/01/21/nT62b4gO9RW5aU3.png"></p>
<p>数据分库+读写分离<br><img src="https://s2.loli.net/2022/01/21/aoCwsKizDkfmVIu.jpg" alt="数据分库+读写分离"></p>
<h3 id="分布式唯一主键"><a href="#分布式唯一主键" class="headerlink" title="分布式唯一主键"></a>分布式唯一主键</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>在分布式环境中，分库分表之后，不同表生成全局唯一的Id是非常棘手的问题。因为在不同表之间的自增键是无法互相感知的，会造成重复Id的生成。当然可以通过约束表生成键的规则（设置不同的起始和步长）来达到数据的不重复，但是数据库节点变更会使框架缺乏扩展性。</p>
<p>目前有许多第三方解决方案可以完美解决这个问题，如:</p>
<blockquote>
<ul>
<li>UUID&#x2F;GUID(一般应用程序和数据库均支持)</li>
<li>Redis| increment</li>
<li>Mongo DB ObjectID( 类似UUID的方式 ）</li>
<li>Zookeeper分布式锁</li>
<li>Twitter的 Snowflake( 雪花算法 )</li>
<li>Ticket server(数据库生存方式, Flick采用的就是这种方式)</li>
</ul>
</blockquote>
<p>而 ShardingSphere不仅提供了<code>内置</code>的分布式主键生成器，例如<code>UUID</code>、 <code>Snowflake</code>。<code>还抽离出分布式主键生成器的接口</code>(io.shardingsphere.core.keygen.KeyGenerator)，方便用户自行实现自定义的自增主键生成器。</p>
<h4 id="雪花算法"><a href="#雪花算法" class="headerlink" title="雪花算法"></a>雪花算法</h4><p>snowflake算法是一款本地生成的（ID生成过程不依赖任何中间件，无网络通信），保证ID全局唯一，并且ID总体有序递增，</p>
<ul>
<li>组成结构</li>
</ul>
<p><img src="https://s2.loli.net/2022/01/25/LOs5cbkdwp1rNiY.png"></p>
<p>大致由：<code>首位无效符</code>、<code>时间戳差值</code>，<code>机器(进程)编码</code>，<code>序列号</code>四部分组成，雪花算法生成的ID是<code>纯数字且具有时间顺序</code>的。</p>
<blockquote>
<ol>
<li><code>1 bit</code>：<code>不用</code>，因为二进制里第一个bit为如果是1，那么都是负数，但是我们生成的 id 都是正数，所以<code>第一个 bit 统一都是 0</code></li>
<li><code>时间位</code>：可以根据时间进行排序，有助于提高查询速度。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2 ^ 41 - 1个毫秒值，换算成年就是表示 69 年的时间。</li>
<li><code>机器id位</code>：适用于分布式环境下对多节点的各个节点进行标识，可以具体根据节点数和部署情况设计，划分机器位10位长度，如划分5位表示进程位等，这个服务最多可以部署在2^10 台机器上，也就是 1024 台机器。</li>
<li><code>序列号位</code>：是一系列的自增id，可以支持同一节点同一毫秒生成多个ID序号，12位的计数序列号支持每个节点每毫秒产生4096个ID序号</li>
</ol>
</blockquote>
<ul>
<li>优点</li>
</ul>
<blockquote>
<ol>
<li>时间自增排序</li>
<li>适合分布式场景，整个分布式系统内不会产生ID碰撞（由datacenter和机器ID作区分）效率较高，一个节点每毫秒4096个ID序号，服务最大每毫秒409.6万个序列号</li>
</ol>
</blockquote>
<ul>
<li>缺点</li>
</ul>
<blockquote>
<ol>
<li>雪花算法在单机系统上ID是递增的，但是在分布式系统多节点的情况下不是绝对递增，所有节点的时钟（System.currentTimeMillis()）并不能保证<code>不完全同步</code>，所以有可能会出现不是全局递增的情况</li>
<li>不能在一台服务器上部署多个分布式ID服务；</li>
<li>时钟回拨问题；</li>
</ol>
</blockquote>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>ShardingSphere 在分片规则配置模块可配置每个表的主键生成策略，默认使用为<code>雪花算法</code>（io.shardingsphere.core.keygen.DefaultKeyGenerator）</p>
<ul>
<li>配置文件</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"># 主键生成 sharding jdbc 默认主键算法是 64位雪花算法</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.key-generator-class-name=io.shardingsphere.core.keygen.DefaultKeyGenerator</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.key-generator-column-name=id</span><br></pre></td></tr></table></figure>

<ul>
<li>使用DefaultKeyGenerator 类获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">DefaultKeyGenerator</span> <span class="variable">generator</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DefaultKeyGenerator</span>();</span><br><span class="line">generator.generateKey()；</span><br></pre></td></tr></table></figure>

<ul>
<li>对Snowflake时钟回拨问题处理</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">waitTolerateTimeDifferenceIfNeed</span><span class="params">(<span class="type">long</span> currentMilliseconds)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//lastMilliseconds 最后一次生成序列时间 </span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.lastMilliseconds &lt;= currentMilliseconds) &#123;</span><br><span class="line">           <span class="comment">//如果lastMilliseconds </span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">timeDifferenceMilliseconds</span> <span class="operator">=</span> <span class="built_in">this</span>.lastMilliseconds - currentMilliseconds;</span><br><span class="line">            Preconditions.checkState(timeDifferenceMilliseconds &lt; (<span class="type">long</span>) maxTolerateTimeDifferenceMilliseconds,</span><br><span class="line">                    <span class="string">&quot;Clock is moving backwards, last time is %d milliseconds, current time is %d milliseconds&quot;</span>,</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="built_in">this</span>.lastMilliseconds, currentMilliseconds&#125;);</span><br><span class="line">            Thread.sleep(timeDifferenceMilliseconds);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">        <span class="keyword">throw</span> var5;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/26/iGXwPIucQ9CNkJ5.png"></p>
<p><code>服务器时钟回拨会导致产生重复序列</code>，因此默认分布式主键生成器提供了一个最大容忍的时钟回拨毫秒数。如果时钟回拨的时间超过最大容忍的毫秒数值，则程序报错；<code>如果在可容忍的范围内，默认分布式主键生成器会等待（Thread.sleep）时钟同步到最后一次主键生成的时间后再继续工作</code>。最大容忍的时钟回拨毫秒数的默认值为0，可通过调用静态方法 <code>Defaultkey Generator setMaxTolerate Time DifferenceMilliseconds</code>设置</p>
<ul>
<li>主键实现理解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> Number <span class="title function_">generateKey</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">currentMilliseconds</span> <span class="operator">=</span> timeService.getCurrentMillis();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.waitTolerateTimeDifferenceIfNeed(currentMilliseconds)) &#123;</span><br><span class="line">        currentMilliseconds = timeService.getCurrentMillis();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lastMilliseconds == currentMilliseconds) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">0L</span> == (<span class="built_in">this</span>.sequence = <span class="built_in">this</span>.sequence + <span class="number">1L</span> &amp; <span class="number">4095L</span>)) &#123;</span><br><span class="line">            currentMilliseconds = <span class="built_in">this</span>.waitUntilNextTime(currentMilliseconds);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.vibrateSequenceOffset();</span><br><span class="line">        <span class="built_in">this</span>.sequence = (<span class="type">long</span>)<span class="built_in">this</span>.sequenceOffset;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">this</span>.lastMilliseconds = currentMilliseconds;</span><br><span class="line">    <span class="keyword">return</span> currentMilliseconds - EPOCH &lt;&lt; <span class="number">22</span> | workerId &lt;&lt; <span class="number">12</span> | <span class="built_in">this</span>.sequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>核心代码如下，几个实现的关键点：</p>
<blockquote>
<ol>
<li>synchronized保证线程安全；</li>
<li>如果出现时间回拨，判断时钟回拨的时间是否超过最大容忍的毫秒数值，如果超过抛出异常；</li>
<li>如果当前时间和上一次是同一秒时间，那么sequence自增。如果同一秒内sequence自增值超过<code>2^13-1</code>，那么就会自旋等待下一秒；</li>
<li>如果是新的一秒，那么sequence重新从0开始；</li>
</ol>
</blockquote>
<h3 id="分片规则"><a href="#分片规则" class="headerlink" title="分片规则"></a>分片规则</h3><blockquote>
<ul>
<li><code>随机分片</code>：hashcode 取模 (user_id % 片数量 ，取模结果为 0 ，insert t_user0,取模结果为 1，insert t_user1)</li>
<li><code>连续分片</code>: 时间范围int，可能会造成数据倾斜（每个库数据量不平衡）</li>
</ul>
</blockquote>
<p>根据业务需求来决定分片键，在业务之初分片键确定之后一般情况不更换，如果更换，对数据迁移，数据维护 非常的麻烦</p>
<h3 id="分片算法"><a href="#分片算法" class="headerlink" title="分片算法"></a>分片算法</h3><p>Sharding提供了以下4种算法接口：</p>
<blockquote>
<ul>
<li><code>精确分片算法</code>PreciseShardingAlgorithm：用于处理使用<code>单一键</code>作为分片键的 <code>= 与 IN 进行分片的场景</code>。需要配合StandardShardingStrategy使用。</li>
<li><code>范围分片算法</code>RangeShardingAlgorithm：用于处理使用<code>单一键</code>作为分片键的<code>BETWEEN AND进行分片的场景</code>。需要配合StandardShardingStrategy使用。如果需要使用RangeShardingAlgorithm，<code>必须和PreciseShardingAlgorithm配套使用</code>，否则会报错</li>
<li><code>Hint分片算法</code>HintShardingAlgorithm</li>
<li><code>复合分片算法</code>ComplexKeysShardingAlgorithm</li>
</ul>
</blockquote>
<h3 id="分片策略"><a href="#分片策略" class="headerlink" title="分片策略"></a>分片策略</h3><p>Sharding-JDBC中的分片策略有两个维度：</p>
<blockquote>
<ul>
<li><code>数据源分片策略</code>（DatabaseShardingStrategy）：数据被分配的目标数据源</li>
<li><code>表分片策略</code>（TableShardingStrategy）：数据被分配的目标表</li>
<li>两种分片策略API完全相同，但是表分片策略是依赖于数据源分片策略的（即：先分库，然后才有分表）</li>
</ul>
</blockquote>
<p>Sharding分片策略继承自ShardingStrategy，提供如下5种分片策略</p>
<p><img src="https://s2.loli.net/2022/01/25/vqiQenzDENf1uTM.png"></p>
<p>由于分片算法和业务实现紧密相关，因此Sharding-JDBC并未提供内置分片算法，而是通过分片策略将各种场景提炼出来，提供更高层级的抽象，并提供接口让应用开发者自行实现分片算法。</p>
<blockquote>
<p>注：Sharding-jdbc在使用分片策略的时候，与分片算法是成对出现的，每种策略都对应一到两种分片算法（不分片策略NoneShardingStrategy除外）</p>
</blockquote>
<h4 id="标准分片策略-StandardShardingStrategy"><a href="#标准分片策略-StandardShardingStrategy" class="headerlink" title="标准分片策略(StandardShardingStrategy)"></a>标准分片策略(StandardShardingStrategy)</h4><h5 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h5><blockquote>
<ul>
<li>提供对SQL语句中的<code>=、IN和BETWEEN AND</code>的分片操作支持</li>
<li>StandardShardingStrategy只支持<code>单分片键</code>，提供<code>PreciseShardingAlgorithm（精准分片）</code>和<code>RangeShardingAlgorithm（范围分片）</code>两个分片算法</li>
<li>PreciseShardingAlgorithm是<code>必选</code>的，用于处理 <code>=</code> 和 <code>IN</code> 的分片</li>
<li>RangeShardingAlgorithm是<code>可选</code>的，用于处理<code>BETWEEN AND</code>分片，如果<code>不配置RangeShardingAlgorithm</code>，SQL中的<code>BETWEEN AND</code>将按照<code>全库路由</code>处理</li>
<li>如果需要使用<code>RangeShardingAlgorithm，必须和PreciseShardingAlgorithm配套使用</code></li>
</ul>
</blockquote>
<h5 id="配置实现"><a href="#配置实现" class="headerlink" title="配置实现"></a>配置实现</h5><ul>
<li>application.properties 配置</li>
</ul>
<p>配置主要分为三个部分：1. <code>配置数据源</code>、2. <code>分库配置</code>、3. <code>分表配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># standard.precise-algorithm  标准策略 + 精准分片算法 SQL 就是  =、in</span><br><span class="line"># standard.range-algorithm   标准策略 + 范围分片算法 （主要是between  and ）</span><br><span class="line">sharding.jdbc.datasource.names=ds0,ds1</span><br><span class="line"> </span><br><span class="line">#分库配置</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.standard.sharding-column=user_id</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds0.url=jdbc:mysql://127.0.0.1:5306/ds0?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds0.username=root</span><br><span class="line">sharding.jdbc.datasource.ds0.password=root</span><br><span class="line">sharding.jdbc.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds1.url=jdbc:mysql://127.0.0.1:5306/ds1?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds1.username=root</span><br><span class="line">sharding.jdbc.datasource.ds1.password=root</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># standard.precise-algorithm 标准策略下分片算法包含2个 precise + range，range是可选的，但是如果使用 range 就必须同 precise 配套一起使用</span><br><span class="line"># 买precise赠送 range，可以选择不要赠品，但是你不能不买还想白嫖赠品</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.standard.precise-algorithm-class-name=类路径.PreciseShardingDBAlgorithm</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.standard.range-algorithm-class-name=类路径.RangeShardingDBAlgorithm</span><br><span class="line"> </span><br><span class="line"># 设置绑定表</span><br><span class="line">sharding.jdbc.config.sharding.binding-tables=t_order,t_order_item</span><br><span class="line"> </span><br><span class="line"># t_order分表配置</span><br><span class="line"># 如果分片键相同，可以直接在后面凭拼接 例如 ：ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;,ds$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.standard.sharding-column=order_id</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.standard.precise-algorithm-class-name=类路径.PreciseShardingTableAlgorithm</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.standard.range-algorithm-class-name=类路径.RangeShardingTableAlgorithm</span><br><span class="line"> </span><br><span class="line"># t_order_item分表配置</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.standard.sharding-column=order_id</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.standard.precise-algorithm-class-name=类路径.PreciseShardingTableAlgorithm</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.standard.range-algorithm-class-name=类路径.RangeShardingTableAlgorithm</span><br></pre></td></tr></table></figure>

<ul>
<li>精准分库PreciseShardingDBAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.PreciseShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.standard.PreciseShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> - 自定义实现 精准分片算法（PreciseShardingAlgorithm）接口</span></span><br><span class="line"><span class="comment"> - 数据库DB的精准分片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreciseShardingDBAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">PreciseShardingAlgorithm</span>&lt;Integer&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> databaseNames 有效的数据源 或者 表 的名字  databaseNames 就为配置文件中的 配置的数据源信息 -&gt; ds0 , ds1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingValue  SQL 分片列 对应的实际值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSharding</span><span class="params">(Collection&lt;String&gt; databaseNames,</span></span><br><span class="line"><span class="params">                             PreciseShardingValue&lt;Integer&gt; shardingValue)</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 作用：散列到具体的哪个库里面去</span></span><br><span class="line"><span class="comment">         * shardingValue ： SQL -&gt; SELECT *  FROM t_order WHERE order _id IN(1,3,6)</span></span><br><span class="line"><span class="comment">         * shardingValue = [1,3,6]</span></span><br><span class="line"><span class="comment">         * */</span></span><br><span class="line">        <span class="keyword">for</span> (String each : databaseNames) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 此方法如果参数所表示的字符序列是由该对象表示的字符序列的后缀返回true, 否则为false;</span></span><br><span class="line"><span class="comment">             *  请注意，如果参数是空字符串或等于此String对象由equals（Object）方法确定结果为 true。</span></span><br><span class="line"><span class="comment">             *  String Str = new String(&quot;This is really not immutable!!&quot;);   retVal = Str.endsWith( &quot;immutable!!&quot; )</span></span><br><span class="line"><span class="comment">             *  为true</span></span><br><span class="line"><span class="comment">             *  ds0.endsWith(&quot;0&quot;) -&gt; true ;</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (each.endsWith(String.valueOf(shardingValue.getValue() % databaseNames.size()))) &#123;</span><br><span class="line">                <span class="comment">//返回相应的数据库</span></span><br><span class="line">                System.out.println(<span class="string">&quot;each&quot;</span>+each);</span><br><span class="line">                <span class="keyword">return</span> each;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范围分库RangeShardingDBAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.RangeShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.standard.RangeShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义实现 范围分片算法（RangeShardingAlgorithm）接口</span></span><br><span class="line"><span class="comment"> * 数据库DB的范围分片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeShardingDBAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">RangeShardingAlgorithm</span>&lt;Integer&gt; &#123;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; databaseNames,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">final</span> RangeShardingValue&lt;Integer&gt; shardingValue)</span> &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 自定义SQL -&gt; SELECT *  FROM t_order WHERE order _id Between 2000 and 4000</span></span><br><span class="line"><span class="comment">         * ds0.t_order: 1000 ~ 3000</span></span><br><span class="line"><span class="comment">         * ds1.t_order: 3001 ~ 5000</span></span><br><span class="line"><span class="comment">         * ds2.t_order: 5001 ~ 7000</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * 执行路由后的SQL 应为：</span></span><br><span class="line"><span class="comment">         * SELECT *  FROM ds0.t_order WHERE order _id Between 2000 and 3000</span></span><br><span class="line"><span class="comment">         * SELECT *  FROM ds1.t_order WHERE order _id Between 3001 and 4000</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 从sql 中获取 Between 2000 and 4000   的值，将2000 赋值给 lower,  4000 赋值给 upper</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lower</span> <span class="operator">=</span> shardingValue.getValueRange().lowerEndpoint();</span><br><span class="line">        <span class="type">int</span> <span class="variable">upper</span> <span class="operator">=</span> shardingValue.getValueRange().upperEndpoint();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lower; i &lt;= upper; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String each : databaseNames) &#123; <span class="comment">//ds0,ds1</span></span><br><span class="line">                <span class="keyword">if</span> (each.endsWith(i % databaseNames.size() + <span class="string">&quot;&quot;</span>)) &#123;</span><br><span class="line">                    result.add(each);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>精准分表PreciseShardingTableAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.PreciseShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.standard.PreciseShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义实现 精准分片算法（PreciseShardingAlgorithm）接口</span></span><br><span class="line"><span class="comment"> * 数据表table的精准分片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PreciseShardingTableAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">PreciseShardingAlgorithm</span>&lt;Long&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注释键 PreciseShardingDBAlgorithm</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> tableNames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingValue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doSharding</span><span class="params">(Collection&lt;String&gt; tableNames,</span></span><br><span class="line"><span class="params">                             PreciseShardingValue&lt;Long&gt; shardingValue)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (String key : tableNames) &#123;</span><br><span class="line">            <span class="keyword">if</span> (key.endsWith(String.valueOf(shardingValue.getValue() % tableNames.size()))) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;key&quot;</span>+key);</span><br><span class="line">                <span class="keyword">return</span> key;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>范围分表RangeShardingTableAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.collect.Range;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.RangeShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.standard.RangeShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义实现 范围分片算法（RangeShardingAlgorithm）接口</span></span><br><span class="line"><span class="comment"> * 数据表 table 的范围分片</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeShardingTableAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">RangeShardingAlgorithm</span>&lt;Integer&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(<span class="keyword">final</span> Collection&lt;String&gt; tableNames,</span></span><br><span class="line"><span class="params">                                         <span class="keyword">final</span> RangeShardingValue&lt;Integer&gt; shardingValue)</span> &#123;</span><br><span class="line">        Set&lt;String&gt; result = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 如果between  2000000 and 7000000</span></span><br><span class="line">        <span class="keyword">if</span> (Range.closed(<span class="number">2000000</span>,</span><br><span class="line">                <span class="number">7000000</span>).encloses(shardingValue.getValueRange())) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String each : tableNames) &#123;</span><br><span class="line">                <span class="keyword">if</span> (each.endsWith(<span class="string">&quot;0&quot;</span>)) &#123;</span><br><span class="line">                    result.add(each);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">UnsupportedOperationException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="复合分片策略-ComplexShardingStrategy"><a href="#复合分片策略-ComplexShardingStrategy" class="headerlink" title="复合分片策略(ComplexShardingStrategy)"></a>复合分片策略(ComplexShardingStrategy)</h4><h5 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h5><blockquote>
<ul>
<li>提供对SQL语句中的<code>=、IN和BETWEEN AND</code>的分片操作支持</li>
<li>ComplexShardingStrategy<code>支持多分片键</code></li>
<li>由于多分片键之间的关系复杂，因此Sharding-JDBC并未做过多的封装，而是直接<code>将分片键值组合</code>以及<code>分片操作符</code>交于<code>算法接口</code>，完全由应用开发者实现，提供最大的灵活度</li>
</ul>
</blockquote>
<h5 id="配置实现-1"><a href="#配置实现-1" class="headerlink" title="配置实现"></a>配置实现</h5><ul>
<li>application.properties 配置</li>
</ul>
<p>配置主要分为三个部分：1. <code>配置数据源</code>、2. <code>分库配置</code>、3. <code>分表配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 复合分片</span><br><span class="line">sharding.jdbc.datasource.names=ds0,ds1</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds0.url=jdbc:mysql://127.0.0.1:5306/ds0?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds0.username=root</span><br><span class="line">sharding.jdbc.datasource.ds0.password=root</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds1.url=jdbc:mysql://127.0.0.1:5306/ds1?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds1.username=root</span><br><span class="line">sharding.jdbc.datasource.ds1.password=root</span><br><span class="line"> </span><br><span class="line"># 分库配置 （行表达式分片策略 + 行表达式分片算法）</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column=user_id</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression=ds$-&gt;&#123;user_id % 2&#125;</span><br><span class="line">sharding.jdbc.config.sharding.binding-tables=t_order,t_order_item</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># t_order分表配置 （复合分片策略）</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;_$-&gt;&#123;0..1&#125;</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.complex.sharding-columns=user_id,order_id</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.complex.algorithm-class-name=类路径.ComplexShardingAlgorithm</span><br><span class="line"> </span><br><span class="line"># t_order_item分表配置 （复合分片策略）</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;_$-&gt;&#123;0..1&#125;</span><br><span class="line"># 标准 和 inline 都是单分片键 ，复合分片策略可以配置则多分片键</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.complex.sharding-columns=user_id,order_id</span><br><span class="line"># 自定义算法，让使用者根据业务自定义实现（开发性接口更灵活方便）</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.complex.algorithm-class-name=类路径.ComplexShardingAlgorithm</span><br><span class="line"> </span><br><span class="line"># 定义广播表</span><br><span class="line">sharding.jdbc.config.sharding.broadcast-tables=t_province</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.config.props.sql.show=true</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义ComplexShardingAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.ListShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.ShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.complex.ComplexKeysShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ComplexShardingAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">ComplexKeysShardingAlgorithm</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> collection 在加载配置文件时，会解析表分片规则。将结果存储到 collection中，doSharding（）参数使用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingValues SQL中对应的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(Collection&lt;String&gt; collection, Collection&lt;ShardingValue&gt; shardingValues)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;collection:&quot;</span> + collection + <span class="string">&quot;,shardingValues:&quot;</span> + shardingValues);</span><br><span class="line"> </span><br><span class="line">        Collection&lt;Integer&gt; orderIdValues = getShardingValue(shardingValues, <span class="string">&quot;order_id&quot;</span>);</span><br><span class="line">        Collection&lt;Integer&gt; userIdValues = getShardingValue(shardingValues, <span class="string">&quot;user_id&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        List&lt;String&gt; shardingSuffix = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// user_id，order_id分片键进行分表</span></span><br><span class="line">        <span class="keyword">for</span> (Integer userId : userIdValues) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer orderId : orderIdValues) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> userId % <span class="number">2</span> + <span class="string">&quot;_&quot;</span> + orderId % <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">for</span> (String s : collection) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (s.endsWith(suffix)) &#123;</span><br><span class="line">                        shardingSuffix.add(s);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> shardingSuffix;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 例如: SELECT * FROM T_ORDER user_id = 100000 AND order_id = 1000009</span></span><br><span class="line"><span class="comment">     * 循环 获取SQL 中 分片键列对应的value值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingValues sql 中分片键的value值   -&gt; 1000009</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 分片键列名                        -&gt; user_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> shardingValues 集合                 -&gt; [1000009]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Collection&lt;Integer&gt; <span class="title function_">getShardingValue</span><span class="params">(Collection&lt;ShardingValue&gt; shardingValues, <span class="keyword">final</span> String key)</span> &#123;</span><br><span class="line">        Collection&lt;Integer&gt; valueSet = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Iterator&lt;ShardingValue&gt; iterator = shardingValues.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            <span class="type">ShardingValue</span> <span class="variable">next</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (next <span class="keyword">instanceof</span> ListShardingValue) &#123;</span><br><span class="line">                <span class="type">ListShardingValue</span> <span class="variable">value</span> <span class="operator">=</span> (ListShardingValue) next;</span><br><span class="line">                <span class="comment">// user_id，order_id分片键进行分表</span></span><br><span class="line">                <span class="keyword">if</span> (value.getColumnName().equals(key)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> value.getValues();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> valueSet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="行表达式分片策略-InlineShardingStrategy"><a href="#行表达式分片策略-InlineShardingStrategy" class="headerlink" title="行表达式分片策略(InlineShardingStrategy)"></a>行表达式分片策略(InlineShardingStrategy)</h4><h5 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h5><blockquote>
<ul>
<li>使用Groovy的Inline表达式，提供对SQL语句中的<code>=</code>和<code>IN</code>的分片操作支持。</li>
<li>InlineShardingStrategy只支持<code>单分片键</code></li>
<li>对于<code>简单的分片算法，可以通过简单的配置使用，从而避免繁琐的Java代码开发</code>，如: tuser${user_id % 8} 表示t_user表按照user_id按8取模分成8个表，表名称为t_user_0到t_user_7</li>
</ul>
</blockquote>
<h5 id="配置实现-2"><a href="#配置实现-2" class="headerlink" title="配置实现"></a>配置实现</h5><ul>
<li>application.properties 配置</li>
</ul>
<p>配置主要分为三个部分：1. <code>配置数据源</code>、2. <code>分库配置</code>、3. <code>分表配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#数据源配置，有多少个数据库，就配置多少个数据源（库多的时候比较繁琐，可以采用数据治理），相比于Mycat 配置还是简单很多</span><br><span class="line">#数据源名字随意，但是配置数据源时必须名字能对应</span><br><span class="line">sharding.jdbc.datasource.names=ds0,ds1</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds0.url=jdbc:mysql://127.0.0.1:5306/ds0?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds0.username=root</span><br><span class="line">sharding.jdbc.datasource.ds0.password=root</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds1.url=jdbc:mysql://127.0.0.1:5306/ds1?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds1.username=root</span><br><span class="line">sharding.jdbc.datasource.ds1.password=root</span><br><span class="line"> </span><br><span class="line">#  ----------------------分库配置--------------------------</span><br><span class="line"># database-strategy.inline 库分片策略   +   指定分库的分片键</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column=user_id</span><br><span class="line"># database-strategy.inline.algorithm-expression 分片算法表达式</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression=ds$-&gt;&#123;user_id % 2&#125;</span><br><span class="line">#  设置绑定表 t_order,t_order_item</span><br><span class="line">sharding.jdbc.config.sharding.binding-tables=t_order,t_order_item</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"># ---------------------- t_order分表配置----------------------</span><br><span class="line"># t_order 分库分表后真实的数据节点(逻辑表 -&gt; 真实表)</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span><br><span class="line">#   分片键设置</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.inline.sharding-column=order_id</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.inline.algorithm-expression=t_order$-&gt;&#123;order_id % 2&#125;</span><br><span class="line"> </span><br><span class="line"># 主键生成 sharding jdbc 默认主键算法是 64位雪花算法</span><br><span class="line"># sharding.jdbc.config.sharding.tables.t_order.key-generator-class-name=io.shardingsphere.core.keygen.DefaultKeyGenerator</span><br><span class="line"># sharding.jdbc.config.sharding.tables.t_order.key-generator-column-name=id</span><br><span class="line"> </span><br><span class="line"># ---------------------- 绑定表t_order_item分表配置 ----------------------</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order_item$-&gt;&#123;0..1&#125;</span><br><span class="line"># 分片键设置</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.inline.sharding-column=order_id</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order_item.table-strategy.inline.algorithm-expression=t_order_item$-&gt;&#123;order_id % 2&#125;</span><br><span class="line"> </span><br><span class="line"># 定义广播表</span><br><span class="line">sharding.jdbc.config.sharding.broadcast-tables=t_province</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.config.props.sql.show=true</span><br></pre></td></tr></table></figure>



<h4 id="强制路由分片策略-HintShardingStrategyhint"><a href="#强制路由分片策略-HintShardingStrategyhint" class="headerlink" title="强制路由分片策略(HintShardingStrategyhint)"></a>强制路由分片策略(HintShardingStrategyhint)</h4><h5 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h5><p>在分库分区中，有些特定的SQL，Sharding-jdbc、Mycat、Vitess都不支持，如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> table1 <span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> table2 <span class="keyword">where</span> ....</span><br></pre></td></tr></table></figure>
<p>这种SQL 路由很麻烦，需要解析table2的路由（是在ds0&#x2F;ds1，table2_0&#x2F;table_1），结果集归并，insert语句也需要同样的路由解析。这种情况Sharding-jdbc可以<code>使用Hint分片策略来实现各种Sharding-jdbc不支持语法的限制</code></p>
<blockquote>
<ul>
<li><code>通过Hint而非SQL解析的方式分片的策略</code>。对于分片字段非SQL决定，而由其他外置条件决定的场景，可使用SQL Hint灵活的注入分片字段</li>
<li><code>Hint分片策略是绕过SQL解析的</code>，所以对于这些比较复杂的需要分片的查询，采用Hint分片策略性能可能会更好</li>
<li>在读写分离数据库中，Hint可以通过<code>HintManager.setMasterRouteOnly()</code>方法，<code>强制读主库</code>（主从复制存在一定延时，但在某些特定的业务场景中，可能更需要保证数据的实时性）</li>
</ul>
</blockquote>
<h5 id="配置实现-3"><a href="#配置实现-3" class="headerlink" title="配置实现"></a>配置实现</h5><ul>
<li>application.properties 配置</li>
</ul>
<p>配置主要分为三个部分：1. <code>配置数据源</code>、2. <code>分库配置</code>、3. <code>分表配置</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Hint 强制路由分片策略</span><br><span class="line">sharding.jdbc.datasource.names=ds0,ds1</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds0.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds0.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds0.url=jdbc:mysql://127.0.0.1:5306/ds0?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds0.username=root</span><br><span class="line">sharding.jdbc.datasource.ds0.password=root</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.datasource.ds1.type=com.alibaba.druid.pool.DruidDataSource</span><br><span class="line">sharding.jdbc.datasource.ds1.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line">sharding.jdbc.datasource.ds1.url=jdbc:mysql://127.0.0.1:5306/ds1?useUnicode=yes&amp;characterEncoding=utf8</span><br><span class="line">sharding.jdbc.datasource.ds1.username=root</span><br><span class="line">sharding.jdbc.datasource.ds1.password=root</span><br><span class="line"> </span><br><span class="line"># 分库配置</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.sharding-column=user_id</span><br><span class="line">sharding.jdbc.config.sharding.default-database-strategy.inline.algorithm-expression=ds$-&gt;&#123;user_id % 2&#125;</span><br><span class="line"> </span><br><span class="line"># t_order强制分片配置</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.actual-data-nodes=ds$-&gt;&#123;0..1&#125;.t_order$-&gt;&#123;0..1&#125;</span><br><span class="line"># 和其他3种不同的是，Hint 需要指定分片表 的数据库分片算法 + 表分片算法</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.database-strategy.hint.algorithm-class-name=类路径.HintShardingKeyAlgorithm</span><br><span class="line">sharding.jdbc.config.sharding.tables.t_order.table-strategy.hint.algorithm-class-name=类路径.HintShardingKeyAlgorithm</span><br><span class="line"> </span><br><span class="line">sharding.jdbc.config.props.sql.show=true</span><br></pre></td></tr></table></figure>

<ul>
<li>自定义HintShardingKeyAlgorithm</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.alibaba.druid.util.StringUtils;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.ListShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.ShardingValue;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.algorithm.sharding.hint.HintShardingAlgorithm;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HintShardingKeyAlgorithm</span> <span class="keyword">implements</span> <span class="title class_">HintShardingAlgorithm</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 自定义Hint 实现算法</span></span><br><span class="line"><span class="comment">     * 能够保证绕过Sharding-JDBC SQL解析过程</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> availableTargetNames</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> shardingValue 不再从SQL 解析中获取值，而是直接通过hintManager.addTableShardingValue(&quot;t_order&quot;, 1)参数指定</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Collection&lt;String&gt; <span class="title function_">doSharding</span><span class="params">(Collection&lt;String&gt; availableTargetNames,</span></span><br><span class="line"><span class="params">                                         ShardingValue shardingValue)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;shardingValue=&quot;</span> + shardingValue);</span><br><span class="line">        System.out.println(<span class="string">&quot;availableTargetNames=&quot;</span> + availableTargetNames);</span><br><span class="line">        List&lt;String&gt; shardingResult = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (String targetName : availableTargetNames) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">suffix</span> <span class="operator">=</span> targetName.substring(targetName.length() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isNumber(suffix)) &#123;</span><br><span class="line">                <span class="comment">// hint分片算法的ShardingValue有两种具体类型:</span></span><br><span class="line">                <span class="comment">// ListShardingValue和RangeShardingValue</span></span><br><span class="line">                <span class="comment">// 使用哪种取决于HintManager.addDatabaseShardingValue(String, String, ShardingOperator,...),ShardingOperator的类型</span></span><br><span class="line">                ListShardingValue&lt;Integer&gt; tmpSharding = (ListShardingValue&lt;Integer&gt;) shardingValue;</span><br><span class="line">                <span class="keyword">for</span> (Integer value : tmpSharding.getValues()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (value % <span class="number">2</span> == Integer.parseInt(suffix)) &#123;</span><br><span class="line">                        shardingResult.add(targetName);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shardingResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>编写测试类HintApplicationTests</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ai.yunxi.sharding.service.OrderService;</span><br><span class="line"><span class="keyword">import</span> io.shardingsphere.api.HintManager;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"> </span><br><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest(classes = VipShardingApplication.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HintApplicationTests</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> OrderService orderService;</span><br><span class="line"> </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// Hint分片策略必须要使用 HintManager工具类</span></span><br><span class="line">        <span class="type">HintManager</span> <span class="variable">hintManager</span> <span class="operator">=</span> HintManager.getInstance();</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        hintManager.addDatabaseShardingValue(<span class="string">&quot;t_order&quot;</span>, <span class="number">0</span>);</span><br><span class="line">        hintManager.addTableShardingValue(<span class="string">&quot;t_order&quot;</span>, <span class="number">1</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 直接指定对应具体的数据库</span></span><br><span class="line">        <span class="comment">//hintManager.setDatabaseShardingValue(1);</span></span><br><span class="line">        <span class="comment">//在读写分离数据库中，Hint 可以强制读主库（主从复制是存在一定延时，但在业务场景中，可能更需要保证数据的实时性）</span></span><br><span class="line">        <span class="comment">//hintManager.setMasterRouteOnly();</span></span><br><span class="line">        System.out.println(orderService.findHint());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/25/j2u49gZ5wek8sHm.png"></p>
<h4 id="不分片策略-NoneShardingStrategy"><a href="#不分片策略-NoneShardingStrategy" class="headerlink" title="不分片策略(NoneShardingStrategy)"></a>不分片策略(NoneShardingStrategy)</h4><p>不分片的策略。和直接不使用Sharding-JDBC 效果相同</p>
<h4 id="主键如何生成"><a href="#主键如何生成" class="headerlink" title="主键如何生成"></a>主键如何生成</h4><p>通过在<code>服务端生成自增主键替换以数据库原生自增主键的方式</code>，做到分布式主键无重复。</p>
<h2 id="执行原理"><a href="#执行原理" class="headerlink" title="执行原理"></a>执行原理</h2><p><img src="https://s2.loli.net/2022/02/08/mjIHoDUBea2RC6u.png"></p>
<h3 id="SQL解析"><a href="#SQL解析" class="headerlink" title="SQL解析"></a>SQL解析</h3><p>SQL解析引擎在 parsing包下：</p>
<blockquote>
<ul>
<li>Lexer：词法解析器</li>
<li>Parser：SQL解析器</li>
</ul>
</blockquote>
<p>两者都是解析器,区别在于<code>Lexer只做词法的解析</code>，不关注上下文。将字符串拆解成N个词法，而Perser在 Lexer的基础上，还需要理解SQL再进行解析</p>
<h4 id="语法树"><a href="#语法树" class="headerlink" title="语法树"></a>语法树</h4><p>解析过程分为<code>词法</code>解析和<code>语法</code>解析。<code>词法解析器用于将SQL拆解为不可再分的原子符号，称为Token</code>。并根据不同数据库方言所提供的字典，将其归类为关键字，表达式，字面量和操作符。再使用<code>语法解析器将SQL转换为抽象语法树</code>。如以下SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id, name <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> status <span class="operator">=</span> <span class="string">&#x27;ACTIVE&#x27;</span> <span class="keyword">AND</span> age <span class="operator">&gt;</span> <span class="number">18</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/01/21/GQjl3DezEqpYIkK.png"></p>
<blockquote>
<p>抽象语法树中的<code>关键字</code>的Token用<code>绿色</code>表示，<code>变量</code>的Token用<code>红色</code>表示，<code>灰色</code>表示需要<code>进一步拆分</code>。</p>
</blockquote>
<p>最后，通过对抽象语法树的遍历去提炼分片所需的上下文，并标记有可能需要改写的位置。 供分片使用的解析上下文包含：</p>
<blockquote>
<ul>
<li>查询选择项（Select Items）</li>
<li>表信息（Table）</li>
<li>分片条件（Sharding Condition）</li>
<li>自增主键信息（Auto increment Primary Key）</li>
<li>排序信息（Order By）</li>
<li>分组信息（Group By）</li>
<li>分页信息（Limit、Rownum、Top）</li>
</ul>
</blockquote>
<p>SQL的一次解析过程是不可逆的，一个个Token的按SQL原本的顺序依次进行解析，性能很高。</p>
<h3 id="SQL路由"><a href="#SQL路由" class="headerlink" title="SQL路由"></a>SQL路由</h3><blockquote>
<p>SQL路由：就是把针对<code>逻辑表</code>的数据操作映射到对数据结点操作的过程。</p>
</blockquote>
<p>根据解析上下文匹配数据库和表的分片策略，并生成路由路径。 对于携带分片键的SQL，根据分片键操作符不同可以划分为<code>单片路由(分片键的操作符是等号)</code>、<code>多片路由(分片键的操作符是IN)</code>和<code>范围路由(分片键的操作符是BETWEEN)</code>，<code>不携带分片键的SQL则采用广播路由</code>。</p>
<p><img src="https://s2.loli.net/2022/01/27/4snapfxT96VOEtg.png"></p>
<h4 id="分片路由"><a href="#分片路由" class="headerlink" title="分片路由"></a>分片路由</h4><p>用于原生SQL中有包含有分片键的场景，又细分为<code>直接路由</code>、<code>标准路由</code>和<code>笛卡尔积</code>路由这3种类型。执行的<code>性能也依次减弱</code>。</p>
<h5 id="直接路由"><a href="#直接路由" class="headerlink" title="直接路由"></a>直接路由</h5><p>满足<code>直接路由</code>的条件相对苛刻，它需要<code>通过Hint强制路由</code>的（使用HintAPI直接指定路由至库表）方式分片，并且是只<code>分库不分表的前提下</code>，则可以<code>避免SQL解析和之后的结果归并</code>。因此它的兼容性最好，可以执行包括子查询、自定义函数等复杂情况的任意SQL。直接路由还可以用于分片键不在SQL中的某些特殊场景。例如，设置用于数据库分片的键为3</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">hintManager.setDatabaseShardingValue(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<p>假如路由算法为<code>order_id % 2</code>，当一个逻辑库t_order对应2个真实库ds_0和ds_1时，路由后SQL将在ds_1上执行。下方是使用API的代码样例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM t_order&quot;</span>;</span><br><span class="line"><span class="keyword">try</span> (</span><br><span class="line">	   <span class="type">HintManager</span> <span class="variable">hintManager</span> <span class="operator">=</span> HintManager.getInstance();</span><br><span class="line">	   <span class="type">Connection</span> <span class="variable">conn</span> <span class="operator">=</span> dataSource.getConnection();</span><br><span class="line">	   <span class="type">PreparedStatement</span> <span class="variable">pstmt</span> <span class="operator">=</span> conn.prepareStatement(sql)) &#123;</span><br><span class="line">	   hintManager.setDatabaseShardingValue(<span class="number">3</span>);</span><br><span class="line">	   <span class="keyword">try</span> (<span class="type">ResultSet</span> <span class="variable">rs</span> <span class="operator">=</span> pstmt.executeQuery()) &#123;</span><br><span class="line">	   <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">	       <span class="comment">//...</span></span><br><span class="line">	   &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="标准路由"><a href="#标准路由" class="headerlink" title="标准路由"></a>标准路由</h5><p><code>标准路由</code>是ShardingSphere最为<code>推荐</code>使用的<code>分片方式</code>，它的<code>适用范围</code>是<code>不包含关联查询</code>或<code>仅包含绑定表和广播表之间关联查询</code>的SQL。当分片运算符是<code>等于号</code>时，<code>路由结果将落入单库（表）</code>，当分片运算符是<code>BETWEEN或IN</code>时，则路由结果<code>不一定落入唯一的库（表）</code>，因此一条逻辑SQL最终可能被拆分为多条用于执行的真实SQL。举例说明，如果按复合分片规则按照order_id的奇数和偶数进行分库，user_id的奇数和偶数进行分表时，一个单表查询的SQL如下：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">AND</span> user_id  <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) ;</span><br></pre></td></tr></table></figure>

<p>那么路由的结果应为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> ds0.order_id_0 <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">AND</span> user_id  <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> ds0.order_id_1 <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">AND</span> user_id  <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> ds1.order_id_0 <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">AND</span> user_id  <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> ds1.order_id_1 <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>) <span class="keyword">AND</span> user_id  <span class="keyword">IN</span> (<span class="number">1</span>,<span class="number">2</span>) ;</span><br></pre></td></tr></table></figure>

<p><code>绑定表和广播表的join关联查询与单表查询复杂度和性能相当</code></p>
<blockquote>
<ul>
<li>广播表在每个分库中都有相同的一份数据，例如原生SQL<code>jion t_order_item</code>，每个分库都存在一张<code>t_order_item</code>表，不需要特殊处理就可以查询 ；</li>
<li>绑定表之间的数据是一一对应的，order_id为奇数的数据只会存储在相同库的一个分表中，有很强的关联性，SQL拆分后的数目与单表是一致的；</li>
</ul>
</blockquote>
<h5 id="笛卡尔路由"><a href="#笛卡尔路由" class="headerlink" title="笛卡尔路由"></a>笛卡尔路由</h5><p>笛卡尔路由是最复杂的情况，它无法根据绑定表的关系定位分片规则，因此<code>非绑定表之间的关联查询需要拆解为笛卡尔积组合执行</code>。</p>
<p>不管是mycat还是sharding，所有的分库分表对非绑定表和广播表之间的关联查询都无法做到有效优化支持，无法根据分片规则计算出SQL应该在哪个数据库、哪个表上执行，那么结果就是把所有分库分表中关联使用到的表交叉查询。<code>笛卡尔路由查询性能较低，需谨慎使用</code>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">AS</span> t1 LFTE JION t_user <span class="keyword">AS</span> t2 <span class="keyword">ON</span> t1.user_id <span class="operator">=</span> t2.user_id <span class="keyword">WHERE</span> t1.order_id <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/27/Te5YNDnFaf1y94z.png"></p>
<h4 id="广播路由"><a href="#广播路由" class="headerlink" title="广播路由"></a>广播路由</h4><p>对于<code>不携带分片键的SQL，则采取广播路由的方式</code>。根据SQL类型又可以划分为<code>全库表路由</code>、<code>全库路由</code>、<code>全实例路由</code>、<code>单播路由</code>和<code>阻断路由</code>这5种类型。</p>
<h5 id="全库表路由"><a href="#全库表路由" class="headerlink" title="全库表路由"></a>全库表路由</h5><p><code>全库表路由</code>用于<code>处理对数据库中与其逻辑表相关的所有真实表的操作</code>，主要包括<code>不带分片键的DQL和DML，以及DDL等</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> t_order <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p>则会遍历所有数据库中的所有表，逐一匹配逻辑表和真实表名，能够匹配得上则执行。路由后成为</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ds0.t_order_0 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ds0.t_order_1 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ds1.t_order_0 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> ds1.t_order_1 <span class="keyword">WHERE</span> good_prority <span class="keyword">IN</span> (<span class="number">1</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h5 id="全库路由"><a href="#全库路由" class="headerlink" title="全库路由"></a>全库路由</h5><p><code>全库路由</code>用于<code>处理对数据库的操作，包括用于库设置的SET类型的数据库管理命令，以及TCL这样的事务控制语句</code>。在这种情况下，会根据逻辑库的名字遍历所有符合名字匹配的真实库，并在真实库中执行该命令，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 在t_order中执行时有<span class="number">2</span>个真实库。则实际会在ds0和ds1上都执行这个命令。</span><br><span class="line"><span class="keyword">SET</span> autocommit<span class="operator">=</span><span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h5 id="全实例路由"><a href="#全实例路由" class="headerlink" title="全实例路由"></a>全实例路由</h5><p><code>全实例路</code>由用于DCL操作，<code>授权语句针对的是数据库的实例</code>。无论一个实例中包含多少个Schema，<code>每个数据库的实例只执行一次</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 这个命令将在所有的真实数据库实例中执行，以确保customer用户可以访问每一个实例。</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> customer<span class="variable">@127</span><span class="number">.0</span><span class="number">.0</span><span class="number">.1</span> identified <span class="keyword">BY</span> <span class="string">&#x27;123&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="单播路由"><a href="#单播路由" class="headerlink" title="单播路由"></a>单播路由</h5><p><code>单播路由</code>用于<code>获取某一真实表信息的场景，它仅需要从任意库中的任意真实表中获取数据即可</code>。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># ds0 和 但ds1 上的的两个真实表t_order_0，t_order_1的描述结构相同，所以这个命令在任意真实表上选择执行一次。</span><br><span class="line"><span class="keyword">DESCRIBE</span> t_order;</span><br></pre></td></tr></table></figure>

<h5 id="阻断路由"><a href="#阻断路由" class="headerlink" title="阻断路由"></a>阻断路由</h5><p>阻断路由用于屏蔽SQL对数据库的操作，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 这个命令不会在真实数据库中执行，因为ShardingSphere采用的是逻辑Schema的方式，无需将切换数据库Schema的命令发送至数据库中。</span><br><span class="line">USE order_db;</span><br></pre></td></tr></table></figure>
<h3 id="结果归并"><a href="#结果归并" class="headerlink" title="结果归并"></a>结果归并</h3><p><code>将从各个数据节点获取的多数据结果集，组合成为一个结果集并正确的返回至请求客户端，称为结果归并</code>。</p>
<p><img src="https://s2.loli.net/2022/02/08/N6nAIMwSuW8EoFx.png"></p>
<p>ShardingSphere支持的结果归并从<code>功能</code>上分为<code>遍历</code>、<code>排序</code>、<code>分组</code>、<code>分页</code>和<code>聚合</code>5种类型，它们<code>是组合而非互斥的关系</code>。从<code>结构</code>划分，可分为<code>流式归并</code>、<code>内存归并</code>和<code>装饰者归并</code>。<code>流式归并和内存归并是互斥的</code>，<code>装饰者归并可以在流式归并和内存归并之上做进一步的处理</code>。</p>
<blockquote>
<ul>
<li><code>流式归并</code>是指每一次从结果集中获取到的数据，都能够通过逐条获取的方式返回正确的单条数据，它与数据库原生的返回结果集的方式最为契合。<code>遍历</code>、<code>排序</code>以及<code>流式分组</code>都<code>属于流式归并</code>的一种。</li>
<li><code>内存归并</code>则是需要将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回。</li>
<li><code>装饰者归并</code>是对所有的结果集归并进行统一的功能增强，目前装饰者归并有<code>分页归并</code>和<code>聚合归并</code>这2种类型。</li>
</ul>
</blockquote>
<h4 id="遍历归并"><a href="#遍历归并" class="headerlink" title="遍历归并"></a>遍历归并</h4><p>最为简单的归并方式。在返回的结果集只有一个或者没有使用到排序条件的场景中使用，因为不涉及到排序，只需将多个数据结果集合并为一个单向链表即可。在遍历完成链表中当前数据结果集之后，将链表元素后移一位，继续遍历下一个数据结果集即可。</p>
<h4 id="排序归并"><a href="#排序归并" class="headerlink" title="排序归并"></a>排序归并</h4><p><code>在 查询SQL中，使用order by 但是没有group by + 聚合函数 的情况下使用，由于在SQL中存在ORDER BY语句，因此每个数据结果集自身是有序的，但各个数据结果集之间是无序的</code>。因此只需要将数据结果集当前游标指向的数据值进行排序即可。 这相当于对多个有序的数组进行排序，归并排序是最适合此场景的排序算法。</p>
<p>ShardingSphere在对排序的查询进行归并时，将每个结果集的当前数据值进行比较（通过实现Java的Comparable接口完成），并将其放入优先级队列。 每次获取下一条数据时，只需将队列顶端结果集的游标下移，并根据新游标重新进入优先级排序队列找到自己的位置即可。</p>
<blockquote>
<ul>
<li>如当前有三个数据结果集，将各个数据结果集的当前游标指向的数据值进行排序，并放入优先级队列。<code>t_score_0</code>的第一个数据值最大，<code>t_score_2</code>的第一个数据值次之，<code>t_score_1</code>的第一个数据值最小，因此优先级队列根据<code>t_score_0</code>，<code>t_score_2</code>和<code>t_score_1</code>的方式排序队列。结果如下所示：</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/21/1kIJD6uBHNrYUX9.png"></p>
<blockquote>
<ul>
<li>调用next()方法，排在优先级队列首位的<code>t_score_0</code>将会被弹出队列，并且将当前游标指向的数据值返回至查询客户端，并且将游标下移一位之后重新放入优先级队列从新进行优先级队列排序</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2022/01/21/FeNysG6aQx8EfPl.png"></p>
<p>可以看到，对于每个数据结果集中的数据有序，而多数据结果集整体无序的情况下，ShardingSphere无需将所有的数据都加载至内存即可排序。它使用的是<code>流式归并的方式，每次next仅获取唯一正确的一条数据，极大的节省了内存的消耗</code>。</p>
<p>从另一个角度来说，ShardingSphere的排序归并，是在维护数据结果集的纵轴和横轴这两个维度的有序性。<code>纵轴是指每个数据结果集本身，它是天然有序的，它通过包含ORDER BY的SQL所获取</code>。<code>横轴是指每个数据结果集当前游标所指向的值，它需要通过优先级队列来维护其正确顺序</code>。每一次数据结果集当前游标的下移，都需要将该数据结果集重新放入优先级队列排序，而只有排列在队列首位的数据结果集才可能发生游标下移的操作。</p>
<h4 id="分组归并"><a href="#分组归并" class="headerlink" title="分组归并"></a>分组归并</h4><p>分组归并的情况最为复杂，它分为流式分组归并和内存分组归并。 <code>流式分组归并要求SQL的排序项与分组项的字段以及排序类型（ASC或DESC）必须保持一致</code>，否则只能通过内存归并才能保证其数据的正确性。</p>
<h5 id="流式分组归并"><a href="#流式分组归并" class="headerlink" title="流式分组归并"></a>流式分组归并</h5><p><code>在分组项与排序项完全一致的情况下，取得的数据是连续的</code>，分组所需的数据全数存在于各个数据结果集的当前游标所指向的数据值，因此可以采用流式归并。</p>
<p>举例说明，假设根据科目分片，表结构中包含考生的姓名（为了简单起见，不考虑重名的情况）和分数。通过SQL获取每位考生的总分，可通过如下SQL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">SUM</span>(score) <span class="keyword">FROM</span> t_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> name;</span><br></pre></td></tr></table></figure>

<p>进行归并时，逻辑与排序归并类似，下图展现了进行next调用的时候，流式分组归并是如何进行的。</p>
<p><img src="https://s2.loli.net/2022/02/08/UJTBO8cKqGrwC7P.png"></p>
<p>通过图中我们可以看到，<code>当进行第一次next调用时，排在队列首位的t_score_java将会被弹出队列，并且将分组值同为“Jetty”的其他结果集中的数据一同弹出队列。 在获取了所有的姓名为“Jetty”的同学的分数之后，进行累加操作，那么，在第一次next调用结束后，取出的结果集是“Jetty”的分数总和。</code>与此同时，所有的数据结果集中的游标都将下移至数据值“Jetty”的下一个不同的数据值，并且根据数据结果集当前游标指向的值进行重排序。因此，包含名字顺着第二位的“John”的相关数据结果集则排在的队列的前列。</p>
<p>流式分组归并与排序归并的区别仅仅在于两点：</p>
<blockquote>
<ul>
<li>它会一次性的将多个数据结果集中的分组项相同的数据全数取出。</li>
<li>它需要根据聚合函数的类型进行聚合计算。</li>
</ul>
</blockquote>
<h5 id="内存分组归并"><a href="#内存分组归并" class="headerlink" title="内存分组归并"></a>内存分组归并</h5><p><code>对于分组项与排序项不一致的情况，由于需要获取分组的相关的数据值并非连续的</code>，因此无法使用流式归并，需要将所有的结果集数据加载至内存中进行分组和聚合。 例如，若通过以下SQL获取每位考生的总分并按照分数从高至低排序，是无法进行流式归并的，<code>只能将结果集的所有数据都遍历并存储在内存中，再通过统一的分组、排序以及聚合等计算之后，再将其封装成为逐条访问的数据结果集返回</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, <span class="built_in">SUM</span>(score) <span class="keyword">FROM</span> t_score <span class="keyword">GROUP</span> <span class="keyword">BY</span> name <span class="keyword">ORDER</span> <span class="keyword">BY</span> score <span class="keyword">DESC</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/02/08/RkrtgGVTPuh3qBp.png"></p>
<blockquote>
<p><code>注：当SQL中只包含分组语句时，根据不同数据库的实现，其排序的顺序不一定与分组顺序一致。但由于排序语句的缺失，则表示此SQL并不在意排序顺序。 因此，ShardingSphere通过SQL优化的改写，自动增加与分组项一致的排序项，使其能够从消耗内存的内存分组归并方式转化为流式分组归并方案。</code></p>
</blockquote>
<h4 id="聚合归并"><a href="#聚合归并" class="headerlink" title="聚合归并"></a>聚合归并</h4><p><code>聚合归并</code>是在之前介绍的归并类的之上追加的归并能力，即<code>装饰者模式的一种</code>。</p>
<p>无论是流式分组归并还是内存分组归并，对聚合函数的处理都是一致的。 除了分组的SQL之外，不进行分组的SQL也可以使用聚合函数。聚合函数可以归类为<code>比较</code>、<code>累加</code>和<code>求平均值</code>这3种类型</p>
<blockquote>
<ul>
<li><code>比较</code>类型的聚合函数是指<code>MAX</code>和<code>MIN</code>。它们需要对每一个同组的结果集数据进行比较，并且直接返回其最大或最小值即可。</li>
<li><code>累加</code>类型的聚合函数是指<code>SUM</code>和<code>COUNT</code>。它们需要将每一个同组的结果集数据进行累加。</li>
<li><code>求平均值</code>的聚合函数只有<code>AVG</code>。</li>
</ul>
</blockquote>
<h4 id="分页归并"><a href="#分页归并" class="headerlink" title="分页归并"></a>分页归并</h4><p>上文所述的所有归并类型都可能进行分页。<code>分页</code>也是追加在其他归并类型之上的<code>装饰器</code>，ShardingSphere通过装饰者模式来增加对数据结果集进行分页的能力。 分页归并负责将无需获取的数据过滤掉。</p>
<p>ShardingSphere 执行分页的处理是通过对SQL的改写来实现的。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span>  age <span class="operator">&gt;</span> <span class="number">18</span> LIMIT <span class="number">10000</span>,<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>为了保证返回数据的准确性，在SQL改写阶段修改为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> id <span class="keyword">FROM</span> t_user <span class="keyword">WHERE</span> age <span class="operator">&gt;</span> <span class="number">18</span> LIMIT <span class="number">0</span>,<span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2022/01/21/2ZD6JK9BxRGMFyQ.png"></p>
<h3 id="SQL执行"><a href="#SQL执行" class="headerlink" title="SQL执行"></a>SQL执行</h3><p>Sharding-JDBC采用一套自动化的执行引擎，负责将路由和改写完成之后的真实SQL安全且高效发送到底层数据源执行。它不是简单地将SQL通过JDBC直接发送至数据源执行；也并非直接将执行请求放入线程池去并发执行。它更关注<code>平衡数据源连接创建以及内存占用所产生的消耗，以及最大限度地合理利用并发等问题</code>。<code>执行引擎的目标是自动化的平衡资源控制与执行效率</code>。</p>
<h4 id="内存限制模式"><a href="#内存限制模式" class="headerlink" title="内存限制模式"></a>内存限制模式</h4><p>使用此模式的前提是，Sharding-JDBC对一次操作所耗费的<code>数据库连接数量不做限制</code>。 如果实际执行的SQL需要对某数据库实例中的200张表做操作，则<code>对每张表创建一个新的数据库连接，并通过多线程的方式并发处理，以达成执行效率最大化</code>。</p>
<h4 id="连接限制模式"><a href="#连接限制模式" class="headerlink" title="连接限制模式"></a>连接限制模式</h4><p>使用此模式的前提是，Sharding-JDBC<code>严格控制对一次操作所耗费的数据库连接数量</code>。 如果实际执行的SQL需要对某数据库实例中的200张表做操作，那么<code>只会创建唯一的数据库连接</code>，并对其200张表<code>串行处理</code>。 如果一次操作中的分片散落在不同的数据库，仍然采用多线程处理对不同库的操作，但每个库的每次操作仍然只创建一个唯一的数据库连接。</p>
<h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><ul>
<li><code>内存限制</code>模式适用于<code>OLAP</code>操作，可以通过放宽对数据库连接的限制提升系统吞吐量；</li>
<li><code>连接限制</code>模式适用于<code>OLTP</code>操作，OLTP通常带有分片键，会路由到单一的分片，因此严格控制数据库连接，以保证在线系统数据库资源能够被更多的应用所使用，是明智的选择。</li>
</ul>
<blockquote>
<p>OLAP(OnLine Analytical Processing) 和 OLTP(OnLine Transaction Processing) 分别代表什么？<br><img src="https://s2.loli.net/2022/01/21/GgT4ILnOumtWANw.jpg"></p>
</blockquote>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><code>基础概念</code>：逻辑表，真实表，数据节点，绑定表，广播表，分片键，分片算法，分片策略，主键生成策略</li>
<li><code>核心功能</code>：数据分片，读写分离</li>
<li><code>执行流程</code>： SQL解析 &#x3D;&gt;  查询优化 &#x3D;&gt;  SQL路由 &#x3D;&gt;  SQL改写 &#x3D;&gt;  SQL执行 &#x3D;&gt;  结果归并</li>
</ul>
<!-- flag of hidden posts --></article><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Sharding-JDBC/">Sharding-JDBC</a><a class="post-meta__tags" href="/tags/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/">分库分表</a><a class="post-meta__tags" href="/tags/%E5%88%86%E7%89%87%E7%AD%96%E7%95%A5/">分片策略</a><a class="post-meta__tags" href="/tags/%E5%88%86%E7%89%87%E7%AE%97%E6%B3%95/">分片算法</a></div><div class="post_share"><div class="social-share" data-image="https://s2.loli.net/2022/02/09/XoaQR4cJu3bPyZD.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/gh/overtrue/share.js@master/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/file/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/file/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li></ul></div></div><nav class="pagination-post" id="pagination"></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/file/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">灵熙云</div><div class="author-info__description">空话连篇，不如劳动实践！</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">123</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">15</div></a></div><a id="card-info-btn" href="https://www.goitman.cn/"><i class="fab fa-github"></i><span>加入书签</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://blog.csdn.net/minkeyto" target="_blank" title="CSDN"><i class="fa fa-university"></i></a><a class="social-icon" href="/file/wx.png" target="_blank" title="抖音号"><i class="fas fa-video"></i></a><a class="social-icon" href="https://github.com/wangdaicong" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="/about/" target="_blank" title="关于本站"><i class="fa fa-address-book"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你好，欢迎来到我的博客！</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/04/27/So%20easy%20Spring%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6/" title="So easy Spring事务回滚机制"><img src="https://s2.loli.net/2022/04/27/9xQwapEFrtc4HnP.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="So easy Spring事务回滚机制"/></a><div class="content"><a class="title" href="/2022/04/27/So%20easy%20Spring%E4%BA%8B%E5%8A%A1%E5%9B%9E%E6%BB%9A%E6%9C%BA%E5%88%B6/" title="So easy Spring事务回滚机制">So easy Spring事务回滚机制</a><time datetime="2022-04-27T08:57:26.164Z" title="发表于 2022-04-27 16:57:26">2022-04-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/11/Caddy%E8%B6%85%E8%B6%8ANginx%EF%BC%8C%E4%B8%8B%E4%B8%80%E4%BB%A3Web%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Caddy超越Nginx，下一代Web服务器？"><img src="https://s2.loli.net/2022/04/11/sSTLlxib6jRZCkH.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Caddy超越Nginx，下一代Web服务器？"/></a><div class="content"><a class="title" href="/2022/04/11/Caddy%E8%B6%85%E8%B6%8ANginx%EF%BC%8C%E4%B8%8B%E4%B8%80%E4%BB%A3Web%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="Caddy超越Nginx，下一代Web服务器？">Caddy超越Nginx，下一代Web服务器？</a><time datetime="2022-04-11T03:36:30.619Z" title="发表于 2022-04-11 11:36:30">2022-04-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/07/Supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" title="Supervisor安装与配置"><img src="https://s2.loli.net/2022/04/07/VUezAxHglWuKPpT.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Supervisor安装与配置"/></a><div class="content"><a class="title" href="/2022/04/07/Supervisor%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE/" title="Supervisor安装与配置">Supervisor安装与配置</a><time datetime="2022-04-07T02:55:18.881Z" title="发表于 2022-04-07 10:55:18">2022-04-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/04/06/%E5%AE%9E%E6%88%98%20ELK%20%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97/" title="实战 ELK 优雅管理服务器日志"><img src="https://s2.loli.net/2022/04/07/NOCjUTqIv1XhwkL.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实战 ELK 优雅管理服务器日志"/></a><div class="content"><a class="title" href="/2022/04/06/%E5%AE%9E%E6%88%98%20ELK%20%E4%BC%98%E9%9B%85%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97/" title="实战 ELK 优雅管理服务器日志">实战 ELK 优雅管理服务器日志</a><time datetime="2022-04-06T01:53:47.256Z" title="发表于 2022-04-06 09:53:47">2022-04-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/22/%E7%94%A8%E5%A5%BDSpringBoot%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="用好SpringBoot内置工具类"><img src="https://s2.loli.net/2022/03/22/aWmpkPE8tzr74cw.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="用好SpringBoot内置工具类"/></a><div class="content"><a class="title" href="/2022/03/22/%E7%94%A8%E5%A5%BDSpringBoot%E5%86%85%E7%BD%AE%E5%B7%A5%E5%85%B7%E7%B1%BB/" title="用好SpringBoot内置工具类">用好SpringBoot内置工具类</a><time datetime="2022-03-22T08:57:55.156Z" title="发表于 2022-03-22 16:57:55">2022-03-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://s2.loli.net/2022/02/09/XoaQR4cJu3bPyZD.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 灵熙云</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@5/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'eKp2wzPKybiFid4KXcVFcyMX-gzGzoHsz',
      appKey: 'RSA7FDJfrFwpawTfG1vE6R71',
      avatar: 'monsterid',
      serverURLs: '',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: 
    }, ))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !false) {
  if (false) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>