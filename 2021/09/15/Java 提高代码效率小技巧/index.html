<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java 提高代码效率小技巧 | 灵熙云工作室</title><meta name="description" content="前言代码优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。 代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可"><meta name="keywords" content="代码优化"><meta name="author" content="灵熙云,minkeyto@qq.com"><meta name="copyright" content="灵熙云"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/file/favicon.png"><link rel="canonical" href="http://www.goitman.cn/2021/09/15/Java%20%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E5%B0%8F%E6%8A%80%E5%B7%A7/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="preconnect" href="//zz.bdstatic.com"/><meta property="og:type" content="article"><meta property="og:title" content="Java 提高代码效率小技巧"><meta property="og:url" content="http://www.goitman.cn/2021/09/15/Java%20%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E5%B0%8F%E6%8A%80%E5%B7%A7/"><meta property="og:site_name" content="灵熙云工作室"><meta property="og:description" content="前言代码优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。 代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可"><meta property="og:image" content="https://i.loli.net/2021/09/15/9VmfNJWSuRtZHj2.jpg"><meta property="article:published_time" content="2021-09-15T03:26:12.407Z"><meta property="article:modified_time" content="2021-09-15T07:11:06.473Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css"><link rel="prev" title="Java中那18把&quot;金刚&quot;锁" href="http://www.goitman.cn/2021/09/16/Java%E4%B8%AD%E9%82%A318%E6%8A%8A%E9%87%91%E5%88%9A%E9%94%81/"><link rel="next" title="常见的for循环优化方式" href="http://www.goitman.cn/2021/09/07/%E5%B8%B8%E8%A7%81%E7%9A%84for%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?5c009f46ba6df7bc385f101477536214";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: {"bookmark":{"message_prev":"按","message_next":"键将本页加入书签"},"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#121212","position":"bottom-left"},
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2021-09-15 15:11:06'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/effect.css"><meta name="generator" content="Hexo 4.2.1"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="/file/head.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">20</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-file"></i><span> 专题笔记</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/08/17/Redis/"><i class="fa-fw fa fa-book"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div></div></div><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#优化细节"><span class="toc-number">2.</span> <span class="toc-text">优化细节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#不要创建和导入不使用的对象或不使用的类"><span class="toc-number">2.1.</span> <span class="toc-text">不要创建和导入不使用的对象或不使用的类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量指定类、方法的final修饰符"><span class="toc-number">2.2.</span> <span class="toc-text">尽量指定类、方法的final修饰符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量重用对象"><span class="toc-number">2.3.</span> <span class="toc-text">尽量重用对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽可能使用局部变量"><span class="toc-number">2.4.</span> <span class="toc-text">尽可能使用局部变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量避免随意使用静态变量"><span class="toc-number">2.5.</span> <span class="toc-text">尽量避免随意使用静态变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#将常量声明为static-final，并以大写命名"><span class="toc-number">2.6.</span> <span class="toc-text">将常量声明为static final，并以大写命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要让public方法中有太多的形参"><span class="toc-number">2.7.</span> <span class="toc-text">不要让public方法中有太多的形参</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要对超出范围的基本数据类型做向下强制转型"><span class="toc-number">2.8.</span> <span class="toc-text">不要对超出范围的基本数据类型做向下强制转型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量采用懒加载的策略"><span class="toc-number">2.9.</span> <span class="toc-text">尽量采用懒加载的策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量在合适的场合使用单例"><span class="toc-number">2.10.</span> <span class="toc-text">尽量在合适的场合使用单例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#慎用异常"><span class="toc-number">2.11.</span> <span class="toc-text">慎用异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要在循环中使用try…catch…"><span class="toc-number">2.12.</span> <span class="toc-text">不要在循环中使用try…catch…</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#及时关闭流"><span class="toc-number">2.13.</span> <span class="toc-text">及时关闭流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对资源的close-建议分开操作"><span class="toc-number">2.14.</span> <span class="toc-text">对资源的close()建议分开操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量减少对变量的重复计算"><span class="toc-number">2.15.</span> <span class="toc-text">尽量减少对变量的重复计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#为底层以数组方式实现的集合、工具类指定初始长度"><span class="toc-number">2.16.</span> <span class="toc-text">为底层以数组方式实现的集合、工具类指定初始长度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#当复制大量数据时"><span class="toc-number">2.17.</span> <span class="toc-text">当复制大量数据时</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#乘法和除法使用移位操作"><span class="toc-number">2.18.</span> <span class="toc-text">乘法和除法使用移位操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#循环内不要不断创建对象引用"><span class="toc-number">2.19.</span> <span class="toc-text">循环内不要不断创建对象引用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#把一个基本数据类型转为字符串"><span class="toc-number">2.20.</span> <span class="toc-text">把一个基本数据类型转为字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串变量和字符串常量equals"><span class="toc-number">2.21.</span> <span class="toc-text">字符串变量和字符串常量equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要对数组使用toString-方法"><span class="toc-number">2.22.</span> <span class="toc-text">不要对数组使用toString()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于效率和类型检查的考虑"><span class="toc-number">2.23.</span> <span class="toc-text">基于效率和类型检查的考虑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#尽量使用HashMap、ArrayList、StringBuilder"><span class="toc-number">2.24.</span> <span class="toc-text">尽量使用HashMap、ArrayList、StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#不要将数组声明为public-static-final"><span class="toc-number">2.25.</span> <span class="toc-text">不要将数组声明为public static final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayList和LinkedList的选择"><span class="toc-number">2.26.</span> <span class="toc-text">ArrayList和LinkedList的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#公用集合中不使用的数据必须及时remove"><span class="toc-number">2.27.</span> <span class="toc-text">公用集合中不使用的数据必须及时remove</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现RandomAccess接口的集合"><span class="toc-number">2.28.</span> <span class="toc-text">实现RandomAccess接口的集合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用最有效率的方式去遍历Map"><span class="toc-number">2.29.</span> <span class="toc-text">使用最有效率的方式去遍历Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用同步代码块替代同步方法"><span class="toc-number">2.30.</span> <span class="toc-text">使用同步代码块替代同步方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用带缓冲的输入输出流进行IO操作"><span class="toc-number">2.31.</span> <span class="toc-text">使用带缓冲的输入输出流进行IO操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序运行过程中避免使用反射"><span class="toc-number">2.32.</span> <span class="toc-text">程序运行过程中避免使用反射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用数据库连接池和线程池"><span class="toc-number">2.33.</span> <span class="toc-text">使用数据库连接池和线程池</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#及时清除不再需要的会话"><span class="toc-number">2.34.</span> <span class="toc-text">及时清除不再需要的会话</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://i.loli.net/2021/09/15/9VmfNJWSuRtZHj2.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">灵熙云工作室</a></span><span class="pull-right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-file"></i><span> 专题笔记</span><i class="fas fa-chevron-down menus-expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/2020/08/17/Redis/"><i class="fa-fw fa fa-book"></i><span> Redis</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-users"></i><span> 友链&amp;留言板</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java 提高代码效率小技巧</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-09-15 11:26:12"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2021-09-15</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-09-15 15:11:06"><i class="fas fa-history fa-fw"></i> 更新于 2021-09-15</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fas fa-inbox fa-fw post-meta__icon"></i><a class="post-meta__categories" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a></span></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">4.3k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 14 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span><span class="post-meta__separator">|</span><i class="far fa-comments fa-fw post-meta__icon"></i><span>评论数:</span><a href="/2021/09/15/Java%20%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E5%B0%8F%E6%8A%80%E5%B7%A7/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/09/15/Java%20%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E6%95%88%E7%8E%87%E5%B0%8F%E6%8A%80%E5%B7%A7/" itemprop="commentCount"></span></a></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>代码优化 ，一个很重要的课题。可能有些人觉得没用，一些细小的地方有什么好修改的，改与不改对于代码的运行效率有什么影响呢？这个问题我是这么考虑的，就像大海里面的鲸鱼一样，它吃一条小虾米有用吗？没用，但是，吃的小虾米一多之后，鲸鱼就被喂饱了。</p>
<p>代码优化也是一样，如果项目着眼于尽快无BUG上线，那么此时可以抓大放小，代码的细节可以不精打细磨；但是如果有足够的时间开发、维护代码，这时候就必须考虑每个可以优化的细节了，一个一个细小的优化点累积起来，对于代码的运行效率绝对是有提升的。</p>
<p><code>代码优化的目标是：</code></p>
<ul>
<li>减小代码的体积</li>
<li>提高代码运行的效率</li>
</ul>
<h2 id="优化细节"><a href="#优化细节" class="headerlink" title="优化细节"></a>优化细节</h2><h3 id="不要创建和导入不使用的对象或不使用的类"><a href="#不要创建和导入不使用的对象或不使用的类" class="headerlink" title="不要创建和导入不使用的对象或不使用的类"></a>不要创建和导入不使用的对象或不使用的类</h3><p>如果代码中出现“The value of the local variable i is not used”、“The import java.util is never used”，那么请删除这些无用的内容。</p>
<h3 id="尽量指定类、方法的final修饰符"><a href="#尽量指定类、方法的final修饰符" class="headerlink" title="尽量指定类、方法的final修饰符"></a>尽量指定类、方法的final修饰符</h3><ul>
<li>带有 final 修饰符的类是不可派生的。</li>
<li>在 Java 核心 API中，有许多应用final的例子，例如java.lang.String，整个类都是 final 的。</li>
<li>为类指定 final 修饰符可以让类不可以被继承，为方法指定final修饰符可以让方法不可以被重写。如果指定了一个类为final，则该类所有的方法都是 final 的。</li>
<li>Java 编译器会寻找机会内联所有的final方法，内联对于提升Java运行效率作用重大。<code>如果一个方法体本身就很大，这样的优势就小了很多了</code>。</li>
</ul>
<p><code>注：在最近的java设计中，虚拟机（特别是hotspot技术）可以自己去根据具体情况自动优化选择是否进行内联，因此和final关键字就无关了。</code></p>
<h3 id="尽量重用对象"><a href="#尽量重用对象" class="headerlink" title="尽量重用对象"></a>尽量重用对象</h3><p>特别是 String 对象的使用，出现字符串连接时应该使用StringBuilder/StringBuffer 代替。由于Java虚拟机不仅要花时间生成对象，以后可能还需要花时间对这些对象进行垃圾回收和处理，因此，生成过多的对象将会给程序的性能带来很大的影响。</p>
<h3 id="尽可能使用局部变量"><a href="#尽可能使用局部变量" class="headerlink" title="尽可能使用局部变量"></a>尽可能使用局部变量</h3><p>调用方法时传递的参数以及在调用中创建的临时变量都保存在栈中速度较快，其他变量，如静态变量、实例变量等，都在堆中创建，速度较慢。另外，栈中创建的变量，随着方法的运行结束，这些内容就没了，不需要额外的垃圾回收。</p>
<h3 id="尽量避免随意使用静态变量"><a href="#尽量避免随意使用静态变量" class="headerlink" title="尽量避免随意使用静态变量"></a>尽量避免随意使用静态变量</h3><p>要知道，当某个对象被定义为static的变量所引用，那么GC通常是不会回收这个对象所占有的堆内存的，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>此时静态变量 b 的生命周期与 A 类相同，如果 A 类不被卸载，那么引用 B 指向的 B 对象会常驻内存，直到程序终止。</code></p>
<h3 id="将常量声明为static-final，并以大写命名"><a href="#将常量声明为static-final，并以大写命名" class="headerlink" title="将常量声明为static final，并以大写命名"></a>将常量声明为static final，并以大写命名</h3><p>这样在编译期间就可以把这些内容放入常量池中，避免运行期间计算生成常量的值。另外，将常量的名字以大写命名也可以方便区分出常量与变量</p>
<h3 id="不要让public方法中有太多的形参"><a href="#不要让public方法中有太多的形参" class="headerlink" title="不要让public方法中有太多的形参"></a>不要让public方法中有太多的形参</h3><p>public 方法即对外提供的方法，如果给这些方法太多形参的话主要有两点坏处：</p>
<ul>
<li>违反了面向对象的编程思想，Java讲求一切都是对象，太多的形参，和面向对象的编程思想并不契合</li>
<li>参数太多势必导致方法调用的出错概率增加</li>
</ul>
<p>至于这个“太多”指的是多少个，<code>3、4个</code>吧。比如我们用 JDBC 写一个 insertStudentInfo() 方法，有10个学生信息字段要插入 Student 表中，可以把这10个参数封装在一个实体类中，作为 insert() 方法的形参。</p>
<h3 id="不要对超出范围的基本数据类型做向下强制转型"><a href="#不要对超出范围的基本数据类型做向下强制转型" class="headerlink" title="不要对超出范围的基本数据类型做向下强制转型"></a>不要对超出范围的基本数据类型做向下强制转型</h3><p>这绝不会得到想要的结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l = <span class="number">12345678901234L</span>;</span><br><span class="line">    <span class="keyword">int</span> i = (<span class="keyword">int</span>) l;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可能期望得到其中的某几位，但是结果却是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1942892530</span><br></pre></td></tr></table></figure>
<p>解释一下。Java 中 long是8个字节64位的，所以12345678901234在计算机中的表示应该是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0000 0000 0000 0000 0000 1011 0011 1010 0111 0011 1100 1110 0010 1111 1111 0010</span><br></pre></td></tr></table></figure>
<p>一个 int 型数据是4个字节32位的，从低位取出上面这串二进制数据的前32位是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0111 0011 1100 1110 0010 1111 1111 0010</span><br></pre></td></tr></table></figure>
<p>这串二进制表示为十进制1942892530，所以就是我们上面的控制台上输出的内容。从这个例子上还能顺便得到两个结论：</p>
<ul>
<li>整型默认的数据类型是int，longl=12345678901234L，这个数字已经超出了int的范围了，所以最后有一个L，表示这是一个long型数。顺便，浮点型的默认类型是 double，所以定义 float 的时候要写成float f = 3.5f</li>
<li>接下来再写一句 int ii = l + i; 会报错，因为 long + int 是一个long，不能赋值给 int</li>
</ul>
<h3 id="尽量采用懒加载的策略"><a href="#尽量采用懒加载的策略" class="headerlink" title="尽量采用懒加载的策略"></a>尽量采用懒加载的策略</h3><p>即在需要的时候才创建，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"aaa"</span>;</span><br><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">    String str = <span class="string">"aaa"</span>;</span><br><span class="line">    list.add(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="尽量在合适的场合使用单例"><a href="#尽量在合适的场合使用单例" class="headerlink" title="尽量在合适的场合使用单例"></a>尽量在合适的场合使用单例</h3><p>使用单例可以减轻加载的负担、缩短加载的时间、提高加载的效率，但并不是所有地方都适用于单例，简单来说，单例主要适用于以下三个方面：</p>
<ul>
<li>控制资源的使用，通过线程同步来控制资源的并发访问</li>
<li>控制实例的产生，以达到节约资源的目的</li>
<li>控制数据的共享，在不建立直接关联的条件下，让多个不相关的进程或线程之间实现通信</li>
</ul>
<h3 id="慎用异常"><a href="#慎用异常" class="headerlink" title="慎用异常"></a>慎用异常</h3><ul>
<li>异常对性能不利。</li>
<li>抛出异常首先要创建一个新的对象，Throwable接口的构造函数调用名为fillInStackTrace()的本地同步方法，fillInStackTrace()方法检查堆栈，收集调用跟踪信息。</li>
<li>只要有异常被抛出，Java虚拟机就必须调整调用堆栈，因为在处理过程中创建了一个新的对象。</li>
<li>异常只能用于错误处理，不应该用来控制程序流程。</li>
</ul>
<h3 id="不要在循环中使用try…catch…"><a href="#不要在循环中使用try…catch…" class="headerlink" title="不要在循环中使用try…catch…"></a>不要在循环中使用try…catch…</h3><p>应该把其放在最外层，除非不得已。如果毫无理由地这么写了，只要你的领导资深一点、有强迫症一点，八成就要骂你为什么写出这种垃圾代码来了。</p>
<h3 id="及时关闭流"><a href="#及时关闭流" class="headerlink" title="及时关闭流"></a>及时关闭流</h3><p>Java 编程过程中，进行数据库连接、I/O流操作时务必小心，在使用完毕后，及时关闭以释放资源。因为对这些大对象的操作会造成系统大的开销，稍有不慎，将会导致严重的后果。</p>
<h3 id="对资源的close-建议分开操作"><a href="#对资源的close-建议分开操作" class="headerlink" title="对资源的close()建议分开操作"></a>对资源的close()建议分开操作</h3><p>意思是，比如我有这么一段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    XXX.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    YYY.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可避免资源泄露。万一 XXX.close() 抛异常，进入了 catch 块中，YYY.close()不会执行，资源不会回收，一直占用，可能引起资源泄露的。而改为上面的写法之后，就保证了无论如何 XXX 和 YYY 都会被 close 掉。</p>
<h3 id="尽量减少对变量的重复计算"><a href="#尽量减少对变量的重复计算" class="headerlink" title="尽量减少对变量的重复计算"></a>尽量减少对变量的重复计算</h3><p>明确一个概念，对方法的调用，即使方法中只有一句语句，也是有消耗的，包括创建栈帧、调用方法时保护现场、调用方法完毕时恢复现场等。所以例如下面的操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议替换为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, <span class="keyword">int</span> length = list.size(); i &lt; length; i++) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，在 list.size() 很大的时候，就减少了很多的消耗。</p>
<h3 id="为底层以数组方式实现的集合、工具类指定初始长度"><a href="#为底层以数组方式实现的集合、工具类指定初始长度" class="headerlink" title="为底层以数组方式实现的集合、工具类指定初始长度"></a>为底层以数组方式实现的集合、工具类指定初始长度</h3><p>如果能估计到待添加的内容长度，比如ArrayList、LinkedLlist、StringBuilder、StringBuffer、HashMap、HashSet等等，以 StringBuilder 为例：</p>
<ul>
<li>StringBuilder() // 默认分配16个字符的空间</li>
<li>StringBuilder(int size) // 默认分配size个字符的空间</li>
<li>StringBuilder(String str) // 默认分配16个字符+str.length()个字符空间</li>
</ul>
<p>可以通过类的来设定它的初始化容量，这样可以明显地提升性能。<br>比如<code>当StringBuilder达到最大容量的时候，它会将自身容量增加到当前的2倍再加2，无论何时只要StringBuilder达到它的最大容量，它就不得不创建一个新的字符数组然后将旧的字符数组内容拷贝到新字符数组中，这是十分耗费性能的一个操作</code>。<br>试想，如果能预估到字符数组中大概要存放5000个字符而不指定长度，最接近5000的2次幂是4096，每次扩容加的2不管，那么：</p>
<blockquote>
<p>在4096的基础上，再申请8194个大小的字符数组，加起来相当于一次申请了12290个大小的字符数组，如果一开始能指定5000个大小的字符数组，就节省了一倍以上的空间；把原来的4096个字符拷贝到新的的字符数组中去。</p>
</blockquote>
<p>这样，既浪费内存空间又降低代码运行效率。所以，给底层以数组实现的集合、工具类设置一个合理的初始化容量是错不了的，这会带来立竿见影的效果。<br><code>注：像 HashMap 这种是以数组+链表实现的集合，别把初始大小和你估计的大小设置得一样，因为一个table上只连接一个对象的可能性几乎为0。初始大小建议设置为2的N次幂，如果能估计到有2000个元素，设置成 new HashMap(128)、new HashMap(256) 都可以。</code></p>
<h3 id="当复制大量数据时"><a href="#当复制大量数据时" class="headerlink" title="当复制大量数据时"></a>当复制大量数据时</h3><p>使用System.arraycopy()方法</p>
<h3 id="乘法和除法使用移位操作"><a href="#乘法和除法使用移位操作" class="headerlink" title="乘法和除法使用移位操作"></a>乘法和除法使用移位操作</h3><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) &#123;</span><br><span class="line">    a = val * <span class="number">8</span>;</span><br><span class="line">    b = val / <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用移位操作可以极大地提高性能，因为在计算机底层，对位的操作是最方便、最快的，因此建议修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (val = <span class="number">0</span>; val &lt; <span class="number">100000</span>; val += <span class="number">5</span>) &#123;</span><br><span class="line">    a = val &lt;&lt; <span class="number">3</span>;</span><br><span class="line">    b = val &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>移位操作虽然快，但是可能会使代码不太好理解，因此最好加上相应的注释。</p>
<h3 id="循环内不要不断创建对象引用"><a href="#循环内不要不断创建对象引用" class="headerlink" title="循环内不要不断创建对象引用"></a>循环内不要不断创建对象引用</h3><p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种做法会导致内存中有count份Object对象引用存在，count很大的话，就耗费内存了，建议为改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= count; i++) &#123;</span><br><span class="line">    obj = <span class="keyword">new</span> Object();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的话，<code>内存中只有一份Object对象引用，每次new Object()的时候，Object对象引用指向不同的Object罢了，但是内存中只有一份</code>，这样就大大节省了内存空间了。</p>
<h3 id="把一个基本数据类型转为字符串"><a href="#把一个基本数据类型转为字符串" class="headerlink" title="把一个基本数据类型转为字符串"></a>把一个基本数据类型转为字符串</h3><ul>
<li>基本数据类型.toString()：最快<br>Integer.toString() 直接调用</li>
<li>String.valueOf(数据)：次之<br>String.valueOf() 方法底层调用了Integer.toString()方法，但是会在调用前做空判断</li>
<li>数据+：最慢<br>i + “”底层使用了 StringBuilder 实现，先用 append() 方法拼接，再用 toString() 方法获取字符串</li>
</ul>
<h3 id="字符串变量和字符串常量equals"><a href="#字符串变量和字符串常量equals" class="headerlink" title="字符串变量和字符串常量equals"></a>字符串变量和字符串常量equals</h3><p>将字符串常量写在前面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (str.equals(<span class="string">"123"</span>)) &#123;</span><br><span class="line">   ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议修改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String str = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">"123"</span>.equals(str))  &#123;</span><br><span class="line">    ... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么做<code>主要是可以避免空指针异常</code>。</p>
<h3 id="不要对数组使用toString-方法"><a href="#不要对数组使用toString-方法" class="headerlink" title="不要对数组使用toString()方法"></a>不要对数组使用toString()方法</h3><p>数组使用toString()打印出来的是什么：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] is = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    System.out.println(is.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[I@18a992f</span><br></pre></td></tr></table></figure>
<p>本意是想打印出数组内容，却有<code>可能因为数组引用is为空而导致空指针异常</code>。但是对集合toString()是可以打印出集合里面的内容的，因为<code>集合的父类 AbstractCollections 重写了 Object 的 toString() 方法</code>。</p>
<h3 id="基于效率和类型检查的考虑"><a href="#基于效率和类型检查的考虑" class="headerlink" title="基于效率和类型检查的考虑"></a>基于效率和类型检查的考虑</h3><p>应该尽可能使用array，无法确定数组大小时才使用ArrayList</p>
<h3 id="尽量使用HashMap、ArrayList、StringBuilder"><a href="#尽量使用HashMap、ArrayList、StringBuilder" class="headerlink" title="尽量使用HashMap、ArrayList、StringBuilder"></a>尽量使用HashMap、ArrayList、StringBuilder</h3><p>除非线程安全需要，否则不推荐使用Hashtable、Vector、StringBuffer，后三者由于使用同步机制而导致了性能开销</p>
<h3 id="不要将数组声明为public-static-final"><a href="#不要将数组声明为public-static-final" class="headerlink" title="不要将数组声明为public static final"></a>不要将数组声明为public static final</h3><p>因为这毫无意义，这样<code>只是定义了引用为static final，数组的内容还是可以随意改变的</code>，<code>将数组声明为public更是一个安全漏洞，这意味着这个数组可以被外部类所改变</code>。</p>
<h3 id="ArrayList和LinkedList的选择"><a href="#ArrayList和LinkedList的选择" class="headerlink" title="ArrayList和LinkedList的选择"></a>ArrayList和LinkedList的选择</h3><p>顺序插入和随机访问比较多的场景使用ArrayList，元素删除和中间插入比较多的场景使用LinkedList这个，理解ArrayList和LinkedList的原理就知道了</p>
<h3 id="公用集合中不使用的数据必须及时remove"><a href="#公用集合中不使用的数据必须及时remove" class="headerlink" title="公用集合中不使用的数据必须及时remove"></a>公用集合中不使用的数据必须及时remove</h3><p>如果一个集合类是公用的（也就是说不是方法里面的属性），那么这个集合里面的元素是不会自动释放的，因为始终有引用指向它们。所以，如果公用集合里面的某些数据不使用而不去remove掉它们，那么将会造成这个公用集合不断增大，使得系统有内存泄露的隐患。</p>
<h3 id="实现RandomAccess接口的集合"><a href="#实现RandomAccess接口的集合" class="headerlink" title="实现RandomAccess接口的集合"></a>实现RandomAccess接口的集合</h3><p>比如ArrayList，应当使用最普通的for循环而不是foreach循环来遍历，这是 JDK 推荐给用户的。<br>JDK API 对于 RandomAccess接口的解释是：实现RandomAccess接口用来表明其支持快速随机访问，此接口的主要目的是允许一般的算法更改其行为，从而将其应用到随机或连续访问列表时能提供良好的性能。<br>实际经验表明，<code>实现RandomAccess接口的类实例，假如是随机访问的，使用普通 for 循环效率将高于使用foreach循环</code>；反过来，<code>如果是顺序访问的，则使用 Iterator 会效率更高</code>。<br><code>参见Java语法糖1：可变长度参数以及 foreach 循环原理。</code></p>
<h3 id="使用最有效率的方式去遍历Map"><a href="#使用最有效率的方式去遍历Map" class="headerlink" title="使用最有效率的方式去遍历Map"></a>使用最有效率的方式去遍历Map</h3><p>遍历 Map 的方式有很多，通常场景下我们需要的是遍历 Map 中的 Key 和 Value，那么推荐使用的、效率最高的方式是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    map.put(<span class="string">"111"</span>, <span class="string">"222"</span>);</span><br><span class="line">    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = entrySet.iterator();</span><br><span class="line">    <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        Map.Entry&lt;String, String&gt; entry = iter.next();</span><br><span class="line">        System.out.println(entry.getKey() + <span class="string">"    "</span> + entry.getValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>只是想遍历一下这个 Map的 key 值，那用 Set keySet = map.keySet(); 会比较合适一些</code></p>
<h3 id="使用同步代码块替代同步方法"><a href="#使用同步代码块替代同步方法" class="headerlink" title="使用同步代码块替代同步方法"></a>使用同步代码块替代同步方法</h3><p>除非能确定一整个方法都是需要进行同步的，否则尽量使用同步代码块，避免对那些不需要进行同步的代码也进行了同步，影响了代码执行效率。</p>
<h3 id="使用带缓冲的输入输出流进行IO操作"><a href="#使用带缓冲的输入输出流进行IO操作" class="headerlink" title="使用带缓冲的输入输出流进行IO操作"></a>使用带缓冲的输入输出流进行IO操作</h3><p>带缓冲的输入输出流，即 BufferedReader、BufferedWriter、BufferedInputStream、BufferedOutputStream，这可以极大地提升 IO 效率。</p>
<h3 id="程序运行过程中避免使用反射"><a href="#程序运行过程中避免使用反射" class="headerlink" title="程序运行过程中避免使用反射"></a>程序运行过程中避免使用反射</h3><p>反射是 Java 提供给用户一个很强大的功能，功能强大往往意味着效率不高。<br>不建议在程序运行过程中使用尤其是频繁使用反射机制，特别是 Method 的 invoke() 方法，如果确实有必要，一种建议性的做法是<code>将那些需要通过反射加载的类在项目启动的时候通过反射实例化出一个对象并放入内存</code>，用户只关心和对端交互的时候获取最快的响应速度，并不关心项目启动花多久时间。</p>
<h3 id="使用数据库连接池和线程池"><a href="#使用数据库连接池和线程池" class="headerlink" title="使用数据库连接池和线程池"></a>使用数据库连接池和线程池</h3><p>这两个池都是用于重用对象的，<code>前者可以避免频繁地打开和关闭连接</code>，<code>后者可以避免频繁地创建和销毁线程</code>。</p>
<h3 id="及时清除不再需要的会话"><a href="#及时清除不再需要的会话" class="headerlink" title="及时清除不再需要的会话"></a>及时清除不再需要的会话</h3><p>为了清除不再活动的会话，许多应用服务器都有默认的会话超时时间，一般为30分钟。当应用服务器需要保存更多的会话时，如果内存不足，那么操作系统会把部分数据转移到磁盘，应用服务器也可能根据MRU（最近最频繁使用）算法把部分不活跃的会话转储到磁盘，甚至可能抛出内存不足的异常。如果会话要被转储到磁盘，那么必须要先被序列化，在大规模集群中，对对象进行序列化的代价是很昂贵的。因此，当会话不再需要时，应当及时调用 HttpSession 的 invalidate() 方法清除会话。</p>
<blockquote>
<p>原文：<a href="https://mp.weixin.qq.com/s/RgpEaHrVnFOuLVQ-qfMfIw" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/RgpEaHrVnFOuLVQ-qfMfIw</a></p>
</blockquote>
</div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/">代码优化</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/10/27/KF5GYAWmP6EIyvB.jpg" data-sites="wechat,weibo,qq,facebook,twitter"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button" type="button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/file/wechat.jpg" alt="微信" onclick="window.open('/file/wechat.jpg')"/><div class="post-qr-code__desc">微信</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/09/16/Java%E4%B8%AD%E9%82%A318%E6%8A%8A%E9%87%91%E5%88%9A%E9%94%81/"><img class="prev-cover" data-src="https://i.loli.net/2021/09/16/sZXckh2A83uMfVe.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java中那18把&quot;金刚&quot;锁</div></div></a></div><div class="next-post pull-right"><a href="/2021/09/07/%E5%B8%B8%E8%A7%81%E7%9A%84for%E5%BE%AA%E7%8E%AF%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F/"><img class="next-cover" data-src="https://i.loli.net/2021/09/07/PQtzrXYN6nhxp2F.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">常见的for循环优化方式</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fas fa-thumbs-up fa-fw"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/09/07/常见的for循环优化方式/" title="常见的for循环优化方式"><img class="relatedPosts_cover" data-src="https://i.loli.net/2021/09/07/PQtzrXYN6nhxp2F.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-07</div><div class="relatedPosts_title">常见的for循环优化方式</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headling"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div class="comments-items-1" data-name="Valine"><div class="vcomment" id="vcomment"></div><script>function loadvaline () {  
  var requestSetting = function (from,set) {
    var from = from
    var setting = set.split(',').filter(function(item){
    return from.indexOf(item) > -1
    });
    setting = setting.length == 0 ? from :setting;
    return setting
  }

  var guestInfo = requestSetting(['nick','mail','link'],'nick,mail,link')
  var requiredFields = requestSetting(['nick','mail'],'nick,mail')

  function initValine () {
    window.valine = new Valine({
      el:'#vcomment',
      appId: 'eKp2wzPKybiFid4KXcVFcyMX-gzGzoHsz',
      appKey: 'RSA7FDJfrFwpawTfG1vE6R71',
      placeholder: 'minkeyto@qq.com',
      avatar: 'monsterid',
      meta: guestInfo,
      pageSize: '10',
      lang: 'zh-CN',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      requiredFields: requiredFields
    });
  }
  loadScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js', initValine)
}

if ('Valine' === 'Valine' || false) {
  window.addEventListener('load', loadvaline)
}
else {
  function loadOtherComment () {
    loadvaline()
  }
}</script></div></div></div></article></main><footer id="footer" style="background-image: url(https://i.loli.net/2021/09/15/9VmfNJWSuRtZHj2.jpg)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By 灵熙云</div><div class="framework-info"><span>Copyright Ⓒ 灵熙云工作室. All rights reserved.</span></div><div class="footer_custom_text">Hi, welcome to my blog !</div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script defer id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = false;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script src="/js/search/local-search.js"></script><script>if (document.getElementsByClassName('mermaid').length) {
  loadScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js',function () {
    mermaid.initialize({
      theme: 'default',
  })
})
}</script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>